{"path":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9","date":1270985469,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10","date":1270996866,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4","date":1271167458,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6267e1ce56c2eec111425690cd04e251b6f14952","date":1275222352,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cd8367c3d48e4b63dee1895a261d4986c716bbb","date":1279637747,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"257da767277782760db0814096b999899995b2b1","date":1289498882,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ba9135468ec4b027cb08a206cba13633a410e8c","date":1289559681,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["d8a2ba2f29c523b1ce4db7c3491d01615d912b15","0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c498d3f8d75170b121f5eda2c6210ac5beb5d411","date":1289726298,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac","date":1290886721,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":["d8a2ba2f29c523b1ce4db7c3491d01615d912b15"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1efe3edca215dd9891cb42af283fed96f792ca0","date":1320428891,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(\"segments.gen version number invalid: \" + version +\n                    \" (must be \" + FORMAT_SEGMENTS_GEN_CURRENT + \")\");\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af9b2f910f7011e60325d367a3aefa7a319d3ba7","date":1324575573,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                } else {\n                  /* TODO: Investigate this! \n                  throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n                  */\n                }\n              } catch (IOException err2) {\n                // rethrow any format exception\n                if (err2 instanceof CorruptIndexException) throw err2;\n                // else will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      int retryCount = 0;\n\n      boolean useFirstMethod = true;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel (when\n      // useFirstMethod is true), and fall back to the third\n      // when necessary.\n\n      while(true) {\n\n        if (useFirstMethod) {\n\n          // List the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null) {\n            genA = getCurrentSegmentGeneration(files);\n          }\n          \n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Also open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gens.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          IndexInput genInput = null;\n          try {\n            genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN, IOContext.READONCE);\n          } catch (FileNotFoundException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n            }\n          } catch (IOException e) {\n            if (infoStream != null) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n          }\n  \n          if (genInput != null) {\n            try {\n              int version = genInput.readInt();\n              if (version == FORMAT_SEGMENTS_GEN_CURRENT) {\n                long gen0 = genInput.readLong();\n                long gen1 = genInput.readLong();\n                if (infoStream != null) {\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                }\n                if (gen0 == gen1) {\n                  // The file is consistent.\n                  genB = gen0;\n                }\n              } else {\n                throw new IndexFormatTooNewException(genInput, version, FORMAT_SEGMENTS_GEN_CURRENT, FORMAT_SEGMENTS_GEN_CURRENT);\n              }\n            } catch (IOException err2) {\n              // rethrow any format exception\n              if (err2 instanceof CorruptIndexException) throw err2;\n            } finally {\n              genInput.close();\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          gen = Math.max(genA, genB);\n\n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new IndexNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        if (useFirstMethod && lastGen == gen && retryCount >= 2) {\n          // Give up on first method -- this is 3rd cycle on\n          // listing directory and checking gen file to\n          // attempt to locate the segments file.\n          useFirstMethod = false;\n        }\n\n        // Second method: since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (!useFirstMethod) {\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          } else {\n            // All attempts have failed -- throw first exc:\n            throw exc;\n          }\n        } else if (lastGen == gen) {\n          // This means we're about to try the same\n          // segments_N last tried.\n          retryCount++;\n        } else {\n          // Segment file has advanced since our last loop\n          // (we made \"progress\"), so reset retryCount:\n          retryCount = 0;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retryCount=\" + retryCount + \"; gen = \" + gen);\n          }\n\n          if (gen > 1 && useFirstMethod && retryCount == 1) {\n\n            // This is our second time trying this same segments\n            // file (because retryCount is 1), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["85a883878c0af761245ab048babc63d099f835f3","0ba9135468ec4b027cb08a206cba13633a410e8c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["af9b2f910f7011e60325d367a3aefa7a319d3ba7"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"85a883878c0af761245ab048babc63d099f835f3":["0cd8367c3d48e4b63dee1895a261d4986c716bbb","257da767277782760db0814096b999899995b2b1"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["6267e1ce56c2eec111425690cd04e251b6f14952"],"5f4e87790277826a2aea119328600dfb07761f32":["6267e1ce56c2eec111425690cd04e251b6f14952","0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10":["b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9"],"6267e1ce56c2eec111425690cd04e251b6f14952":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"257da767277782760db0814096b999899995b2b1":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"af9b2f910f7011e60325d367a3aefa7a319d3ba7":["f1efe3edca215dd9891cb42af283fed96f792ca0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ba9135468ec4b027cb08a206cba13633a410e8c":["257da767277782760db0814096b999899995b2b1"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac","639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"3bb13258feba31ab676502787ab2e1779f129b7a":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac":["0ba9135468ec4b027cb08a206cba13633a410e8c"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["3bb13258feba31ab676502787ab2e1779f129b7a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["af9b2f910f7011e60325d367a3aefa7a319d3ba7"],"85a883878c0af761245ab048babc63d099f835f3":["c498d3f8d75170b121f5eda2c6210ac5beb5d411"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["85a883878c0af761245ab048babc63d099f835f3","5f4e87790277826a2aea119328600dfb07761f32","257da767277782760db0814096b999899995b2b1"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"6267e1ce56c2eec111425690cd04e251b6f14952":["0cd8367c3d48e4b63dee1895a261d4986c716bbb","5f4e87790277826a2aea119328600dfb07761f32"],"257da767277782760db0814096b999899995b2b1":["85a883878c0af761245ab048babc63d099f835f3","0ba9135468ec4b027cb08a206cba13633a410e8c"],"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4":["6267e1ce56c2eec111425690cd04e251b6f14952"],"af9b2f910f7011e60325d367a3aefa7a319d3ba7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0ba9135468ec4b027cb08a206cba13633a410e8c":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["f1efe3edca215dd9891cb42af283fed96f792ca0","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"3bb13258feba31ab676502787ab2e1779f129b7a":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9"],"d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5d004d0e0b3f65bb40da76d476d659d7888270e8","ddc4c914be86e34b54f70023f45a60fa7f04e929","3bb13258feba31ab676502787ab2e1779f129b7a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5d004d0e0b3f65bb40da76d476d659d7888270e8","3bb13258feba31ab676502787ab2e1779f129b7a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}