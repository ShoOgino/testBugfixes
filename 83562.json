{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields inclued in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      Document luceneDocument = cmd.getLuceneDocument(false);\n      log.debug(\"updateDocument({})\", cmd);\n      writer.updateDocument(updateTerm, luceneDocument);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields inclued in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      Document luceneDocument = cmd.getLuceneDocument(false);\n      log.debug(\"updateDocument({})\", cmd);\n      writer.updateDocument(updateTerm, luceneDocument);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407b2e02aedce6b9118323ef204a08acfd83add7","date":1487217081,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields inclued in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields inclued in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      Document luceneDocument = cmd.getLuceneDocument(false);\n      log.debug(\"updateDocument({})\", cmd);\n      writer.updateDocument(updateTerm, luceneDocument);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields inclued in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields inclued in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5ce7c704ca874aa623a99f2669737b52ec71cfc","date":1528728510,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument}(s) as\n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer) throws IOException {\n    assert idField != null; // this code path requires an idField in order to potentially replace a doc\n    boolean hasUpdateTerm = cmd.updateTerm != null; // AKA dedupe\n\n    if (cmd.isInPlaceUpdate()) {\n      if (hasUpdateTerm) {\n        throw new IllegalStateException(\"cmd.updateTerm/dedupe is not compatible with in-place updates\");\n      }\n      // we don't support the solrInputDoc with nested child docs either but we'll throw an exception if attempted\n\n      Term updateTerm = new Term(idField.getName(), cmd.getIndexedId());\n      Document luceneDocument = cmd.getLuceneDocument();\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(updateTerm.field()) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n\n    } else { // more normal path\n\n      Iterable<Document> blockDocs = cmd.getLuceneDocsIfNested();\n      boolean isBlock = blockDocs != null; // AKA nested child docs\n      Term idTerm = new Term(isBlock ? IndexSchema.ROOT_FIELD_NAME : idField.getName(), cmd.getIndexedId());\n      Term updateTerm = hasUpdateTerm ? cmd.updateTerm : idTerm;\n      if (isBlock) {\n        log.debug(\"updateDocuments({})\", cmd);\n        writer.updateDocuments(updateTerm, blockDocs);\n      } else {\n        Document luceneDocument = cmd.getLuceneDocument();\n        log.debug(\"updateDocument({})\", cmd);\n        writer.updateDocument(updateTerm, luceneDocument);\n      }\n\n      // If hasUpdateTerm, then delete any existing documents with the same ID other than the one added above\n      //   (used in near-duplicate replacement)\n      if (hasUpdateTerm) { // rare\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        bq.add(new TermQuery(updateTerm), Occur.MUST_NOT); //don't want the one we added above (will be unique)\n        bq.add(new TermQuery(idTerm), Occur.MUST); // same ID\n        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":4,"author":"Michael Braun","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":null,"sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":4,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#updateDocOrDocValues(AddUpdateCommand,IndexWriter,Term).mjava","sourceNew":null,"sourceOld":"  /**\n   * Calls either {@link IndexWriter#updateDocValues} or {@link IndexWriter#updateDocument} as \n   * needed based on {@link AddUpdateCommand#isInPlaceUpdate}.\n   * <p>\n   * If the this is an UPDATE_INPLACE cmd, then all fields included in \n   * {@link AddUpdateCommand#getLuceneDocument} must either be the uniqueKey field, or be DocValue \n   * only fields.\n   * </p>\n   *\n   * @param cmd - cmd apply to IndexWriter\n   * @param writer - IndexWriter to use\n   * @param updateTerm - used if this cmd results in calling {@link IndexWriter#updateDocument}\n   */\n  private void updateDocOrDocValues(AddUpdateCommand cmd, IndexWriter writer, Term updateTerm) throws IOException {\n    assert null != cmd;\n    final SchemaField uniqueKeyField = cmd.req.getSchema().getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    if (cmd.isInPlaceUpdate()) {\n      Document luceneDocument = cmd.getLuceneDocument(true);\n\n      final List<IndexableField> origDocFields = luceneDocument.getFields();\n      final List<Field> fieldsToUpdate = new ArrayList<>(origDocFields.size());\n      for (IndexableField field : origDocFields) {\n        if (! field.name().equals(uniqueKeyFieldName) ) {\n          fieldsToUpdate.add((Field)field);\n        }\n      }\n      log.debug(\"updateDocValues({})\", cmd);\n      writer.updateDocValues(updateTerm, fieldsToUpdate.toArray(new Field[fieldsToUpdate.size()]));\n    } else {\n      updateDocument(cmd, writer, updateTerm);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["407b2e02aedce6b9118323ef204a08acfd83add7","61c45e99cf6676da48f19d7511c73712ad39402b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["61c45e99cf6676da48f19d7511c73712ad39402b","c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"61c45e99cf6676da48f19d7511c73712ad39402b":["407b2e02aedce6b9118323ef204a08acfd83add7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["61c45e99cf6676da48f19d7511c73712ad39402b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"407b2e02aedce6b9118323ef204a08acfd83add7":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["61c45e99cf6676da48f19d7511c73712ad39402b","c5ce7c704ca874aa623a99f2669737b52ec71cfc"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","407b2e02aedce6b9118323ef204a08acfd83add7"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c5ce7c704ca874aa623a99f2669737b52ec71cfc","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"407b2e02aedce6b9118323ef204a08acfd83add7":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}