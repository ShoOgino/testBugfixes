{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","commits":[{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":1,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88922bf68f0b509aba218f1b9e7ef5981b4d13bc","date":1570820823,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#doDefensiveChecks(DistribPhase).mjava","sourceNew":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: {}\", req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","sourceOld":"  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n\n    String from = req.getParams().get(DISTRIB_FROM);\n\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"740d649f013f07efbeb73ca854f106c60166e7c0":["88922bf68f0b509aba218f1b9e7ef5981b4d13bc"],"88922bf68f0b509aba218f1b9e7ef5981b4d13bc":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"],"b0b597c65628ca9e73913a07e81691f8229bae35":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87","88922bf68f0b509aba218f1b9e7ef5981b4d13bc"]},"commit2Childs":{"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"88922bf68f0b509aba218f1b9e7ef5981b4d13bc":["740d649f013f07efbeb73ca854f106c60166e7c0","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["88922bf68f0b509aba218f1b9e7ef5981b4d13bc","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}