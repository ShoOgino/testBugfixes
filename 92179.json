{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","commits":[{"id":"d9d5abf772262a05c74afddcadc95c4bdab07f1f","date":1381747682,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","pathOld":"/dev/null","sourceNew":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<Range>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max))  {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else  {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe","date":1384867512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","sourceNew":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<Range>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max)) {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","sourceOld":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<Range>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max))  {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else  {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","sourceNew":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<Range>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max)) {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","sourceOld":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<Range>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max))  {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else  {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/CompositeIdRouter#partitionRangeByKey(String,Range).mjava","sourceNew":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max)) {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","sourceOld":"  public List<Range> partitionRangeByKey(String key, Range range) {\n    List<Range> result = new ArrayList<Range>(3);\n    Range keyRange = keyHashRange(key);\n    if (!keyRange.overlaps(range)) {\n      throw new IllegalArgumentException(\"Key range does not overlap given range\");\n    }\n    if (keyRange.equals(range)) {\n      return Collections.singletonList(keyRange);\n    } else if (keyRange.isSubsetOf(range)) {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(keyRange);\n      result.add((new Range(keyRange.max + 1, range.max)));\n    } else if (range.includes(keyRange.max)) {\n      result.add(new Range(range.min, keyRange.max));\n      result.add(new Range(keyRange.max + 1, range.max));\n    } else {\n      result.add(new Range(range.min, keyRange.min - 1));\n      result.add(new Range(keyRange.min, range.max));\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d9d5abf772262a05c74afddcadc95c4bdab07f1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["d9d5abf772262a05c74afddcadc95c4bdab07f1f","c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["d9d5abf772262a05c74afddcadc95c4bdab07f1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9d5abf772262a05c74afddcadc95c4bdab07f1f"],"d9d5abf772262a05c74afddcadc95c4bdab07f1f":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}