{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentReader#SegmentReader(SegmentCommitInfo,int,boolean,IOContext,Map[String,String]).mjava","commits":[{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentReader#SegmentReader(SegmentCommitInfo,int,boolean,IOContext,Map[String,String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentReader#SegmentReader(SegmentCommitInfo,int,boolean,IOContext).mjava","sourceNew":"  /**\n   * Constructs a new SegmentReader with a new core.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  SegmentReader(SegmentCommitInfo si, int createdVersionMajor, boolean openedFromWriter, IOContext context, Map<String, String> readerAttributes) throws IOException {\n    this.si = si.clone();\n    this.originalSi = si;\n    this.metaData = new LeafMetaData(createdVersionMajor, si.info.getMinVersion(), si.info.getIndexSort());\n\n    // We pull liveDocs/DV updates from disk:\n    this.isNRT = false;\n    \n    core = new SegmentCoreReaders(si.info.dir, si, openedFromWriter, context, readerAttributes);\n    segDocValues = new SegmentDocValues();\n    \n    boolean success = false;\n    final Codec codec = si.info.getCodec();\n    try {\n      if (si.hasDeletions()) {\n        // NOTE: the bitvector is stored using the regular directory, not cfs\n        hardLiveDocs = liveDocs = codec.liveDocsFormat().readLiveDocs(directory(), si, IOContext.READONCE);\n      } else {\n        assert si.getDelCount() == 0;\n        hardLiveDocs = liveDocs = null;\n      }\n      numDocs = si.info.maxDoc() - si.getDelCount();\n      \n      fieldInfos = initFieldInfos();\n      docValuesProducer = initDocValuesProducer();\n      assert assertLiveDocs(isNRT, hardLiveDocs, liveDocs);\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        doClose();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new SegmentReader with a new core.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  SegmentReader(SegmentCommitInfo si, int createdVersionMajor, boolean openedFromWriter, IOContext context) throws IOException {\n    this.si = si.clone();\n    this.originalSi = si;\n    this.metaData = new LeafMetaData(createdVersionMajor, si.info.getMinVersion(), si.info.getIndexSort());\n\n    // We pull liveDocs/DV updates from disk:\n    this.isNRT = false;\n    \n    core = new SegmentCoreReaders(si.info.dir, si, openedFromWriter, context);\n    segDocValues = new SegmentDocValues();\n    \n    boolean success = false;\n    final Codec codec = si.info.getCodec();\n    try {\n      if (si.hasDeletions()) {\n        // NOTE: the bitvector is stored using the regular directory, not cfs\n        hardLiveDocs = liveDocs = codec.liveDocsFormat().readLiveDocs(directory(), si, IOContext.READONCE);\n      } else {\n        assert si.getDelCount() == 0;\n        hardLiveDocs = liveDocs = null;\n      }\n      numDocs = si.info.maxDoc() - si.getDelCount();\n      \n      fieldInfos = initFieldInfos();\n      docValuesProducer = initDocValuesProducer();\n      assert assertLiveDocs(isNRT, hardLiveDocs, liveDocs);\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        doClose();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":5,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentReader#SegmentReader(SegmentCommitInfo,int,boolean,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentReader#SegmentReader(SegmentCommitInfo,int,boolean,IOContext,Map[String,String]).mjava","sourceNew":"  /**\n   * Constructs a new SegmentReader with a new core.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  SegmentReader(SegmentCommitInfo si, int createdVersionMajor, boolean openedFromWriter, IOContext context) throws IOException {\n    this.si = si.clone();\n    this.originalSi = si;\n    this.metaData = new LeafMetaData(createdVersionMajor, si.info.getMinVersion(), si.info.getIndexSort());\n\n    // We pull liveDocs/DV updates from disk:\n    this.isNRT = false;\n    \n    core = new SegmentCoreReaders(si.info.dir, si, openedFromWriter, context);\n    segDocValues = new SegmentDocValues();\n    \n    boolean success = false;\n    final Codec codec = si.info.getCodec();\n    try {\n      if (si.hasDeletions()) {\n        // NOTE: the bitvector is stored using the regular directory, not cfs\n        hardLiveDocs = liveDocs = codec.liveDocsFormat().readLiveDocs(directory(), si, IOContext.READONCE);\n      } else {\n        assert si.getDelCount() == 0;\n        hardLiveDocs = liveDocs = null;\n      }\n      numDocs = si.info.maxDoc() - si.getDelCount();\n      \n      fieldInfos = initFieldInfos();\n      docValuesProducer = initDocValuesProducer();\n      assert assertLiveDocs(isNRT, hardLiveDocs, liveDocs);\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        doClose();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new SegmentReader with a new core.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  SegmentReader(SegmentCommitInfo si, int createdVersionMajor, boolean openedFromWriter, IOContext context, Map<String, String> readerAttributes) throws IOException {\n    this.si = si.clone();\n    this.originalSi = si;\n    this.metaData = new LeafMetaData(createdVersionMajor, si.info.getMinVersion(), si.info.getIndexSort());\n\n    // We pull liveDocs/DV updates from disk:\n    this.isNRT = false;\n    \n    core = new SegmentCoreReaders(si.info.dir, si, openedFromWriter, context, readerAttributes);\n    segDocValues = new SegmentDocValues();\n    \n    boolean success = false;\n    final Codec codec = si.info.getCodec();\n    try {\n      if (si.hasDeletions()) {\n        // NOTE: the bitvector is stored using the regular directory, not cfs\n        hardLiveDocs = liveDocs = codec.liveDocsFormat().readLiveDocs(directory(), si, IOContext.READONCE);\n      } else {\n        assert si.getDelCount() == 0;\n        hardLiveDocs = liveDocs = null;\n      }\n      numDocs = si.info.maxDoc() - si.getDelCount();\n      \n      fieldInfos = initFieldInfos();\n      docValuesProducer = initDocValuesProducer();\n      assert assertLiveDocs(isNRT, hardLiveDocs, liveDocs);\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        doClose();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"763da4a9605e47013078edc323b9d4b608f0f9e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["763da4a9605e47013078edc323b9d4b608f0f9e0"]},"commit2Childs":{"763da4a9605e47013078edc323b9d4b608f0f9e0":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}