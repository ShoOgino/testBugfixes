{"path":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    return mergedDocs;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"833a7987bc1c94455fde83e3311f72bddedcfb93","date":1279951470,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01f60198ece724a6e96cd0b45f289cf42ff83d4f","date":1286864103,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    mergeIndexValues();\n\n    return mergedDocs;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e28c49f1fb6215a550fdadcf3805aa629b63ec0","date":1288081775,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n    return mergedDocs;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    mergeIndexValues();\n\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e06c9d5fba0a2f937941d199d64ccb32aac502d1","date":1292411167,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors()) {\n      mergeVectors();\n    }\n\n    return mergedDocs;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors()) {\n      mergeVectors();\n    }\n\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge(boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method\n   * into the directory passed to the constructor.\n   * @param mergeDocStores if false, we will not merge the\n   * stored fields nor vectors files\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final int merge(boolean mergeDocStores) throws CorruptIndexException, IOException {\n\n    this.mergeDocStores = mergeDocStores;\n    \n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n\n    mergedDocs = mergeFields();\n    mergeTerms();\n    mergeNorms();\n\n    if (mergeDocStores && fieldInfos.hasVectors())\n      mergeVectors();\n    return mergedDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e06c9d5fba0a2f937941d199d64ccb32aac502d1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["e06c9d5fba0a2f937941d199d64ccb32aac502d1"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["01f60198ece724a6e96cd0b45f289cf42ff83d4f"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"833a7987bc1c94455fde83e3311f72bddedcfb93":["9454a6510e2db155fb01faa5c049b06ece95fab9"]},"commit2Childs":{"e06c9d5fba0a2f937941d199d64ccb32aac502d1":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":[],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e06c9d5fba0a2f937941d199d64ccb32aac502d1","01f60198ece724a6e96cd0b45f289cf42ff83d4f","833a7987bc1c94455fde83e3311f72bddedcfb93"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"833a7987bc1c94455fde83e3311f72bddedcfb93":[]},"heads":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","cd5edd1f2b162a5cfa08efd17851a07373a96817","833a7987bc1c94455fde83e3311f72bddedcfb93"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}