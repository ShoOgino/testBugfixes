{"path":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","date":1550036130,"type":3,"author":"Bruno P. Kinoshita","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must periodically call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}