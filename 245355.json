{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","commits":[{"id":"fe4b37941dda041ab19456b15412aacb9c657a26","date":1429449253,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"/dev/null","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context, acceptDocs);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        parentDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery fromQuery = new BooleanQuery();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","date":1431446228,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context, acceptDocs);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery fromQuery = new BooleanQuery();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context, acceptDocs);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        parentDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery fromQuery = new BooleanQuery();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context, acceptDocs);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context, acceptDocs);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery fromQuery = new BooleanQuery();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context, acceptDocs);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f11f03fdb6e013cb2da7aa973c84bf9de326c56d","date":1436880767,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":["fe4b37941dda041ab19456b15412aacb9c657a26"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public float getValueForNormalization() throws IOException {\n            return 0;\n          }\n\n          @Override\n          public void normalize(float norm, float topLevelBoost) {\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                return (float) price.get(in.docID());\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6448f67be45147de82a85cd903fec34e8930da75","date":1477041277,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d9452e13e015fa1187b0b1bed1a1d08b9c96241","date":1485723373,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    // FunctionQuery would be helpful, but join module doesn't depend on queries module.\n    Query priceQuery = new Query() {\n\n      private final Query fieldQuery = new FieldValueQuery(priceField);\n\n      @Override\n      public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n        Weight fieldWeight = fieldQuery.createWeight(searcher, false, boost);\n        return new Weight(this) {\n\n          @Override\n          public void extractTerms(Set<Term> terms) {\n          }\n\n          @Override\n          public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n            return null;\n          }\n\n          @Override\n          public Scorer scorer(LeafReaderContext context) throws IOException {\n            Scorer fieldScorer = fieldWeight.scorer(context);\n            if (fieldScorer == null) {\n              return null;\n            }\n            NumericDocValues price = context.reader().getNumericDocValues(priceField);\n            return new FilterScorer(fieldScorer, this) {\n              @Override\n              public float score() throws IOException {\n                assertEquals(in.docID(), price.nextDoc());\n                return (float) price.longValue();\n              }\n            };\n          }\n        };\n      }\n\n      @Override\n      public String toString(String field) {\n        return fieldQuery.toString(field);\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        return o == this;\n      }\n\n      @Override\n      public int hashCode() {\n        return System.identityHashCode(this);\n      }\n\n    };\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    OrdinalMap ordinalMap = OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    OrdinalMap ordinalMap = OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxScore().mjava","sourceNew":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    OrdinalMap ordinalMap = OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits.value);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits.value);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxScore() throws Exception {\n    String priceField = \"price\";\n    Query priceQuery = numericDocValuesScoreQuery(priceField);\n\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    Map<String, Float> lowestScoresPerParent = new HashMap<>();\n    Map<String, Float> highestScoresPerParent = new HashMap<>();\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), 2, 16);\n      int lowest = Integer.MAX_VALUE;\n      int highest = Integer.MIN_VALUE;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        int price = random().nextInt(1000);\n        childDoc.add(new NumericDocValuesField(priceField, price));\n        iw.addDocument(childDoc);\n        lowest = Math.min(lowest, price);\n        highest = Math.max(highest, price);\n      }\n      lowestScoresPerParent.put(parentId, (float) lowest);\n      highestScoresPerParent.put(parentId, (float) highest);\n    }\n    iw.close();\n\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    OrdinalMap ordinalMap = OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    BooleanQuery.Builder fromQuery = new BooleanQuery.Builder();\n    fromQuery.add(priceQuery, BooleanClause.Occur.MUST);\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n    Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Min, ordinalMap);\n    TopDocs topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery.build(), toQuery, searcher, ScoreMode.Max, ordinalMap);\n    topDocs = searcher.search(joinQuery, numParents);\n    assertEquals(numParents, topDocs.totalHits);\n    for (int i = 0; i < topDocs.scoreDocs.length; i++) {\n      ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n      String id = searcher.doc(scoreDoc.doc).get(\"id\");\n      assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"957c610636f393a85a38f1af670540028db13e6b":["d211216c83f01894810543d1c107160a9ae3650b"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","9d9452e13e015fa1187b0b1bed1a1d08b9c96241"],"fe4b37941dda041ab19456b15412aacb9c657a26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["fe4b37941dda041ab19456b15412aacb9c657a26"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["f11f03fdb6e013cb2da7aa973c84bf9de326c56d"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"f11f03fdb6e013cb2da7aa973c84bf9de326c56d":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["d211216c83f01894810543d1c107160a9ae3650b","957c610636f393a85a38f1af670540028db13e6b"],"d211216c83f01894810543d1c107160a9ae3650b":["9d9452e13e015fa1187b0b1bed1a1d08b9c96241"],"6448f67be45147de82a85cd903fec34e8930da75":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["02e175abd2c4c1611c5a9647486ae8ba249a94c1","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6448f67be45147de82a85cd903fec34e8930da75"],"0e7bc21595222ae4f75509300fbb7726691f387f":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["0e7bc21595222ae4f75509300fbb7726691f387f"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["957c610636f393a85a38f1af670540028db13e6b"],"9d9452e13e015fa1187b0b1bed1a1d08b9c96241":["6448f67be45147de82a85cd903fec34e8930da75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","83788ad129a5154d5c6562c4e8ce3db48793aada"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"fe4b37941dda041ab19456b15412aacb9c657a26":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["f11f03fdb6e013cb2da7aa973c84bf9de326c56d"],"f11f03fdb6e013cb2da7aa973c84bf9de326c56d":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"d211216c83f01894810543d1c107160a9ae3650b":["957c610636f393a85a38f1af670540028db13e6b","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fe4b37941dda041ab19456b15412aacb9c657a26"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6448f67be45147de82a85cd903fec34e8930da75"],"6448f67be45147de82a85cd903fec34e8930da75":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","9d9452e13e015fa1187b0b1bed1a1d08b9c96241"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0e7bc21595222ae4f75509300fbb7726691f387f":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9d9452e13e015fa1187b0b1bed1a1d08b9c96241":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","d211216c83f01894810543d1c107160a9ae3650b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}