{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","commits":[{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"/dev/null","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<Integer>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrClient client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrClient client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrClient client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrServer client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrServer client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrServer client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92f789dbd1886e4b468e61b0def88b29a3f55228","date":1533844010,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    final SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrClient client : clients) {\n      SolrException e = expectThrows(SolrException.class, () -> client.add(sd));\n      assertEquals(409, e.code());\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    final SolrInputDocument sd2 =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd2);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrClient client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrClient client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrClient client : clients) {\n      try {\n        client.add(sd);\n        fail();\n      } catch (SolrException e) {\n        assertEquals(409, e.code());\n      }\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    sd =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrClient client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrClient client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doOptimisticLockingAndUpdating().mjava","sourceNew":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    final SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrClient client : clients) {\n      SolrException e = expectThrows(SolrException.class, () -> client.add(sd));\n      assertEquals(409, e.code());\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    final SolrInputDocument sd2 =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd2);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrClient client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrClient client : clients) {\n      val += 10;\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","sourceOld":"  // cloud level test mainly needed just to make sure that versions and errors are propagated correctly\n  private void doOptimisticLockingAndUpdating() throws Exception {\n    log.info(\"### STARTING doOptimisticLockingAndUpdating\");\n    printLayout();\n    \n    final SolrInputDocument sd =  sdoc(\"id\", 1000, \"_version_\", -1);\n    indexDoc(sd);\n\n    ignoreException(\"version conflict\");\n    for (SolrClient client : clients) {\n      SolrException e = expectThrows(SolrException.class, () -> client.add(sd));\n      assertEquals(409, e.code());\n    }\n    unIgnoreException(\"version conflict\");\n\n    // TODO: test deletes.  SolrJ needs a good way to pass version for delete...\n\n    final SolrInputDocument sd2 =  sdoc(\"id\", 1000, \"foo_i\",5);\n    clients.get(0).add(sd2);\n\n    List<Integer> expected = new ArrayList<>();\n    int val = 0;\n    for (SolrClient client : clients) {\n      val += 10;\n      client.add(sdoc(\"id\", 1000, \"val_i\", map(\"add\",val), \"foo_i\",val));\n      expected.add(val);\n    }\n\n    QueryRequest qr = new QueryRequest(params(\"qt\", \"/get\", \"id\",\"1000\"));\n    for (SolrClient client : clients) {\n      val += 10;\n      NamedList rsp = client.request(qr);\n      String match = JSONTestUtil.matchObj(\"/val_i\", rsp.get(\"doc\"), expected);\n      if (match != null) throw new RuntimeException(match);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c5a558d54519c651068ddb202f03befefb1514a7"],"c5a558d54519c651068ddb202f03befefb1514a7":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["e19067e820b148e8dc0b240da4f2771cf7b68252","c5a558d54519c651068ddb202f03befefb1514a7"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["bafca15d8e408346a67f4282ad1143b88023893b"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["1bea3922196318026c4274f2013416acb60c691e"],"bafca15d8e408346a67f4282ad1143b88023893b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"1bea3922196318026c4274f2013416acb60c691e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["92f789dbd1886e4b468e61b0def88b29a3f55228"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bafca15d8e408346a67f4282ad1143b88023893b"],"c5a558d54519c651068ddb202f03befefb1514a7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1bea3922196318026c4274f2013416acb60c691e"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"92f789dbd1886e4b468e61b0def88b29a3f55228":["e98520789adb1d5ad05afb4956eca0944a929688"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["c5a558d54519c651068ddb202f03befefb1514a7","407687e67faf6e1f02a211ca078d8e3eed631027"],"bafca15d8e408346a67f4282ad1143b88023893b":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"1bea3922196318026c4274f2013416acb60c691e":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}