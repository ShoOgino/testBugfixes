{"path":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","commits":[{"id":"57e91c86e193010fc38028001cf0590693ad2cd1","date":1166153548,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","pathOld":"/dev/null","sourceNew":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n    \n    short type = nd.getNodeType();\n\n    switch (type) {\n      \n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ATTRIBUTE_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE: \n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n      \n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7c43a99d6476bc0bc1a587f63cac6f5fbd238129"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c43a99d6476bc0bc1a587f63cac6f5fbd238129","date":1166922600,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","pathOld":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","sourceNew":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n    \n    short type = nd.getNodeType();\n\n    switch (type) {\n      \n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE: \n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n      \n    case Node.ATTRIBUTE_NODE: /* fall through */\n      /* Putting Attribute nodes in this section does not exactly \n         match the definition of how textContent should behave \n         according to the DOM Level-3 Core documentation - which \n         specifies that the Attr's children should have their \n         textContent concated (Attr's can have a single child which \n         is either Text node or an EntityRefrence).  In practice,\n         DOM implementations do not seem to use child nodes of \n         Attributes, storing the \"text\" directly as the nodeValue.\n         Fortunately, the DOM Spec indicates that when Attr.nodeValue \n         is read, it should return the nodeValue from the child Node, \n         so this approach should work both for strict implementations, \n         and implementations actually encountered.\n      */\n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","sourceOld":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n    \n    short type = nd.getNodeType();\n\n    switch (type) {\n      \n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ATTRIBUTE_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE: \n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n      \n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","bugFix":["57e91c86e193010fc38028001cf0590693ad2cd1"],"bugIntro":["7602e63987582091a0e432f8d8f7619d2206fab7","7602e63987582091a0e432f8d8f7619d2206fab7","7602e63987582091a0e432f8d8f7619d2206fab7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"810d380561c984370e8bfcbf778486c08f7e2cc0","date":1171644169,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","pathOld":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","sourceNew":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n\n    short type = nd.getNodeType();\n\n    switch (type) {\n\n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n\n    case Node.ATTRIBUTE_NODE: /* fall through */\n      /* Putting Attribute nodes in this section does not exactly \n         match the definition of how textContent should behave \n         according to the DOM Level-3 Core documentation - which \n         specifies that the Attr's children should have their \n         textContent concated (Attr's can have a single child which \n         is either Text node or an EntityRefrence).  In practice,\n         DOM implementations do not seem to use child nodes of \n         Attributes, storing the \"text\" directly as the nodeValue.\n         Fortunately, the DOM Spec indicates that when Attr.nodeValue \n         is read, it should return the nodeValue from the child Node, \n         so this approach should work both for strict implementations, \n         and implementations actually encountered.\n      */\n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","sourceOld":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n    \n    short type = nd.getNodeType();\n\n    switch (type) {\n      \n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE: \n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n      \n    case Node.ATTRIBUTE_NODE: /* fall through */\n      /* Putting Attribute nodes in this section does not exactly \n         match the definition of how textContent should behave \n         according to the DOM Level-3 Core documentation - which \n         specifies that the Attr's children should have their \n         textContent concated (Attr's can have a single child which \n         is either Text node or an EntityRefrence).  In practice,\n         DOM implementations do not seem to use child nodes of \n         Attributes, storing the \"text\" directly as the nodeValue.\n         Fortunately, the DOM Spec indicates that when Attr.nodeValue \n         is read, it should return the nodeValue from the child Node, \n         so this approach should work both for strict implementations, \n         and implementations actually encountered.\n      */\n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3abdd666f12a1d3197de9c612ea8e83cfbb6e7bb","date":1181791578,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/common/util/DOMUtil#getText(Node,StringBuilder).mjava","pathOld":"src/java/org/apache/solr/util/DOMUtil#getText(Node,StringBuilder).mjava","sourceNew":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n\n    short type = nd.getNodeType();\n\n    switch (type) {\n\n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n\n    case Node.ATTRIBUTE_NODE: /* fall through */\n      /* Putting Attribute nodes in this section does not exactly \n         match the definition of how textContent should behave \n         according to the DOM Level-3 Core documentation - which \n         specifies that the Attr's children should have their \n         textContent concated (Attr's can have a single child which \n         is either Text node or an EntityRefrence).  In practice,\n         DOM implementations do not seem to use child nodes of \n         Attributes, storing the \"text\" directly as the nodeValue.\n         Fortunately, the DOM Spec indicates that when Attr.nodeValue \n         is read, it should return the nodeValue from the child Node, \n         so this approach should work both for strict implementations, \n         and implementations actually encountered.\n      */\n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","sourceOld":"  /** @see #getText(Node) */\n  private static void getText(Node nd, StringBuilder buf) {\n\n    short type = nd.getNodeType();\n\n    switch (type) {\n\n    case Node.ELEMENT_NODE: /* fall through */\n    case Node.ENTITY_NODE: /* fall through */\n    case Node.ENTITY_REFERENCE_NODE: /* fall through */\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      NodeList childs = nd.getChildNodes();\n      for (int i = 0; i < childs.getLength(); i++) {\n        Node child = childs.item(i);\n        short childType = child.getNodeType();\n        if (childType != Node.COMMENT_NODE &&\n            childType != Node.PROCESSING_INSTRUCTION_NODE) {\n          getText(child, buf);\n        }\n      }\n      break;\n\n    case Node.ATTRIBUTE_NODE: /* fall through */\n      /* Putting Attribute nodes in this section does not exactly \n         match the definition of how textContent should behave \n         according to the DOM Level-3 Core documentation - which \n         specifies that the Attr's children should have their \n         textContent concated (Attr's can have a single child which \n         is either Text node or an EntityRefrence).  In practice,\n         DOM implementations do not seem to use child nodes of \n         Attributes, storing the \"text\" directly as the nodeValue.\n         Fortunately, the DOM Spec indicates that when Attr.nodeValue \n         is read, it should return the nodeValue from the child Node, \n         so this approach should work both for strict implementations, \n         and implementations actually encountered.\n      */\n    case Node.TEXT_NODE: /* fall through */\n    case Node.CDATA_SECTION_NODE: /* fall through */\n    case Node.COMMENT_NODE: /* fall through */\n    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */\n      buf.append(nd.getNodeValue());\n      break;\n\n    case Node.DOCUMENT_NODE: /* fall through */\n    case Node.DOCUMENT_TYPE_NODE: /* fall through */\n    case Node.NOTATION_NODE: /* fall through */\n    default:\n      /* :NOOP: */\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3abdd666f12a1d3197de9c612ea8e83cfbb6e7bb":["810d380561c984370e8bfcbf778486c08f7e2cc0"],"57e91c86e193010fc38028001cf0590693ad2cd1":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"810d380561c984370e8bfcbf778486c08f7e2cc0":["7c43a99d6476bc0bc1a587f63cac6f5fbd238129"],"7c43a99d6476bc0bc1a587f63cac6f5fbd238129":["57e91c86e193010fc38028001cf0590693ad2cd1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3abdd666f12a1d3197de9c612ea8e83cfbb6e7bb":[],"57e91c86e193010fc38028001cf0590693ad2cd1":["7c43a99d6476bc0bc1a587f63cac6f5fbd238129"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["57e91c86e193010fc38028001cf0590693ad2cd1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"810d380561c984370e8bfcbf778486c08f7e2cc0":["3abdd666f12a1d3197de9c612ea8e83cfbb6e7bb"],"7c43a99d6476bc0bc1a587f63cac6f5fbd238129":["810d380561c984370e8bfcbf778486c08f7e2cc0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3abdd666f12a1d3197de9c612ea8e83cfbb6e7bb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}