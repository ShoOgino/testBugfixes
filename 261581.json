{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","commits":[{"id":"ffab13814193b42cd50780daa02d4bd9e94ed0d1","date":1509080304,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","pathOld":"/dev/null","sourceNew":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish\n      (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["25839fe4831afa605843216ad003e225bb0af2b1","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25839fe4831afa605843216ad003e225bb0af2b1","date":1510568445,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","sourceNew":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish\n      (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = new CloudSolrClientBuilder()\n        .withZkHost(cluster.getZkServer().getZkAddress())\n        .sendDirectUpdatesToAnyShardReplica()\n        .withParallelUpdates(true)\n        .build()) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","sourceOld":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish\n      (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","bugFix":["ffab13814193b42cd50780daa02d4bd9e94ed0d1"],"bugIntro":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8","date":1520696743,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","sourceNew":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish\n      (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .sendDirectUpdatesToAnyShardReplica()\n        .withParallelUpdates(true)\n        .build()) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","sourceOld":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish\n      (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = new CloudSolrClientBuilder()\n        .withZkHost(cluster.getZkServer().getZkAddress())\n        .sendDirectUpdatesToAnyShardReplica()\n        .withParallelUpdates(true)\n        .build()) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","bugFix":["25839fe4831afa605843216ad003e225bb0af2b1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRetryUpdatesWhenClusterStateIsStale().mjava","sourceNew":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    cluster.waitForActiveCollection(COL, 1, 1);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .sendDirectUpdatesToAnyShardReplica()\n        .withParallelUpdates(true)\n        .build()) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","sourceOld":"  public void testRetryUpdatesWhenClusterStateIsStale() throws Exception {\n    final String COL = \"stale_state_test_col\";\n    assert cluster.getJettySolrRunners().size() >= 2;\n\n    final JettySolrRunner old_leader_node = cluster.getJettySolrRunners().get(0);\n    final JettySolrRunner new_leader_node = cluster.getJettySolrRunners().get(1);\n    \n    // start with exactly 1 shard/replica...\n    assertEquals(\"Couldn't create collection\", 0,\n                 CollectionAdminRequest.createCollection(COL, \"conf\", 1, 1)\n                 .setCreateNodeSet(old_leader_node.getNodeName())\n                 .process(cluster.getSolrClient()).getStatus());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish\n      (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n    // determine the coreNodeName of only current replica\n    Collection<Slice> slices = cluster.getSolrClient().getZkStateReader().getClusterState().getCollection(COL).getSlices();\n    assertEquals(1, slices.size()); // sanity check\n    Slice slice = slices.iterator().next();\n    assertEquals(1, slice.getReplicas().size()); // sanity check\n    final String old_leader_core_node_name = slice.getLeader().getName();\n\n    // NOTE: creating our own CloudSolrClient whose settings we can muck with...\n    try (CloudSolrClient stale_client = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .sendDirectUpdatesToAnyShardReplica()\n        .withParallelUpdates(true)\n        .build()) {\n      // don't let collection cache entries get expired, even on a slow machine...\n      stale_client.setCollectionCacheTTl(Integer.MAX_VALUE);\n      stale_client.setDefaultCollection(COL);\n     \n      // do a query to populate stale_client's cache...\n      assertEquals(0, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n      // add 1 replica on a diff node...\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.addReplicaToShard(COL, \"shard1\")\n                   .setNode(new_leader_node.getNodeName())\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n      \n      // ...and delete our original leader.\n      assertEquals(\"Couldn't create collection\", 0,\n                   CollectionAdminRequest.deleteReplica(COL, \"shard1\", old_leader_core_node_name)\n                   // NOTE: don't use our stale_client for this -- don't tip it off of a collection change\n                   .process(cluster.getSolrClient()).getStatus());\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish\n        (COL, cluster.getSolrClient().getZkStateReader(), true, true, 330);\n\n      // stale_client's collection state cache should now only point at a leader that no longer exists.\n      \n      // attempt a (direct) update that should succeed in spite of cached cluster state\n      // pointing solely to a node that's no longer part of our collection...\n      assertEquals(0, (new UpdateRequest().add(\"id\", \"1\").commit(stale_client, COL)).getStatus());\n      assertEquals(1, stale_client.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      \n    }\n  }\n\n","bugFix":["ffab13814193b42cd50780daa02d4bd9e94ed0d1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ffab13814193b42cd50780daa02d4bd9e94ed0d1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"25839fe4831afa605843216ad003e225bb0af2b1":["ffab13814193b42cd50780daa02d4bd9e94ed0d1"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8":["25839fe4831afa605843216ad003e225bb0af2b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"ffab13814193b42cd50780daa02d4bd9e94ed0d1":["25839fe4831afa605843216ad003e225bb0af2b1"],"25839fe4831afa605843216ad003e225bb0af2b1":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ffab13814193b42cd50780daa02d4bd9e94ed0d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}