{"path":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#nextSetBit(int).mjava","commits":[{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#nextSetBit(int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public int nextSetBit(int i) {\n    assert i < length;\n    final int i4096 = i >>> 12;\n    final long index = indices[i4096];\n    int i64 = i >>> 6;\n    long indexBits = index >>> i64;\n    if (indexBits == 0) {\n      // if the index is zero, it means that there is no value in the\n      // current block, so return the first document of the next block\n      // or\n      // if neither the i64-th bit or any other bit on its left is set then\n      // it means that there are no more documents in this block, go to the\n      // next one\n      return firstDoc(i4096 + 1);\n    } else {\n      // We know we still have some 64-bits blocks that have bits set, let's\n      // advance to the next one by skipping trailing zeros of the index\n      int i1 = i & 0x3F;\n      int trailingZeros = Long.numberOfTrailingZeros(indexBits);\n      if (trailingZeros != 0) {\n        // no bits in the current long, go to the next one\n        i64 += trailingZeros;\n        i1 = 0;\n      }\n\n      // So now we are on a sub 64-bits block that has values\n      assert (index & (1L << i64)) != 0;\n      // we count the number of ones on the left of i64 to figure out the\n      // index of the long that contains the bits we are interested in\n      int longIndex = Long.bitCount(index & ((1L << i64) - 1)); // shifts are mod 64 in java\n      final long[] longArray = bits[i4096];\n      assert longArray[longIndex] != 0;\n      long bits = longArray[longIndex] >>> i1; // shifts are mod 64 in java\n      if (bits != 0L) {\n        // hurray, we found some non-zero bits, this gives us the next document:\n        i1 += Long.numberOfTrailingZeros(bits);\n        return (i4096 << 12) | ((i64 & 0x3F) << 6) | i1;\n      }\n\n      // otherwise it means that although we were on a sub-64 block that contains\n      // documents, all documents of this sub-block have already been consumed\n      // so two cases:\n      indexBits = index >>> i64 >>> 1; // we don't shift by (i64+1) otherwise we might shift by a multiple of 64 which is a no-op\n      if (indexBits == 0) {\n        // Case 1: this was the last long of the block of 4096 bits, then go\n        // to the next block\n        return firstDoc(i4096 + 1);\n      }\n      // Case 2: go to the next sub 64-bits block in the current block of 4096 bits\n      // by skipping trailing zeros of the index\n      trailingZeros = Long.numberOfTrailingZeros(indexBits);\n      i64 += 1 + trailingZeros;\n      bits = longArray[longIndex + 1];\n      assert bits != 0;\n      i1 = Long.numberOfTrailingZeros(bits);\n      return (i4096 << 12) | ((i64 & 0x3F) << 6) | i1;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b012914a8110b2ff1d075ed1ef72aa57084d4897","date":1414685177,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#nextSetBit(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet#nextSetBit(int).mjava","sourceNew":"  @Override\n  public int nextSetBit(int i) {\n    assert i < length;\n    final int i4096 = i >>> 12;\n    final long index = indices[i4096];\n    final long[] bitArray = this.bits[i4096];\n    int i64 = i >>> 6;\n    int o = Long.bitCount(index & ((1L << i64) - 1));\n    if ((index & (1L << i64)) != 0) {\n      // There is at least one bit that is set in the current long, check if\n      // one of them is after i\n      final long bits = bitArray[o] >>> i; // shifts are mod 64\n      if (bits != 0) {\n        return i + Long.numberOfTrailingZeros(bits);\n      }\n      o += 1;\n    }\n    final long indexBits = index >>> i64 >>> 1;\n    if (indexBits == 0) {\n      // no more bits are set in the current block of 4096 bits, go to the next one\n      return firstDoc(i4096 + 1);\n    }\n    // there are still set bits\n    i64 += 1 + Long.numberOfTrailingZeros(indexBits);\n    final long bits = bitArray[o];\n    return (i64 << 6) | Long.numberOfTrailingZeros(bits);\n  }\n\n","sourceOld":"  @Override\n  public int nextSetBit(int i) {\n    assert i < length;\n    final int i4096 = i >>> 12;\n    final long index = indices[i4096];\n    int i64 = i >>> 6;\n    long indexBits = index >>> i64;\n    if (indexBits == 0) {\n      // if the index is zero, it means that there is no value in the\n      // current block, so return the first document of the next block\n      // or\n      // if neither the i64-th bit or any other bit on its left is set then\n      // it means that there are no more documents in this block, go to the\n      // next one\n      return firstDoc(i4096 + 1);\n    } else {\n      // We know we still have some 64-bits blocks that have bits set, let's\n      // advance to the next one by skipping trailing zeros of the index\n      int i1 = i & 0x3F;\n      int trailingZeros = Long.numberOfTrailingZeros(indexBits);\n      if (trailingZeros != 0) {\n        // no bits in the current long, go to the next one\n        i64 += trailingZeros;\n        i1 = 0;\n      }\n\n      // So now we are on a sub 64-bits block that has values\n      assert (index & (1L << i64)) != 0;\n      // we count the number of ones on the left of i64 to figure out the\n      // index of the long that contains the bits we are interested in\n      int longIndex = Long.bitCount(index & ((1L << i64) - 1)); // shifts are mod 64 in java\n      final long[] longArray = bits[i4096];\n      assert longArray[longIndex] != 0;\n      long bits = longArray[longIndex] >>> i1; // shifts are mod 64 in java\n      if (bits != 0L) {\n        // hurray, we found some non-zero bits, this gives us the next document:\n        i1 += Long.numberOfTrailingZeros(bits);\n        return (i4096 << 12) | ((i64 & 0x3F) << 6) | i1;\n      }\n\n      // otherwise it means that although we were on a sub-64 block that contains\n      // documents, all documents of this sub-block have already been consumed\n      // so two cases:\n      indexBits = index >>> i64 >>> 1; // we don't shift by (i64+1) otherwise we might shift by a multiple of 64 which is a no-op\n      if (indexBits == 0) {\n        // Case 1: this was the last long of the block of 4096 bits, then go\n        // to the next block\n        return firstDoc(i4096 + 1);\n      }\n      // Case 2: go to the next sub 64-bits block in the current block of 4096 bits\n      // by skipping trailing zeros of the index\n      trailingZeros = Long.numberOfTrailingZeros(indexBits);\n      i64 += 1 + trailingZeros;\n      bits = longArray[longIndex + 1];\n      assert bits != 0;\n      i1 = Long.numberOfTrailingZeros(bits);\n      return (i4096 << 12) | ((i64 & 0x3F) << 6) | i1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b012914a8110b2ff1d075ed1ef72aa57084d4897":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b012914a8110b2ff1d075ed1ef72aa57084d4897"]},"commit2Childs":{"b012914a8110b2ff1d075ed1ef72aa57084d4897":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}