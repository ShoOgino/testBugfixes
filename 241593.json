{"path":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","commits":[{"id":"f49f14d65e01870e494b6f38fa88ea1a8011e4fe","date":1450213592,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",\"101\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",\"102\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",\"103\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",\"104\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",\"105\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[105,104]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",\"200\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",\"201\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",\"203\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",\"204\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",\"205\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",\"206\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':104}\"\n              + \",{'id':'c5','_version_':105}\"\n              + \",{'id':'c100','_version_':200}\"\n              + \",{'id':'c101','_version_':201}\"\n              + \",{'id':'c105','_version_':205}\"\n              + \",{'id':'c106','_version_':206}\"\n              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[206,205,204,203,201,200,105,104,103,102,101]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",\"101\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",\"102\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",\"103\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",\"104\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",\"105\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[105,104]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",\"200\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",\"201\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",\"203\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",\"204\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",\"205\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",\"206\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':104}\"\n              + \",{'id':'c5','_version_':105}\"\n              + \",{'id':'c100','_version_':200}\"\n              + \",{'id':'c101','_version_':201}\"\n              + \",{'id':'c105','_version_':205}\"\n              + \",{'id':'c106','_version_':206}\"\n              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[206,205,204,203,201,200,105,104,103,102,101]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",\"101\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",\"102\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",\"103\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",\"104\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",\"105\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[105,104]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",\"200\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",\"201\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",\"203\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",\"204\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",\"205\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",\"206\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':104}\"\n              + \",{'id':'c5','_version_':105}\"\n              + \",{'id':'c100','_version_':200}\"\n              + \",{'id':'c101','_version_':201}\"\n              + \",{'id':'c105','_version_':205}\"\n              + \",{'id':'c106','_version_':206}\"\n              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[206,205,204,203,201,200,105,104,103,102,101]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9efcb86f82b536ffcefcc27adbfa39b603342af1","date":1492147023,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v204,v203,v201,v200,v105,v104,v103,v102,v101)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",\"101\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",\"102\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",\"103\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",\"104\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",\"105\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[105,104]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",\"200\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",\"201\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",\"203\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",\"204\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",\"205\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",\"206\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':104}\"\n              + \",{'id':'c5','_version_':105}\"\n              + \",{'id':'c100','_version_':200}\"\n              + \",{'id':'c101','_version_':201}\"\n              + \",{'id':'c105','_version_':205}\"\n              + \",{'id':'c106','_version_':206}\"\n              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[206,205,204,203,201,200,105,104,103,102,101]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v204,v203,v201,v200,v105,v104,v103,v102,v101)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",\"101\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",\"102\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",\"103\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",\"104\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",\"105\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[105,104]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",\"200\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",\"201\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",\"203\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",\"204\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",\"205\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",\"206\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':104}\"\n              + \",{'id':'c5','_version_':105}\"\n              + \",{'id':'c100','_version_':200}\"\n              + \",{'id':'c101','_version_':201}\"\n              + \",{'id':'c105','_version_':205}\"\n              + \",{'id':'c106','_version_':206}\"\n              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[206,205,204,203,201,200,105,104,103,102,101]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v201,v200,v105,v104)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v204,v203,v201,v200,v105,v104,v103,v102,v101)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v201,v200,v105,v104)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v204,v203,v201,v200,v105,v104,v103,v102,v101)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v201,v200,v105,v104)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      // this time add some docs first before buffering starts (so tlog won't be at pos 0)\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      // The updates that were buffered (but never applied) still appear in recent versions!\n      // This is good for some uses, but may not be good for others.\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"11\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v204,v203,v201,v200,v105,v104,v103,v102,v101)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBufferedMultipleCalls().mjava","sourceNew":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v201,v200,v105,v104)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBufferedMultipleCalls() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    Future<UpdateLog.RecoveryInfo> rinfoFuture;\n\n    try {\n      String v101 = getNextVersion();\n      String v102 = getNextVersion();\n      String v103 = getNextVersion();\n      String v104 = getNextVersion();\n      String v105 = getNextVersion();\n      String v200 = getNextVersion();\n      String v201 = getNextVersion();\n      String v203 = getNextVersion();\n      String v204 = getNextVersion();\n      String v205 = getNextVersion();\n      String v206 = getNextVersion();\n      \n      clearIndex();\n      assertU(commit());\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"c1\", \"_version_\",v101)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c2\", \"_version_\",v102)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c3\", \"_version_\",v103)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      updateJ(jsonAdd(sdoc(\"id\", \"c4\", \"_version_\",v104)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\", \"c5\", \"_version_\",v105)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      logReplay.release(1000);\n      rinfoFuture = ulog.applyBufferedUpdates();\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"2\")\n          ,\"=={'versions':[\"+v105+\",\"+v104+\"]}\"\n      );\n\n      updateJ(jsonAdd(sdoc(\"id\",\"c100\", \"_version_\",v200)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c101\", \"_version_\",v201)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c103\", \"_version_\",v203)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c104\", \"_version_\",v204)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // call bufferUpdates again (this currently happens when recovery fails)... we should get a new starting point\n      ulog.bufferUpdates();\n      updateJ(jsonAdd(sdoc(\"id\",\"c105\", \"_version_\",v205)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"c106\", \"_version_\",v206)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      rinfo = rinfoFuture.get();\n      assertEquals(2, rinfo.adds);\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"_version_ asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n              + \"{'id':'c4','_version_':\"+v104+\"}\"\n              + \",{'id':'c5','_version_':\"+v105+\"}\"\n              + \",{'id':'c100','_version_':\"+v200+\"}\"\n              + \",{'id':'c101','_version_':\"+v201+\"}\"\n              + \",{'id':'c105','_version_':\"+v205+\"}\"\n              + \",{'id':'c106','_version_':\"+v206+\"}\"\n+\"\"              +\"]\"\n      );\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+String.join(\",\",v206,v205,v201,v200,v105,v104)+\"]}\"\n      );\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9efcb86f82b536ffcefcc27adbfa39b603342af1":["3a0c04b71951333291abc7f317109a6a5957bd28"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["3a0c04b71951333291abc7f317109a6a5957bd28"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["9efcb86f82b536ffcefcc27adbfa39b603342af1","1455c941cc4ce652efc776fc23471b0e499246f6"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["1455c941cc4ce652efc776fc23471b0e499246f6"],"f49f14d65e01870e494b6f38fa88ea1a8011e4fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f592209545c71895260367152601e9200399776d":["9efcb86f82b536ffcefcc27adbfa39b603342af1","1455c941cc4ce652efc776fc23471b0e499246f6"],"3a0c04b71951333291abc7f317109a6a5957bd28":["f49f14d65e01870e494b6f38fa88ea1a8011e4fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"1455c941cc4ce652efc776fc23471b0e499246f6":["9efcb86f82b536ffcefcc27adbfa39b603342af1"]},"commit2Childs":{"9efcb86f82b536ffcefcc27adbfa39b603342af1":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","1455c941cc4ce652efc776fc23471b0e499246f6"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f49f14d65e01870e494b6f38fa88ea1a8011e4fe"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f49f14d65e01870e494b6f38fa88ea1a8011e4fe":["3a0c04b71951333291abc7f317109a6a5957bd28"],"f592209545c71895260367152601e9200399776d":[],"3a0c04b71951333291abc7f317109a6a5957bd28":["9efcb86f82b536ffcefcc27adbfa39b603342af1","54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"1455c941cc4ce652efc776fc23471b0e499246f6":["b70042a8a492f7054d480ccdd2be9796510d4327","b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","f592209545c71895260367152601e9200399776d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}