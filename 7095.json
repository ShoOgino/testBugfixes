{"path":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","commits":[{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe214d6e09deed3001159c1ad5173f9c8fc4a7f5","date":1563597632,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if(sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if(sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ea07d22cef2406e950de111f8aa7bc2edb91d56","date":1581094599,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          replicaPropMap.put(ZkStateReader.CORE_NAME_PROP, \"core_\" + replicaName);\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if(sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if(sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f6c2c088b7e829984b5bca4359702c0d5ccc62b","date":1581143367,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          replicaPropMap.put(ZkStateReader.CORE_NAME_PROP, \"core_\" + replicaName);\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if(sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc28b46d62a8b91c8e90f9345612c4050eab98d4","date":1581344825,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n\n          // O(n^2) alert! but this is for mocks and testing so shouldn't be used for very large cluster states\n          boolean leaderFound = false;\n          for (Map.Entry<String, Replica> entry : replicas.entrySet()) {\n            Replica value = entry.getValue();\n            if (\"true\".equals(value.get(Slice.LEADER)))  {\n              leaderFound = true;\n              break;\n            }\n          }\n          if (!leaderFound && !m.group(1).equals(\"p\")) {\n            replicaPropMap.put(Slice.LEADER, \"true\");\n          }\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n          replicas.put(replica.getName(), replica);\n\n          // hack alert: re-create slice with existing data and new replicas map so that it updates its internal leader attribute\n          slice = new Slice(slice.getName(), replicas, null, collName);\n          slices.put(slice.getName(), slice);\n          // we don't need to update doc collection again because we aren't adding a new slice or changing its state\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n\n          // O(n^2) alert! but this is for mocks and testing so shouldn't be used for very large cluster states\n          boolean leaderFound = false;\n          for (Map.Entry<String, Replica> entry : replicas.entrySet()) {\n            Replica value = entry.getValue();\n            if (\"true\".equals(value.get(Slice.LEADER)))  {\n              leaderFound = true;\n              break;\n            }\n          }\n          if (!leaderFound && !m.group(1).equals(\"p\")) {\n            replicaPropMap.put(Slice.LEADER, \"true\");\n          }\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n          replicas.put(replica.getName(), replica);\n\n          // hack alert: re-create slice with existing data and new replicas map so that it updates its internal leader attribute\n          slice = new Slice(slice.getName(), replicas, null, collName);\n          slices.put(slice.getName(), slice);\n          // we don't need to update doc collection again because we aren't adding a new slice or changing its state\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n\n          // O(n^2) alert! but this is for mocks and testing so shouldn't be used for very large cluster states\n          boolean leaderFound = false;\n          for (Map.Entry<String, Replica> entry : replicas.entrySet()) {\n            Replica value = entry.getValue();\n            if (\"true\".equals(value.get(Slice.LEADER)))  {\n              leaderFound = true;\n              break;\n            }\n          }\n          if (!leaderFound && !m.group(1).equals(\"p\")) {\n            replicaPropMap.put(Slice.LEADER, \"true\");\n          }\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n          replicas.put(replica.getName(), replica);\n\n          // hack alert: re-create slice with existing data and new replicas map so that it updates its internal leader attribute\n          slice = new Slice(slice.getName(), replicas, null, collName);\n          slices.put(slice.getName(), slice);\n          // we don't need to update doc collection again because we aren't adding a new slice or changing its state\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","sourceNew":null,"sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n\n          // O(n^2) alert! but this is for mocks and testing so shouldn't be used for very large cluster states\n          boolean leaderFound = false;\n          for (Map.Entry<String, Replica> entry : replicas.entrySet()) {\n            Replica value = entry.getValue();\n            if (\"true\".equals(value.get(Slice.LEADER)))  {\n              leaderFound = true;\n              break;\n            }\n          }\n          if (!leaderFound && !m.group(1).equals(\"p\")) {\n            replicaPropMap.put(Slice.LEADER, \"true\");\n          }\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n          replicas.put(replica.getName(), replica);\n\n          // hack alert: re-create slice with existing data and new replicas map so that it updates its internal leader attribute\n          slice = new Slice(slice.getName(), replicas, null, collName);\n          slices.put(slice.getName(), slice);\n          // we don't need to update doc collection again because we aren't adding a new slice or changing its state\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["fe214d6e09deed3001159c1ad5173f9c8fc4a7f5","6681d02f2302c363be938426e68f8dfd090cc1bf"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cc28b46d62a8b91c8e90f9345612c4050eab98d4"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"7f6c2c088b7e829984b5bca4359702c0d5ccc62b":["3ea07d22cef2406e950de111f8aa7bc2edb91d56"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["fe214d6e09deed3001159c1ad5173f9c8fc4a7f5"],"fe214d6e09deed3001159c1ad5173f9c8fc4a7f5":["560c18d71dad43d675158783c3840f8c80d6d39c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc28b46d62a8b91c8e90f9345612c4050eab98d4":["7f6c2c088b7e829984b5bca4359702c0d5ccc62b"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"3ea07d22cef2406e950de111f8aa7bc2edb91d56":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f6c2c088b7e829984b5bca4359702c0d5ccc62b":["cc28b46d62a8b91c8e90f9345612c4050eab98d4"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","3ea07d22cef2406e950de111f8aa7bc2edb91d56"],"fe214d6e09deed3001159c1ad5173f9c8fc4a7f5":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","717e5ceb2acae36d422ec75e5a4ce9fac40506e1","560c18d71dad43d675158783c3840f8c80d6d39c"],"cc28b46d62a8b91c8e90f9345612c4050eab98d4":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"560c18d71dad43d675158783c3840f8c80d6d39c":["fe214d6e09deed3001159c1ad5173f9c8fc4a7f5"],"3ea07d22cef2406e950de111f8aa7bc2edb91d56":["7f6c2c088b7e829984b5bca4359702c0d5ccc62b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}