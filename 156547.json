{"path":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleDisallowSysouts#afterIfSuccessful().mjava","commits":[{"id":"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518","date":1398331323,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleDisallowSysouts#afterIfSuccessful().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * We're only interested in failing the suite if it was successful. Otherwise\n   * just propagate the original problem and don't bother.\n   */\n  @Override\n  protected void afterIfSuccessful() throws Throwable {\n    if (isEnforced()) {\n      checkCaptureStreams();\n  \n      // Flush any buffers.\n      capturedSystemOut.printStream.flush();\n      capturedSystemErr.printStream.flush();\n  \n      // And check for offenders, but only if everything was successful so far.\n      StackTraceElement[] offenderStack = firstWriteStack.get();\n      if (offenderStack != null && failureMarker.wasSuccessful()) {\n        AssertionError e = new AssertionError(\"The test or suite printed information to stdout or stderr,\" +\n            \" even though verbose mode is turned off and it's not annotated with @\" + \n            SuppressSysoutChecks.class.getSimpleName() + \". This exception contains the stack\" +\n                \" trace of the first offending call.\");\n        e.setStackTrace(offenderStack);\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15f78d4c3703bdf31ef64dc18dd5d5c7996bcd0a","date":1398846443,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleLimitSysouts#afterIfSuccessful().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestRuleDisallowSysouts#afterIfSuccessful().mjava","sourceNew":"  /**\n   * We're only interested in failing the suite if it was successful. Otherwise\n   * just propagate the original problem and don't bother.\n   */\n  @Override\n  protected void afterIfSuccessful() throws Throwable {\n    if (isEnforced()) {\n      checkCaptureStreams();\n  \n      // Flush any buffers.\n      capturedSystemOut.printStream.flush();\n      capturedSystemErr.printStream.flush();\n  \n      // Check for offenders, but only if everything was successful so far.\n      int limit = RandomizedTest.getContext().getTargetClass().getAnnotation(Limit.class).bytes();\n      if (bytesWritten.get() >= limit && failureMarker.wasSuccessful()) {\n        throw new AssertionError(String.format(Locale.ENGLISH, \n            \"The test or suite printed %d bytes to stdout and stderr,\" +\n            \" even though the limit was set to %d bytes. Increase the limit with @%s, ignore it completely\" +\n            \" with @%s or run with -Dtests.verbose=true\",\n            bytesWritten.get(),\n            limit,\n            Limit.class.getSimpleName(),\n            SuppressSysoutChecks.class.getSimpleName()));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * We're only interested in failing the suite if it was successful. Otherwise\n   * just propagate the original problem and don't bother.\n   */\n  @Override\n  protected void afterIfSuccessful() throws Throwable {\n    if (isEnforced()) {\n      checkCaptureStreams();\n  \n      // Flush any buffers.\n      capturedSystemOut.printStream.flush();\n      capturedSystemErr.printStream.flush();\n  \n      // And check for offenders, but only if everything was successful so far.\n      StackTraceElement[] offenderStack = firstWriteStack.get();\n      if (offenderStack != null && failureMarker.wasSuccessful()) {\n        AssertionError e = new AssertionError(\"The test or suite printed information to stdout or stderr,\" +\n            \" even though verbose mode is turned off and it's not annotated with @\" + \n            SuppressSysoutChecks.class.getSimpleName() + \". This exception contains the stack\" +\n                \" trace of the first offending call.\");\n        e.setStackTrace(offenderStack);\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a02a9b55e3d768e01d82ac97c60d96014f046f6d"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"15f78d4c3703bdf31ef64dc18dd5d5c7996bcd0a":["e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518":["15f78d4c3703bdf31ef64dc18dd5d5c7996bcd0a"],"15f78d4c3703bdf31ef64dc18dd5d5c7996bcd0a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["15f78d4c3703bdf31ef64dc18dd5d5c7996bcd0a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}