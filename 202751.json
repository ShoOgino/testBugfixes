{"path":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"/dev/null","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["248f6ecc900c3a5633fd5ca6f564ea8b717720da","efff98a8632f3c2f5b05f961e22a67f122db81e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"/dev/null","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"051c3069a96e986b8fa0435398a73a922ce85418","date":1447853599,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3d5f49e404387af0c20abb76ef75489cc1a748","date":1504565932,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efff98a8632f3c2f5b05f961e22a67f122db81e0","date":1550955355,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      } else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4","date":1551083645,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      } else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(int).mjava","sourceNew":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new ValueSourceParser.LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      } else {\n        if (\"true\".equals(id)) {\n          valueSource = ValueSourceParser.BoolConstValueSource.TRUE;\n        } else if (\"false\".equals(id)) {\n          valueSource = ValueSourceParser.BoolConstValueSource.FALSE;\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","sourceOld":"   protected ValueSource parseValueSource(int flags) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        StrParser sp = new StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        StrParser sp = new StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      } else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          if ((flags & FLAG_USE_FIELDNAME_SOURCE) != 0) {\n            // Don't try to create a ValueSource for the field, just use a placeholder.\n            valueSource = new FieldNameValueSource(id);\n          } else {\n            SchemaField f = req.getSchema().getField(id);\n            valueSource = f.getType().getValueSource(f, this);\n          }\n        }\n      }\n\n    }\n    \n    if ((flags & FLAG_CONSUME_DELIMITER) != 0) {\n      consumeArgumentDelimiter();\n    }\n    \n    return valueSource;\n  }\n\n","bugFix":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["051c3069a96e986b8fa0435398a73a922ce85418","cc3d5f49e404387af0c20abb76ef75489cc1a748"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["051c3069a96e986b8fa0435398a73a922ce85418","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["051c3069a96e986b8fa0435398a73a922ce85418","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"cc3d5f49e404387af0c20abb76ef75489cc1a748":["051c3069a96e986b8fa0435398a73a922ce85418"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"051c3069a96e986b8fa0435398a73a922ce85418":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"efff98a8632f3c2f5b05f961e22a67f122db81e0":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","efff98a8632f3c2f5b05f961e22a67f122db81e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["685bd38810c206c93e9058f3c2cfa9827c086c27","efff98a8632f3c2f5b05f961e22a67f122db81e0","0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"cc3d5f49e404387af0c20abb76ef75489cc1a748":["b21283ed01203901a7257aa4b7f0a0899c86e56e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"051c3069a96e986b8fa0435398a73a922ce85418":["b21283ed01203901a7257aa4b7f0a0899c86e56e","685bd38810c206c93e9058f3c2cfa9827c086c27","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","cc3d5f49e404387af0c20abb76ef75489cc1a748"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","051c3069a96e986b8fa0435398a73a922ce85418"],"efff98a8632f3c2f5b05f961e22a67f122db81e0":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["685bd38810c206c93e9058f3c2cfa9827c086c27","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}