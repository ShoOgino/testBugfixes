{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].commit();\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = \n      FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = \n      tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].commit();\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = \n      FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = \n      tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1","date":1353511594,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].commit();\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = \n      FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = \n      tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].commit();\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = \n      FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = \n      tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4c6c7f3cda7a0595cabd16e5e9107ca29852708","date":1355402234,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2cd18c7da6f499a33f06fc89c07a463ec074c0","date":1358329431,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams, null);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90213788e5007cc5e2b3d88200a8265de9d4e6d4","date":1359060940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"239f79ed06f0979cfe1911ec5fba32b94fda43c1","date":1359553898,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n      \n      @Override\n      public CategoryListParams getCategoryListParams(CategoryPath category) {\n        return new CategoryListParams() {\n          @Override\n          public OrdinalPolicy getOrdinalPolicy(String dimension) {\n            return OrdinalPolicy.ALL_PARENTS;\n          }\n        };\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc","date":1359570667,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache();\n\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n      \n      @Override\n      public CategoryListParams getCategoryListParams(CategoryPath category) {\n        return new CategoryListParams() {\n          @Override\n          public OrdinalPolicy getOrdinalPolicy(String dimension) {\n            return OrdinalPolicy.ALL_PARENTS;\n          }\n        };\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    String[] categories = new String[] { \"a/b\", \"c/d\", \"a/e\", \"a/d\", \"c/g\", \"c/z\", \"b/a\", \"1/2\", \"b/c\" };\n\n    FacetFields facetFields = new FacetFields(taxoWriter, iParams);\n    for (String cat : categories) {\n      Document doc = new Document();\n      facetFields.addFields(doc, Collections.singletonList(new CategoryPath(cat, '/')));\n      indexWriter.addDocument(doc);\n    }\n\n    // Commit Changes\n    IOUtils.close(indexWriter, taxoWriter);\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, indexReader, taxoReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, indexReader, taxoReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(indexReader, taxoReader, iParams);\n\n    int partition = 0;\n    for (int i = 0; i < expectedCounts.length; i += partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n      \n      @Override\n      public CategoryListParams getCategoryListParams(CategoryPath category) {\n        return new CategoryListParams() {\n          @Override\n          public OrdinalPolicy getOrdinalPolicy(String dimension) {\n            return OrdinalPolicy.ALL_PARENTS;\n          }\n        };\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache();\n\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n      \n      @Override\n      public CategoryListParams getCategoryListParams(CategoryPath category) {\n        return new CategoryListParams() {\n          @Override\n          public OrdinalPolicy getOrdinalPolicy(String dimension) {\n            return OrdinalPolicy.ALL_PARENTS;\n          }\n        };\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    String[] categories = new String[] { \"a/b\", \"c/d\", \"a/e\", \"a/d\", \"c/g\", \"c/z\", \"b/a\", \"1/2\", \"b/c\" };\n\n    FacetFields facetFields = new FacetFields(taxoWriter, iParams);\n    for (String cat : categories) {\n      Document doc = new Document();\n      facetFields.addFields(doc, Collections.singletonList(new CategoryPath(cat, '/')));\n      indexWriter.addDocument(doc);\n    }\n\n    // Commit Changes\n    IOUtils.close(indexWriter, taxoWriter);\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, indexReader, taxoReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, indexReader, taxoReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(indexReader, taxoReader, iParams);\n\n    int partition = 0;\n    for (int i = 0; i < expectedCounts.length; i += partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache(1);\n\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    \n    // Add a facet to the index\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"e\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"d\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"g\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"c\", \"z\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"a\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"1\", \"2\");\n    TestTotalFacetCountsCache.addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"b\", \"c\");\n\n    // Commit Changes\n    writers[0].close();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n\n    int partition = 0;\n    for (int i=0; i<expectedCounts.length; i+=partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"607428da722dcb3e86bbd11c63de8986e6275c36","date":1360334150,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCounts#doTestWriteRead(int).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts#doTestWriteRead(int).mjava","sourceNew":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache();\n\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n      \n      @Override\n      public CategoryListParams getCategoryListParams(CategoryPath category) {\n        return new CategoryListParams() {\n          @Override\n          public OrdinalPolicy getOrdinalPolicy(String dimension) {\n            return OrdinalPolicy.ALL_PARENTS;\n          }\n        };\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    String[] categories = new String[] { \"a/b\", \"c/d\", \"a/e\", \"a/d\", \"c/g\", \"c/z\", \"b/a\", \"1/2\", \"b/c\" };\n\n    FacetFields facetFields = new FacetFields(taxoWriter, iParams);\n    for (String cat : categories) {\n      Document doc = new Document();\n      facetFields.addFields(doc, Collections.singletonList(new CategoryPath(cat, '/')));\n      indexWriter.addDocument(doc);\n    }\n\n    // Commit Changes\n    IOUtils.close(indexWriter, taxoWriter);\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, indexReader, taxoReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, indexReader, taxoReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(indexReader, taxoReader, iParams);\n\n    int partition = 0;\n    for (int i = 0; i < expectedCounts.length; i += partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n    tmpFile.delete();\n  }\n\n","sourceOld":"  private void doTestWriteRead(final int partitionSize) throws IOException {\n    initCache();\n\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return partitionSize;\n      }\n      \n      @Override\n      public CategoryListParams getCategoryListParams(CategoryPath category) {\n        return new CategoryListParams() {\n          @Override\n          public OrdinalPolicy getOrdinalPolicy(String dimension) {\n            return OrdinalPolicy.ALL_PARENTS;\n          }\n        };\n      }\n    };\n    // The counts that the TotalFacetCountsArray should have after adding\n    // the below facets to the index.\n    int[] expectedCounts = new int[] { 0, 3, 1, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1 };\n    String[] categories = new String[] { \"a/b\", \"c/d\", \"a/e\", \"a/d\", \"c/g\", \"c/z\", \"b/a\", \"1/2\", \"b/c\" };\n\n    FacetFields facetFields = new FacetFields(taxoWriter, iParams);\n    for (String cat : categories) {\n      Document doc = new Document();\n      facetFields.addFields(doc, Collections.singletonList(new CategoryPath(cat, '/')));\n      indexWriter.addDocument(doc);\n    }\n\n    // Commit Changes\n    IOUtils.close(indexWriter, taxoWriter);\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    \n    int[] intArray = new int[iParams.getPartitionSize()];\n\n    TotalFacetCountsCache tfcc = TotalFacetCountsCache.getSingleton();\n    File tmpFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    tfcc.store(tmpFile, indexReader, taxoReader, iParams);\n    tfcc.clear(); // not really required because TFCC overrides on load(), but in the test we need not rely on this.\n    tfcc.load(tmpFile, indexReader, taxoReader, iParams);\n    \n    // now retrieve the one just loaded\n    TotalFacetCounts totalCounts = tfcc.getTotalCounts(indexReader, taxoReader, iParams);\n\n    int partition = 0;\n    for (int i = 0; i < expectedCounts.length; i += partitionSize) {\n      totalCounts.fillTotalCountsForPartition(intArray, partition);\n      int[] partitionExpectedCounts = new int[partitionSize];\n      int nToCopy = Math.min(partitionSize,expectedCounts.length-i);\n      System.arraycopy(expectedCounts, i, partitionExpectedCounts, 0, nToCopy);\n      assertTrue(\"Wrong counts! for partition \"+partition+\n          \"\\nExpected:\\n\" + Arrays.toString(partitionExpectedCounts)+\n          \"\\nActual:\\n\" + Arrays.toString(intArray),\n          Arrays.equals(partitionExpectedCounts, intArray));\n      ++partition;\n    }\n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n    tmpFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b89678825b68eccaf09e6ab71675fc0b0af1e099","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["c4015cd39dff8d4dec562d909f9766debac53aa6","90213788e5007cc5e2b3d88200a8265de9d4e6d4"],"1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc":["239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"607428da722dcb3e86bbd11c63de8986e6275c36":["1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc"],"90213788e5007cc5e2b3d88200a8265de9d4e6d4":["6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"61d5f95d14e5b9b046998c51e16709a398c15226":["dd45d4a2ee01a1932d33eec42f5272c2402da679","1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc"],"d4c6c7f3cda7a0595cabd16e5e9107ca29852708":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["90213788e5007cc5e2b3d88200a8265de9d4e6d4"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["607428da722dcb3e86bbd11c63de8986e6275c36"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["dd45d4a2ee01a1932d33eec42f5272c2402da679"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["61d5f95d14e5b9b046998c51e16709a398c15226"],"1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc":["607428da722dcb3e86bbd11c63de8986e6275c36","61d5f95d14e5b9b046998c51e16709a398c15226"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["407687e67faf6e1f02a211ca078d8e3eed631027","d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["407687e67faf6e1f02a211ca078d8e3eed631027","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"90213788e5007cc5e2b3d88200a8265de9d4e6d4":["dd45d4a2ee01a1932d33eec42f5272c2402da679","239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"607428da722dcb3e86bbd11c63de8986e6275c36":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"d4c6c7f3cda7a0595cabd16e5e9107ca29852708":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["c4015cd39dff8d4dec562d909f9766debac53aa6","90213788e5007cc5e2b3d88200a8265de9d4e6d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["61d5f95d14e5b9b046998c51e16709a398c15226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}