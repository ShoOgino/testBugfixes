{"path":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","commits":[{"id":"bf795ee457272965bd751f513787065bbf0a650a","date":1385015231,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","sourceNew":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<FieldFacetStats>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList<?> getFieldCacheStats(String fieldName, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf);\n\n    List<FieldFacetStats> facetStats = new ArrayList<FieldFacetStats>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<FieldFacetStats>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","sourceNew":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<FieldFacetStats>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c20e2f66487155554bc2d8bc489e0ff1686ba915","date":1394942287,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","sourceNew":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"610c97b96420e614c67797fd43822ebc1d4b7ee2","date":1410814832,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField[StatsComponent]#getFieldCacheStats(DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,boolean,String[]).mjava","sourceNew":"  private StatsValues getFieldCacheStats(DocSet base) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facets ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats;\n  }\n\n","sourceOld":"  public NamedList<?> getFieldCacheStats(String fieldName, boolean calcDistinct, String[] facet) throws IOException {\n    IndexSchema schema = searcher.getSchema();\n    final SchemaField sf = schema.getField(fieldName);\n\n    final StatsValues allstats = StatsValuesFactory.createStatsValues(sf, calcDistinct);\n\n    List<FieldFacetStats> facetStats = new ArrayList<>();\n    for( String facetField : facet ) {\n      SchemaField fsf = schema.getField(facetField);\n\n      if ( fsf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Stats can only facet on single-valued fields, not: \" + facetField );\n      }\n\n      facetStats.add(new FieldFacetStats(searcher, facetField, sf, fsf, calcDistinct));\n    }\n\n    final Iterator<AtomicReaderContext> ctxIt = searcher.getIndexReader().leaves().iterator();\n    AtomicReaderContext ctx = null;\n    for (DocIterator docsIt = base.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc()) {\n        // advance\n        do {\n          ctx = ctxIt.next();\n        } while (ctx == null || doc >= ctx.docBase + ctx.reader().maxDoc());\n        assert doc >= ctx.docBase;\n\n        // propagate the context among accumulators.\n        allstats.setNextReader(ctx);\n        for (FieldFacetStats f : facetStats) {\n          f.setNextReader(ctx);\n        }\n      }\n\n      // accumulate\n      allstats.accumulate(doc - ctx.docBase);\n      for (FieldFacetStats f : facetStats) {\n        f.facet(doc - ctx.docBase);\n      }\n    }\n\n    for (FieldFacetStats f : facetStats) {\n      allstats.addFacet(f.name, f.facetStatsValues);\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bf795ee457272965bd751f513787065bbf0a650a"],"610c97b96420e614c67797fd43822ebc1d4b7ee2":["c20e2f66487155554bc2d8bc489e0ff1686ba915"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bf795ee457272965bd751f513787065bbf0a650a"],"c20e2f66487155554bc2d8bc489e0ff1686ba915":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bf795ee457272965bd751f513787065bbf0a650a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["610c97b96420e614c67797fd43822ebc1d4b7ee2"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c20e2f66487155554bc2d8bc489e0ff1686ba915"],"610c97b96420e614c67797fd43822ebc1d4b7ee2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","bf795ee457272965bd751f513787065bbf0a650a"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c20e2f66487155554bc2d8bc489e0ff1686ba915":["610c97b96420e614c67797fd43822ebc1d4b7ee2"],"bf795ee457272965bd751f513787065bbf0a650a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}