{"path":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","commits":[{"id":"0e8270c911ac3f2780a5d8660bd53be1aa142ad8","date":1497368366,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecb39e783dd104116a9502e8b0ab3df89f35ac19","date":1499167547,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","sourceNew":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n          if (targetCore != null && !targetCore.equals(coreName)) {\n            continue;\n          }\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            recovered = replica;\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","sourceOld":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","sourceNew":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n          if (targetCore != null && !targetCore.equals(coreName)) {\n            continue;\n          }\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            recovered = replica;\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","sourceOld":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bcfee499548996a6e5448bbf93b8f276d010270","date":1508336936,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd.RecoveryWatcher#onStateChanged(Set[String],DocCollection).mjava","sourceNew":null,"sourceOld":"    @Override\n    public boolean onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n      if (collectionState == null) { // collection has been deleted - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      Slice slice = collectionState.getSlice(shardId);\n      if (slice == null) { // shard has been removed - don't wait\n        countDownLatch.countDown();\n        return true;\n      }\n      for (Replica replica : slice.getReplicas()) {\n        // check if another replica exists - doesn't have to be the one we're moving\n        // as long as it's active and can become a leader, in which case we don't have to wait\n        // for recovery of specifically the one that we've just added\n        if (!replica.getName().equals(replicaId)) {\n          if (replica.getType().equals(Replica.Type.PULL)) { // not eligible for leader election\n            continue;\n          }\n          // check its state\n          String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n          if (targetCore != null && !targetCore.equals(coreName)) {\n            continue;\n          }\n          if (replica.isActive(liveNodes)) { // recovered - stop waiting\n            recovered = replica;\n            countDownLatch.countDown();\n            return true;\n          }\n        }\n      }\n      // set the watch again to wait for the new replica to recover\n      return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2bcfee499548996a6e5448bbf93b8f276d010270":["ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0e8270c911ac3f2780a5d8660bd53be1aa142ad8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e8270c911ac3f2780a5d8660bd53be1aa142ad8"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0e8270c911ac3f2780a5d8660bd53be1aa142ad8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2bcfee499548996a6e5448bbf93b8f276d010270"],"ecb39e783dd104116a9502e8b0ab3df89f35ac19":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"2bcfee499548996a6e5448bbf93b8f276d010270":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0e8270c911ac3f2780a5d8660bd53be1aa142ad8","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"0e8270c911ac3f2780a5d8660bd53be1aa142ad8":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"28288370235ed02234a64753cdbf0c6ec096304a":["ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"ecb39e783dd104116a9502e8b0ab3df89f35ac19":["2bcfee499548996a6e5448bbf93b8f276d010270","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}