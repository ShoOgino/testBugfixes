{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","commits":[{"id":"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2","date":1498616740,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98f11c416d30e556e0004a9a84960702d12d35b1","date":1498628359,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47a99fe8ee3f74e8da2ece1bddbc059d1e1beffa","date":1498706808,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        if (collections != null) {\n          for (String coll : collections) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n              session.addClausesForCollection(session.dataProvider, coll);\n            }\n            for (Row row : session.matrix) {\n              if (!row.collectionVsShardVsReplicas.containsKey(coll))\n                row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n              if (shard != null) {\n                Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n                if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n              }\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"/dev/null","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5088ce415a50eb8412f4942aeabe293e75c81e7","date":1504531555,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n        Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n        if (!collections.isEmpty() || !s.isEmpty()) {\n          HashSet<Pair<String, String>> shards = new HashSet<>(s);\n          collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n          for (Pair<String, String> shard : shards) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n              session.addClausesForCollection(session.dataProvider, shard.first());\n            }\n            for (Row row : session.matrix) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n              if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        if (collections != null) {\n          for (String coll : collections) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n              session.addClausesForCollection(session.dataProvider, coll);\n            }\n            for (Row row : session.matrix) {\n              if (!row.collectionVsShardVsReplicas.containsKey(coll))\n                row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n              if (shard != null) {\n                Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n                if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n              }\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n        Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n        if (!collections.isEmpty() || !s.isEmpty()) {\n          HashSet<Pair<String, String>> shards = new HashSet<>(s);\n          collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n          for (Pair<String, String> shard : shards) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n              session.addClausesForCollection(session.dataProvider, shard.first());\n            }\n            for (Row row : session.matrix) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n              if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n        Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n        if (!collections.isEmpty() || !s.isEmpty()) {\n          HashSet<Pair<String, String>> shards = new HashSet<>(s);\n          collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n          for (Pair<String, String> shard : shards) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n              session.addClausesForCollection(session.dataProvider, shard.first());\n            }\n            for (Row row : session.matrix) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n              if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        String coll = (String) hints.get(Hint.COLL);\n        String shard = (String) hints.get(Hint.SHARD);\n        // if this is not a known collection from the existing clusterstate,\n        // then add it\n        if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(coll))) {\n          session.addClausesForCollection(session.dataProvider, coll);\n          Collections.sort(session.expandedClauses);\n        }\n        if (coll != null) {\n          for (Row row : session.matrix) {\n            if (!row.collectionVsShardVsReplicas.containsKey(coll)) row.collectionVsShardVsReplicas.put(coll, new HashMap<>());\n            if (shard != null) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.get(coll);\n              if (!shardInfo.containsKey(shard)) shardInfo.put(shard, new ArrayList<>());\n            }\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n        Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n        if (!collections.isEmpty() || !s.isEmpty()) {\n          HashSet<Pair<String, String>> shards = new HashSet<>(s);\n          collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n          ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n          for (Pair<String, String> shard : shards) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n              session.addClausesForCollection(stateProvider, shard.first());\n            }\n            for (Row row : session.matrix) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n              if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.cloudManager));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n        Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n        if (!collections.isEmpty() || !s.isEmpty()) {\n          HashSet<Pair<String, String>> shards = new HashSet<>(s);\n          collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n          for (Pair<String, String> shard : shards) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n              session.addClausesForCollection(session.dataProvider, shard.first());\n            }\n            for (Row row : session.matrix) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n              if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.dataProvider));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eaca6a0674512222004d9a2b0ca95d86bda20f1c","date":1508160449,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy.Suggester#getOperation().mjava","sourceNew":null,"sourceOld":"    public SolrRequest getOperation() {\n      if (!isInitialized) {\n        Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n        Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n        if (!collections.isEmpty() || !s.isEmpty()) {\n          HashSet<Pair<String, String>> shards = new HashSet<>(s);\n          collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n          ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n          for (Pair<String, String> shard : shards) {\n            // if this is not a known collection from the existing clusterstate,\n            // then add it\n            if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n              session.addClausesForCollection(stateProvider, shard.first());\n            }\n            for (Row row : session.matrix) {\n              Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n              if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n            }\n          }\n          Collections.sort(session.expandedClauses);\n        }\n        Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n        if (srcNodes != null && !srcNodes.isEmpty()) {\n          // the source node is dead so live nodes may not have it\n          for (String srcNode : srcNodes) {\n            if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.cloudManager));\n          }\n        }\n        session.applyRules();\n        originalViolations.addAll(session.getViolations());\n        this.operation = init();\n        isInitialized = true;\n      }\n      return operation;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["28288370235ed02234a64753cdbf0c6ec096304a","d5088ce415a50eb8412f4942aeabe293e75c81e7"],"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["560c18d71dad43d675158783c3840f8c80d6d39c"],"47a99fe8ee3f74e8da2ece1bddbc059d1e1beffa":["98f11c416d30e556e0004a9a84960702d12d35b1"],"eaca6a0674512222004d9a2b0ca95d86bda20f1c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"560c18d71dad43d675158783c3840f8c80d6d39c":["28288370235ed02234a64753cdbf0c6ec096304a","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"d5088ce415a50eb8412f4942aeabe293e75c81e7":["47a99fe8ee3f74e8da2ece1bddbc059d1e1beffa"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2"],"98f11c416d30e556e0004a9a84960702d12d35b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eaca6a0674512222004d9a2b0ca95d86bda20f1c"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2":["28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2","28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["eaca6a0674512222004d9a2b0ca95d86bda20f1c"],"47a99fe8ee3f74e8da2ece1bddbc059d1e1beffa":["d5088ce415a50eb8412f4942aeabe293e75c81e7"],"eaca6a0674512222004d9a2b0ca95d86bda20f1c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d5088ce415a50eb8412f4942aeabe293e75c81e7":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"560c18d71dad43d675158783c3840f8c80d6d39c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"28288370235ed02234a64753cdbf0c6ec096304a":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c"],"98f11c416d30e556e0004a9a84960702d12d35b1":["47a99fe8ee3f74e8da2ece1bddbc059d1e1beffa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}