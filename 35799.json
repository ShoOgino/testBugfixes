{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter#tooDirty(CompressingTermVectorsReader).mjava","commits":[{"id":"b88448324d3a96c5842455dabea63450b697b58f","date":1421779050,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter#tooDirty(CompressingTermVectorsReader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Returns true if we should recompress this reader, even though we could bulk merge compressed data \n   * <p>\n   * The last chunk written for a segment is typically incomplete, so without recompressing,\n   * in some worst-case situations (e.g. frequent reopen with tiny flushes), over time the \n   * compression ratio can degrade. This is a safety switch.\n   */\n  boolean tooDirty(CompressingTermVectorsReader candidate) {\n    // more than 1% dirty, or more than hard limit of 1024 dirty chunks\n    return candidate.getNumDirtyChunks() > 1024 || \n           candidate.getNumDirtyChunks() * 100 > candidate.getNumChunks();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45264aed0cfa8a8a55ae1292b0e336d29cd88401","date":1600361948,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter#tooDirty(CompressingTermVectorsReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter#tooDirty(CompressingTermVectorsReader).mjava","sourceNew":"  /** \n   * Returns true if we should recompress this reader, even though we could bulk merge compressed data \n   * <p>\n   * The last chunk written for a segment is typically incomplete, so without recompressing,\n   * in some worst-case situations (e.g. frequent reopen with tiny flushes), over time the \n   * compression ratio can degrade. This is a safety switch.\n   */\n  boolean tooDirty(CompressingTermVectorsReader candidate) {\n    // more than 1% dirty, or more than hard limit of 1024 dirty chunks\n    return candidate.getNumDirtyChunks() > 1024 || \n           candidate.getNumDirtyDocs() * 100 > candidate.getNumDocs();\n  }\n\n","sourceOld":"  /** \n   * Returns true if we should recompress this reader, even though we could bulk merge compressed data \n   * <p>\n   * The last chunk written for a segment is typically incomplete, so without recompressing,\n   * in some worst-case situations (e.g. frequent reopen with tiny flushes), over time the \n   * compression ratio can degrade. This is a safety switch.\n   */\n  boolean tooDirty(CompressingTermVectorsReader candidate) {\n    // more than 1% dirty, or more than hard limit of 1024 dirty chunks\n    return candidate.getNumDirtyChunks() > 1024 || \n           candidate.getNumDirtyChunks() * 100 > candidate.getNumChunks();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b88448324d3a96c5842455dabea63450b697b58f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45264aed0cfa8a8a55ae1292b0e336d29cd88401":["b88448324d3a96c5842455dabea63450b697b58f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["45264aed0cfa8a8a55ae1292b0e336d29cd88401"]},"commit2Childs":{"b88448324d3a96c5842455dabea63450b697b58f":["45264aed0cfa8a8a55ae1292b0e336d29cd88401"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b88448324d3a96c5842455dabea63450b697b58f"],"45264aed0cfa8a8a55ae1292b0e336d29cd88401":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}