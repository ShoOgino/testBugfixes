{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","commits":[{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":1,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long,boolean,boolean,long,int).mjava","sourceNew":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // As we recurse, we compute temporary partitions of the data, halving the\n    // number of points at each recursion.  Once there are few enough points,\n    // we can switch to sorting in heap instead of offline (on disk).  At any\n    // time in the recursion, we hold the number of points at that level, plus\n    // all recursive halves (i.e. 16 + 8 + 4 + 2) so the memory usage is 2X\n    // what that level would consume, so we multiply by 0.5 to convert from\n    // bytes to points here.  In addition the radix partitioning may sort on memory\n    // double of this size so we multiply by another 0.5.\n\n    maxPointsSortInHeap = (int) (0.25 * (maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(16, maxPointsSortInHeap, packedBytesLength);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","sourceOld":"  private SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount,\n                              boolean singleValuePerDoc, boolean longOrds, long offlineSorterBufferMB, int offlineSorterMaxTempFiles) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    this.offlineSorterBufferMB = OfflineSorter.BufferSize.megabytes(offlineSorterBufferMB);\n    this.offlineSorterMaxTempFiles = offlineSorterMaxTempFiles;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // If we may have more than 1+Integer.MAX_VALUE values, then we must encode ords with long (8 bytes), else we can use int (4 bytes).\n    this.longOrds = longOrds;\n\n    this.singleValuePerDoc = singleValuePerDoc;\n\n    // dimensional values (numDims * bytesPerDim) + ord (int or long) + docID (int)\n    if (singleValuePerDoc) {\n      // Lucene only supports up to 2.1 docs, so we better not need longOrds in this case:\n      assert longOrds == false;\n      bytesPerDoc = packedBytesLength + Integer.BYTES;\n    } else if (longOrds) {\n      bytesPerDoc = packedBytesLength + Long.BYTES + Integer.BYTES;\n    } else {\n      bytesPerDoc = packedBytesLength + Integer.BYTES + Integer.BYTES;\n    }\n\n    // As we recurse, we compute temporary partitions of the data, halving the\n    // number of points at each recursion.  Once there are few enough points,\n    // we can switch to sorting in heap instead of offline (on disk).  At any\n    // time in the recursion, we hold the number of points at that level, plus\n    // all recursive halves (i.e. 16 + 8 + 4 + 2) so the memory usage is 2X\n    // what that level would consume, so we multiply by 0.5 to convert from\n    // bytes to points here.  Each dimension has its own sorted partition, so\n    // we must divide by numDims as wel.\n\n    maxPointsSortInHeap = (int) (0.5 * (maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(16, maxPointsSortInHeap, packedBytesLength, longOrds, singleValuePerDoc);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a69ebf290ab26d026cc224e517e0d93d931ac87b","date":1549869083,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","sourceNew":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(16, maxPointsSortInHeap, packedBytesLength);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","sourceOld":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // As we recurse, we compute temporary partitions of the data, halving the\n    // number of points at each recursion.  Once there are few enough points,\n    // we can switch to sorting in heap instead of offline (on disk).  At any\n    // time in the recursion, we hold the number of points at that level, plus\n    // all recursive halves (i.e. 16 + 8 + 4 + 2) so the memory usage is 2X\n    // what that level would consume, so we multiply by 0.5 to convert from\n    // bytes to points here.  In addition the radix partitioning may sort on memory\n    // double of this size so we multiply by another 0.5.\n\n    maxPointsSortInHeap = (int) (0.25 * (maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(16, maxPointsSortInHeap, packedBytesLength);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2344a1c769566d8c85cffcacc5e55153fa54b86","date":1550661298,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","sourceNew":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(maxPointsSortInHeap, packedBytesLength);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","sourceOld":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(16, maxPointsSortInHeap, packedBytesLength);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76a51551f05a6c96a115b5a656837ecc8fd0b1ff","date":1551422476,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","sourceNew":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","sourceOld":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    // We write first maxPointsSortInHeap in heap, then cutover to offline for additional points:\n    heapPointWriter = new HeapPointWriter(maxPointsSortInHeap, packedBytesLength);\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":5,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,BKDConfig,double,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter#SimpleTextBKDWriter(int,Directory,String,int,int,int,int,double,long).mjava","sourceNew":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, BKDConfig config, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(maxMBSortInHeap, totalPointCount);\n    this.config = config;\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n\n\n    scratchDiff = new byte[config.bytesPerDim];\n    scratch1 = new byte[config.packedBytesLength];\n    scratch2 = new byte[config.packedBytesLength];\n    commonPrefixLengths = new int[config.numDims];\n\n    minPackedValue = new byte[config.packedIndexBytesLength];\n    maxPackedValue = new byte[config.packedIndexBytesLength];\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (config.bytesPerDoc * config.numDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < config.maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than config.maxPointsInLeafNode=\" + config.maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease config.maxPointsInLeafNode\");\n    }\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","sourceOld":"  public SimpleTextBKDWriter(int maxDoc, Directory tempDir, String tempFileNamePrefix, int numDataDims, int numIndexDims, int bytesPerDim,\n                              int maxPointsInLeafNode, double maxMBSortInHeap, long totalPointCount) throws IOException {\n    verifyParams(numDataDims, numIndexDims, maxPointsInLeafNode, maxMBSortInHeap, totalPointCount);\n    // We use tracking dir to deal with removing files on exception, so each place that\n    // creates temp files doesn't need crazy try/finally/sucess logic:\n    this.tempDir = new TrackingDirectoryWrapper(tempDir);\n    this.tempFileNamePrefix = tempFileNamePrefix;\n    this.maxPointsInLeafNode = maxPointsInLeafNode;\n    this.numDataDims = numDataDims;\n    this.numIndexDims = numIndexDims;\n    this.bytesPerDim = bytesPerDim;\n    this.totalPointCount = totalPointCount;\n    this.maxDoc = maxDoc;\n    docsSeen = new FixedBitSet(maxDoc);\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    scratchDiff = new byte[bytesPerDim];\n    scratch1 = new byte[packedBytesLength];\n    scratch2 = new byte[packedBytesLength];\n    commonPrefixLengths = new int[numDataDims];\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    // dimensional values (numDims * bytesPerDim) +  docID (int)\n    bytesPerDoc = packedBytesLength + Integer.BYTES;\n\n    // Maximum number of points we hold in memory at any time\n    maxPointsSortInHeap = (int) ((maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDataDims));\n\n    // Finally, we must be able to hold at least the leaf node in heap during build:\n    if (maxPointsSortInHeap < maxPointsInLeafNode) {\n      throw new IllegalArgumentException(\"maxMBSortInHeap=\" + maxMBSortInHeap + \" only allows for maxPointsSortInHeap=\" + maxPointsSortInHeap + \", but this is less than maxPointsInLeafNode=\" + maxPointsInLeafNode + \"; either increase maxMBSortInHeap or decrease maxPointsInLeafNode\");\n    }\n\n    this.maxMBSortInHeap = maxMBSortInHeap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["a69ebf290ab26d026cc224e517e0d93d931ac87b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a69ebf290ab26d026cc224e517e0d93d931ac87b":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2344a1c769566d8c85cffcacc5e55153fa54b86":["76a51551f05a6c96a115b5a656837ecc8fd0b1ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["a69ebf290ab26d026cc224e517e0d93d931ac87b"],"a69ebf290ab26d026cc224e517e0d93d931ac87b":["c2344a1c769566d8c85cffcacc5e55153fa54b86"],"76a51551f05a6c96a115b5a656837ecc8fd0b1ff":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}