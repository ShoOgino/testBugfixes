{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","commits":[{"id":"cedcb3038bb218e20fc9c61e3b50642101e656e8","date":1454869299,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-6835: make sure best-effort to not create an \"apparently but not really\" corrupt index is working:\n  public void testExcInDeleteFile() throws Throwable {\n    int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      MockDirectoryWrapper dir = newMockDirectory();\n\n      final AtomicBoolean doFailExc = new AtomicBoolean();\n\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            if (doFailExc.get() && random().nextInt(4) == 1) {\n              Exception e = new Exception();\n              StackTraceElement stack[] = e.getStackTrace();\n              for (int i = 0; i < stack.length; i++) {\n                if (stack[i].getClassName().equals(MockDirectoryWrapper.class.getName()) && stack[i].getMethodName().equals(\"deleteFile\")) {\n                  throw new MockDirectoryWrapper.FakeIOException();\n                }\n              }\n            }\n          }\n        });\n\n      IndexWriterConfig iwc = newIndexWriterConfig();\n      iwc.setMergeScheduler(new SerialMergeScheduler());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      w.addDocument(new Document());\n\n      // makes segments_1\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit\");\n      }\n      w.commit();\n\n      w.addDocument(new Document());\n      doFailExc.set(true);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now close\");\n      }\n      try {\n        w.close();\n        if (VERBOSE) {\n          System.out.println(\"TEST: no exception (ok)\");\n        }\n      } catch (RuntimeException re) {\n        assertTrue(re.getCause() instanceof MockDirectoryWrapper.FakeIOException);\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          re.printStackTrace(System.out);\n        }\n      } catch (MockDirectoryWrapper.FakeIOException fioe) {\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          fioe.printStackTrace(System.out);\n        }\n      }\n      doFailExc.set(false);\n      assertFalse(w.w.isOpen());\n\n      for(String name : dir.listAll()) {\n        if (name.startsWith(IndexFileNames.SEGMENTS)) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: now read \" + name);\n          }\n          SegmentInfos.readCommit(dir, name);\n        }\n      }\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd75f58072bba84066e89d61bd7028de1bd5b632","date":1454871793,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-6835: make sure best-effort to not create an \"apparently but not really\" corrupt index is working:\n  public void testExcInDeleteFile() throws Throwable {\n    int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      MockDirectoryWrapper dir = newMockDirectory();\n\n      final AtomicBoolean doFailExc = new AtomicBoolean();\n\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            if (doFailExc.get() && random().nextInt(4) == 1) {\n              Exception e = new Exception();\n              StackTraceElement stack[] = e.getStackTrace();\n              for (int i = 0; i < stack.length; i++) {\n                if (stack[i].getClassName().equals(MockDirectoryWrapper.class.getName()) && stack[i].getMethodName().equals(\"deleteFile\")) {\n                  throw new MockDirectoryWrapper.FakeIOException();\n                }\n              }\n            }\n          }\n        });\n\n      IndexWriterConfig iwc = newIndexWriterConfig();\n      iwc.setMergeScheduler(new SerialMergeScheduler());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      w.addDocument(new Document());\n\n      // makes segments_1\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit\");\n      }\n      w.commit();\n\n      w.addDocument(new Document());\n      doFailExc.set(true);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now close\");\n      }\n      try {\n        w.close();\n        if (VERBOSE) {\n          System.out.println(\"TEST: no exception (ok)\");\n        }\n      } catch (RuntimeException re) {\n        assertTrue(re.getCause() instanceof MockDirectoryWrapper.FakeIOException);\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          re.printStackTrace(System.out);\n        }\n      } catch (MockDirectoryWrapper.FakeIOException fioe) {\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          fioe.printStackTrace(System.out);\n        }\n      }\n      doFailExc.set(false);\n      assertFalse(w.w.isOpen());\n\n      for(String name : dir.listAll()) {\n        if (name.startsWith(IndexFileNames.SEGMENTS)) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: now read \" + name);\n          }\n          SegmentInfos.readCommit(dir, name);\n        }\n      }\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2916966cc9815e973c01452a0d76c98c5e0d0926","date":1577444040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","sourceNew":"  // LUCENE-6835: make sure best-effort to not create an \"apparently but not really\" corrupt index is working:\n  public void testExcInDeleteFile() throws Throwable {\n    int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      MockDirectoryWrapper dir = newMockDirectory();\n\n      final AtomicBoolean doFailExc = new AtomicBoolean();\n\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            if (doFailExc.get() && random().nextInt(4) == 1) {\n              if (callStackContains(MockDirectoryWrapper.class, \"deleteFile\")) {\n                throw new MockDirectoryWrapper.FakeIOException();\n              }\n            }\n          }\n        });\n\n      IndexWriterConfig iwc = newIndexWriterConfig();\n      iwc.setMergeScheduler(new SerialMergeScheduler());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      w.addDocument(new Document());\n\n      // makes segments_1\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit\");\n      }\n      w.commit();\n\n      w.addDocument(new Document());\n      doFailExc.set(true);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now close\");\n      }\n      try {\n        w.close();\n        if (VERBOSE) {\n          System.out.println(\"TEST: no exception (ok)\");\n        }\n      } catch (RuntimeException re) {\n        assertTrue(re.getCause() instanceof MockDirectoryWrapper.FakeIOException);\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          re.printStackTrace(System.out);\n        }\n      } catch (MockDirectoryWrapper.FakeIOException fioe) {\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          fioe.printStackTrace(System.out);\n        }\n      }\n      doFailExc.set(false);\n      assertFalse(w.w.isOpen());\n\n      for(String name : dir.listAll()) {\n        if (name.startsWith(IndexFileNames.SEGMENTS)) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: now read \" + name);\n          }\n          SegmentInfos.readCommit(dir, name);\n        }\n      }\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // LUCENE-6835: make sure best-effort to not create an \"apparently but not really\" corrupt index is working:\n  public void testExcInDeleteFile() throws Throwable {\n    int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      MockDirectoryWrapper dir = newMockDirectory();\n\n      final AtomicBoolean doFailExc = new AtomicBoolean();\n\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            if (doFailExc.get() && random().nextInt(4) == 1) {\n              Exception e = new Exception();\n              StackTraceElement stack[] = e.getStackTrace();\n              for (int i = 0; i < stack.length; i++) {\n                if (stack[i].getClassName().equals(MockDirectoryWrapper.class.getName()) && stack[i].getMethodName().equals(\"deleteFile\")) {\n                  throw new MockDirectoryWrapper.FakeIOException();\n                }\n              }\n            }\n          }\n        });\n\n      IndexWriterConfig iwc = newIndexWriterConfig();\n      iwc.setMergeScheduler(new SerialMergeScheduler());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      w.addDocument(new Document());\n\n      // makes segments_1\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit\");\n      }\n      w.commit();\n\n      w.addDocument(new Document());\n      doFailExc.set(true);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now close\");\n      }\n      try {\n        w.close();\n        if (VERBOSE) {\n          System.out.println(\"TEST: no exception (ok)\");\n        }\n      } catch (RuntimeException re) {\n        assertTrue(re.getCause() instanceof MockDirectoryWrapper.FakeIOException);\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          re.printStackTrace(System.out);\n        }\n      } catch (MockDirectoryWrapper.FakeIOException fioe) {\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          fioe.printStackTrace(System.out);\n        }\n      }\n      doFailExc.set(false);\n      assertFalse(w.w.isOpen());\n\n      for(String name : dir.listAll()) {\n        if (name.startsWith(IndexFileNames.SEGMENTS)) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: now read \" + name);\n          }\n          SegmentInfos.readCommit(dir, name);\n        }\n      }\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec73c5617c177b1d81ddfe04bbff1d08fccecc","date":1577456244,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter#testExcInDeleteFile().mjava","sourceNew":"  // LUCENE-6835: make sure best-effort to not create an \"apparently but not really\" corrupt index is working:\n  public void testExcInDeleteFile() throws Throwable {\n    int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      MockDirectoryWrapper dir = newMockDirectory();\n\n      final AtomicBoolean doFailExc = new AtomicBoolean();\n\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            if (doFailExc.get() && random().nextInt(4) == 1) {\n              if (callStackContains(MockDirectoryWrapper.class, \"deleteFile\")) {\n                throw new MockDirectoryWrapper.FakeIOException();\n              }\n            }\n          }\n        });\n\n      IndexWriterConfig iwc = newIndexWriterConfig();\n      iwc.setMergeScheduler(new SerialMergeScheduler());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      w.addDocument(new Document());\n\n      // makes segments_1\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit\");\n      }\n      w.commit();\n\n      w.addDocument(new Document());\n      doFailExc.set(true);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now close\");\n      }\n      try {\n        w.close();\n        if (VERBOSE) {\n          System.out.println(\"TEST: no exception (ok)\");\n        }\n      } catch (RuntimeException re) {\n        assertTrue(re.getCause() instanceof MockDirectoryWrapper.FakeIOException);\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          re.printStackTrace(System.out);\n        }\n      } catch (MockDirectoryWrapper.FakeIOException fioe) {\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          fioe.printStackTrace(System.out);\n        }\n      }\n      doFailExc.set(false);\n      assertFalse(w.w.isOpen());\n\n      for(String name : dir.listAll()) {\n        if (name.startsWith(IndexFileNames.SEGMENTS)) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: now read \" + name);\n          }\n          SegmentInfos.readCommit(dir, name);\n        }\n      }\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // LUCENE-6835: make sure best-effort to not create an \"apparently but not really\" corrupt index is working:\n  public void testExcInDeleteFile() throws Throwable {\n    int iters = atLeast(10);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      MockDirectoryWrapper dir = newMockDirectory();\n\n      final AtomicBoolean doFailExc = new AtomicBoolean();\n\n      dir.failOn(new MockDirectoryWrapper.Failure() {\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            if (doFailExc.get() && random().nextInt(4) == 1) {\n              Exception e = new Exception();\n              StackTraceElement stack[] = e.getStackTrace();\n              for (int i = 0; i < stack.length; i++) {\n                if (stack[i].getClassName().equals(MockDirectoryWrapper.class.getName()) && stack[i].getMethodName().equals(\"deleteFile\")) {\n                  throw new MockDirectoryWrapper.FakeIOException();\n                }\n              }\n            }\n          }\n        });\n\n      IndexWriterConfig iwc = newIndexWriterConfig();\n      iwc.setMergeScheduler(new SerialMergeScheduler());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      w.addDocument(new Document());\n\n      // makes segments_1\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit\");\n      }\n      w.commit();\n\n      w.addDocument(new Document());\n      doFailExc.set(true);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now close\");\n      }\n      try {\n        w.close();\n        if (VERBOSE) {\n          System.out.println(\"TEST: no exception (ok)\");\n        }\n      } catch (RuntimeException re) {\n        assertTrue(re.getCause() instanceof MockDirectoryWrapper.FakeIOException);\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          re.printStackTrace(System.out);\n        }\n      } catch (MockDirectoryWrapper.FakeIOException fioe) {\n        // good\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exception:\");\n          fioe.printStackTrace(System.out);\n        }\n      }\n      doFailExc.set(false);\n      assertFalse(w.w.isOpen());\n\n      for(String name : dir.listAll()) {\n        if (name.startsWith(IndexFileNames.SEGMENTS)) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: now read \" + name);\n          }\n          SegmentInfos.readCommit(dir, name);\n        }\n      }\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd75f58072bba84066e89d61bd7028de1bd5b632":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cedcb3038bb218e20fc9c61e3b50642101e656e8"],"cedcb3038bb218e20fc9c61e3b50642101e656e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2916966cc9815e973c01452a0d76c98c5e0d0926":["cedcb3038bb218e20fc9c61e3b50642101e656e8"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":["cedcb3038bb218e20fc9c61e3b50642101e656e8","2916966cc9815e973c01452a0d76c98c5e0d0926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2916966cc9815e973c01452a0d76c98c5e0d0926"]},"commit2Childs":{"dd75f58072bba84066e89d61bd7028de1bd5b632":[],"cedcb3038bb218e20fc9c61e3b50642101e656e8":["dd75f58072bba84066e89d61bd7028de1bd5b632","2916966cc9815e973c01452a0d76c98c5e0d0926","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd75f58072bba84066e89d61bd7028de1bd5b632","cedcb3038bb218e20fc9c61e3b50642101e656e8"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd75f58072bba84066e89d61bd7028de1bd5b632","94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}