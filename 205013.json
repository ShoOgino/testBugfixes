{"path":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","commits":[{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","pathOld":"/dev/null","sourceNew":"  public void testRoundTripParsing() {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = QueryParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd3693b696a64d987bf4b3a14399d2105f16b05e","date":1396054865,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","sourceNew":"  public void testRoundTripParsing() throws IOException {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = QueryParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRoundTripParsing() {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = QueryParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","sourceNew":"  public void testRoundTripParsing() throws IOException {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = QueryParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRoundTripParsing() {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = QueryParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c8dc56dbae186505066de8a78986cba31525ef0","date":1447876120,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/CursorMarkTest#testRoundTripParsing().mjava","sourceNew":"  public void testRoundTripParsing() throws IOException {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = SortSpecParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRoundTripParsing() throws IOException {\n\n    // for any valid SortSpec, and any legal values, we should be able to round \n    // trip serialize the totem and get the same values back.\n\n    final Collection<String> allFieldNames = getAllFieldNames();\n    final SolrQueryRequest req = req();\n    final IndexSchema schema = req.getSchema();\n    final int numRandomSorts = atLeast(50);\n    final int numRandomValIters = atLeast(10);\n    for (int i = 0; i < numRandomSorts; i++) {\n      final SortSpec ss = QueryParsing.parseSortSpec\n        (CursorPagingTest.buildRandomSort(allFieldNames), req);\n      final CursorMark totemIn = new CursorMark(schema, ss);\n      final CursorMark totemOut = new CursorMark(schema, ss);\n\n      // trivial case: regardless of sort, \"*\" should be valid and roundtrippable\n      totemIn.parseSerializedTotem(CURSOR_MARK_START);\n      assertEquals(CURSOR_MARK_START, totemIn.getSerializedTotem());\n      // values should be null (and still roundtrippable)\n      assertNull(totemIn.getSortValues());\n      totemOut.setSortValues(null);\n      assertEquals(CURSOR_MARK_START, totemOut.getSerializedTotem());\n\n      for (int j = 0; j < numRandomValIters; j++) {\n        final Object[] inValues = buildRandomSortObjects(ss);\n        totemIn.setSortValues(Arrays.<Object>asList(inValues));\n        totemOut.parseSerializedTotem(totemIn.getSerializedTotem());\n        final List<Object> out = totemOut.getSortValues();\n        assertNotNull(out);\n        final Object[] outValues = out.toArray();\n        assertArrayEquals(inValues, outValues);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2","cd3693b696a64d987bf4b3a14399d2105f16b05e"],"6c8dc56dbae186505066de8a78986cba31525ef0":["cd3693b696a64d987bf4b3a14399d2105f16b05e"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd3693b696a64d987bf4b3a14399d2105f16b05e":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6c8dc56dbae186505066de8a78986cba31525ef0"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"6c8dc56dbae186505066de8a78986cba31525ef0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["5eb2511ababf862ea11e10761c70ee560cd84510","cd3693b696a64d987bf4b3a14399d2105f16b05e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"cd3693b696a64d987bf4b3a14399d2105f16b05e":["5eb2511ababf862ea11e10761c70ee560cd84510","6c8dc56dbae186505066de8a78986cba31525ef0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}