{"path":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","commits":[{"id":"20f6b7cff3771384f27af0f059795d7e64aff6b9","date":1425498309,"type":1,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#startExecutorService().mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollInterval = readInterval(pollIntervalStr);\n    if (pollInterval == null || pollInterval <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        if (pollDisabled.get()) {\n          LOG.info(\"Poll disabled\");\n          return;\n        }\n        try {\n          LOG.debug(\"Polling for index modifications\");\n          executorStartTime = System.currentTimeMillis();\n          doFetch(null, false);\n        } catch (Exception e) {\n          LOG.error(\"Exception in fetching index\", e);\n        }\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    long initialDelay = pollInterval - (System.currentTimeMillis() % pollInterval);\n    executorService.scheduleAtFixedRate(task, initialDelay, pollInterval, TimeUnit.MILLISECONDS);\n    LOG.info(\"Poll Scheduled at an interval of \" + pollInterval + \"ms\");\n  }\n\n","sourceOld":"  private void startExecutorService() {\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        if (pollDisabled.get()) {\n          LOG.info(\"Poll disabled\");\n          return;\n        }\n        try {\n          LOG.debug(\"Polling for index modifications\");\n          executorStartTime = System.currentTimeMillis();\n          replicationHandler.doFetch(null, false);\n        } catch (Exception e) {\n          LOG.error(\"Exception in fetching index\", e);\n        }\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"snapPuller\"));\n    long initialDelay = pollInterval - (System.currentTimeMillis() % pollInterval);\n    executorService.scheduleAtFixedRate(task, initialDelay, pollInterval, TimeUnit.MILLISECONDS);\n    LOG.info(\"Poll Scheduled at an interval of \" + pollInterval + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"/dev/null","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollInterval = readInterval(pollIntervalStr);\n    if (pollInterval == null || pollInterval <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        if (pollDisabled.get()) {\n          LOG.info(\"Poll disabled\");\n          return;\n        }\n        try {\n          LOG.debug(\"Polling for index modifications\");\n          executorStartTime = System.currentTimeMillis();\n          doFetch(null, false);\n        } catch (Exception e) {\n          LOG.error(\"Exception in fetching index\", e);\n        }\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    long initialDelay = pollInterval - (System.currentTimeMillis() % pollInterval);\n    executorService.scheduleAtFixedRate(task, initialDelay, pollInterval, TimeUnit.MILLISECONDS);\n    LOG.info(\"Poll Scheduled at an interval of \" + pollInterval + \"ms\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        if (pollDisabled.get()) {\n          LOG.info(\"Poll disabled\");\n          return;\n        }\n        try {\n          LOG.debug(\"Polling for index modifications\");\n          markScheduledExecutionStart();\n          doFetch(null, false);\n        } catch (Exception e) {\n          LOG.error(\"Exception in fetching index\", e);\n        }\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollInterval = readInterval(pollIntervalStr);\n    if (pollInterval == null || pollInterval <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        if (pollDisabled.get()) {\n          LOG.info(\"Poll disabled\");\n          return;\n        }\n        try {\n          LOG.debug(\"Polling for index modifications\");\n          executorStartTime = System.currentTimeMillis();\n          doFetch(null, false);\n        } catch (Exception e) {\n          LOG.error(\"Exception in fetching index\", e);\n        }\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    long initialDelay = pollInterval - (System.currentTimeMillis() % pollInterval);\n    executorService.scheduleAtFixedRate(task, initialDelay, pollInterval, TimeUnit.MILLISECONDS);\n    LOG.info(\"Poll Scheduled at an interval of \" + pollInterval + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        doFetch(null, false);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        if (pollDisabled.get()) {\n          LOG.info(\"Poll disabled\");\n          return;\n        }\n        try {\n          LOG.debug(\"Polling for index modifications\");\n          markScheduledExecutionStart();\n          doFetch(null, false);\n        } catch (Exception e) {\n          LOG.error(\"Exception in fetching index\", e);\n        }\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        doFetch(null, false);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":["04ecf884544ff74add5faa452748f160c4af904b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        doFetch(null, false);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        doFetch(null, false);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c641347aa34a81b8c172fd46691e3cba6357a6f","date":1490409984,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false).getSuccessful();\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":["04ecf884544ff74add5faa452748f160c4af904b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5f6959c652bdf332fe98fc9180b54095a4053ae","date":1490594650,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false).getSuccessful();\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04ecf884544ff74add5faa452748f160c4af904b","date":1506527215,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false).getSuccessful();\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":["be320990bdc77e643388fa801e75017f19289c42","7c641347aa34a81b8c172fd46691e3cba6357a6f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        boolean pollSuccess = doFetch(null, false).getSuccessful();\n        if (pollListener != null) pollListener.onComplete(core, pollSuccess);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      log.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        log.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        log.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        log.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    log.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      LOG.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        LOG.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        LOG.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        LOG.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    LOG.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      log.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        log.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        log.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        log.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new SolrNamedThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    log.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      log.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        log.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        log.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        log.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new DefaultSolrThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    log.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0d5cb585092313dd99717bd4b28f3bf0e96f12","date":1602076937,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ReplicationHandler#setupPolling(String).mjava","sourceNew":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      log.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        log.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        log.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        log.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new SolrNamedThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleWithFixedDelay(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    log.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","sourceOld":"  private void setupPolling(String intervalStr) {\n    pollIntervalStr = intervalStr;\n    pollIntervalNs = readIntervalNs(pollIntervalStr);\n    if (pollIntervalNs == null || pollIntervalNs <= 0) {\n      log.info(\" No value set for 'pollInterval'. Timer Task not started.\");\n      return;\n    }\n\n    Runnable task = () -> {\n      if (pollDisabled.get()) {\n        log.info(\"Poll disabled\");\n        return;\n      }\n      try {\n        log.debug(\"Polling for index modifications\");\n        markScheduledExecutionStart();\n        IndexFetchResult fetchResult = doFetch(null, false);\n        if (pollListener != null) pollListener.onComplete(core, fetchResult);\n      } catch (Exception e) {\n        log.error(\"Exception in fetching index\", e);\n      }\n    };\n    executorService = Executors.newSingleThreadScheduledExecutor(\n        new SolrNamedThreadFactory(\"indexFetcher\"));\n    // Randomize initial delay, with a minimum of 1ms\n    long initialDelayNs = new Random().nextLong() % pollIntervalNs\n        + TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    executorService.scheduleAtFixedRate(task, initialDelayNs, pollIntervalNs, TimeUnit.NANOSECONDS);\n    log.info(\"Poll scheduled at an interval of {}ms\",\n        TimeUnit.MILLISECONDS.convert(pollIntervalNs, TimeUnit.NANOSECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04ecf884544ff74add5faa452748f160c4af904b":["7c641347aa34a81b8c172fd46691e3cba6357a6f"],"0d0d5cb585092313dd99717bd4b28f3bf0e96f12":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"3a0c04b71951333291abc7f317109a6a5957bd28":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"7c641347aa34a81b8c172fd46691e3cba6357a6f":["be320990bdc77e643388fa801e75017f19289c42"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["3a0c04b71951333291abc7f317109a6a5957bd28"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["d5f6959c652bdf332fe98fc9180b54095a4053ae","04ecf884544ff74add5faa452748f160c4af904b"],"d5f6959c652bdf332fe98fc9180b54095a4053ae":["ab68488225b6a6c357dda72ed11dedca9914a192"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["20f6b7cff3771384f27af0f059795d7e64aff6b9"],"be320990bdc77e643388fa801e75017f19289c42":["3a0c04b71951333291abc7f317109a6a5957bd28"],"ab68488225b6a6c357dda72ed11dedca9914a192":["3a0c04b71951333291abc7f317109a6a5957bd28","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d0d5cb585092313dd99717bd4b28f3bf0e96f12"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["04ecf884544ff74add5faa452748f160c4af904b"]},"commit2Childs":{"04ecf884544ff74add5faa452748f160c4af904b":["6240b74b884c5587f2a4062dd27d6c32bf228889","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"0d0d5cb585092313dd99717bd4b28f3bf0e96f12":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a0c04b71951333291abc7f317109a6a5957bd28":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"7c641347aa34a81b8c172fd46691e3cba6357a6f":["04ecf884544ff74add5faa452748f160c4af904b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","bcf9886c8ff537aafde14de48ebf744f5673f08b"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"d5f6959c652bdf332fe98fc9180b54095a4053ae":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["0d0d5cb585092313dd99717bd4b28f3bf0e96f12"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["3a0c04b71951333291abc7f317109a6a5957bd28"],"be320990bdc77e643388fa801e75017f19289c42":["7c641347aa34a81b8c172fd46691e3cba6357a6f"],"ab68488225b6a6c357dda72ed11dedca9914a192":["d5f6959c652bdf332fe98fc9180b54095a4053ae"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}