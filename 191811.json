{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","sourceNew":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"/dev/null","sourceNew":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","sourceNew":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","sourceNew":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","bugFix":["073a74201a21520f4fc543c9f6d1d87c19a467b2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","sourceNew":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    if (isLive) {\n      shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          shardRequestTracker.processResponses(results, shardHandler, false, null);\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","bugFix":["073a74201a21520f4fc543c9f6d1d87c19a467b2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    if (isLive) {\n      shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          shardRequestTracker.processResponses(results, shardHandler, false, null);\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":"  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    if (isLive) {\n      shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          shardRequestTracker.processResponses(results, shardHandler, false, null);\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1964c059f45ae1de1877f9f0fe3ca327ea4218e8","date":1594088246,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteCore(Slice,String,String,ZkNodeProps,String,NamedList,Runnable,boolean).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    if (isLive) {\n      shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          shardRequestTracker.processResponses(results, shardHandler, false, null);\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  void deleteCore(Slice slice, String collectionName, String replicaName,ZkNodeProps message, String shard, @SuppressWarnings({\"rawtypes\"})NamedList results, Runnable onComplete, boolean parallel) throws KeeperException, InterruptedException {\n\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" +  replicaName + \" in shard/collection : \" +\n              shard  + \"/\" + collectionName + \" available replicas are \" +  StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(OverseerCollectionMessageHandler.ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Attempted to remove replica : \" + collectionName + \"/\"  + shard + \"/\" + replicaName +\n              \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n    params.set(CoreAdminParams.DELETE_METRICS_HISTORY, message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    if (isLive) {\n      shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          shardRequestTracker.processResponses(results, shardHandler, false, null);\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                  \"Could not remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["b94236357aaa22b76c10629851fe4e376e0cea82"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["69e6520a21709190413a63084ed135271aab1a7c"],"69e6520a21709190413a63084ed135271aab1a7c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"69e6520a21709190413a63084ed135271aab1a7c":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["69e6520a21709190413a63084ed135271aab1a7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}