{"path":"solr/core/src/java/org/apache/solr/core/CoreMaps[CoreContainer]#getCoreToClose().mjava","commits":[{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreMaps[CoreContainer]#getCoreToClose().mjava","pathOld":"/dev/null","sourceNew":"  // Be a little careful. We don't want to either open or close a core unless it's _not_ being opened or closed by\n  // another thread. So within this lock we'll walk along the list of pending closes until we find something NOT in\n  // the list of threads currently being opened. The \"usual\" case will probably return the very first one anyway..\n  protected SolrCore getCoreToClose() {\n    synchronized (locker) {\n      if (pendingDynamicCloses.size() == 0) return null; // nothing to do.\n      // Yes, a linear search but this is a pretty short list in the normal case and usually we'll take the first one.\n      for (SolrCore core : pendingDynamicCloses) {\n        if (! pendingDynamicLoads.contains(core.getName())) {  // Don't try close a core if it's being opened.\n          return core;\n        }\n      }\n    }\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245","date":1363106546,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreMaps[CoreContainer]#getCoreToClose().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreMaps[CoreContainer]#getCoreToClose().mjava","sourceNew":"  // Be a little careful. We don't want to either open or close a core unless it's _not_ being opened or closed by\n  // another thread. So within this lock we'll walk along the list of pending closes until we find something NOT in\n  // the list of threads currently being loaded or reloaded. The \"usual\" case will probably return the very first\n  // one anyway..\n  protected SolrCore getCoreToClose() {\n    synchronized (locker) {\n      for (SolrCore core : pendingCloses) {\n        if (! pendingCoreOps.contains(core.getName())) {\n          pendingCoreOps.add(core.getName());\n          pendingCloses.remove(core);\n          return core;\n        }\n      }\n    }\n    return null;\n  }\n\n","sourceOld":"  // Be a little careful. We don't want to either open or close a core unless it's _not_ being opened or closed by\n  // another thread. So within this lock we'll walk along the list of pending closes until we find something NOT in\n  // the list of threads currently being opened. The \"usual\" case will probably return the very first one anyway..\n  protected SolrCore getCoreToClose() {\n    synchronized (locker) {\n      if (pendingDynamicCloses.size() == 0) return null; // nothing to do.\n      // Yes, a linear search but this is a pretty short list in the normal case and usually we'll take the first one.\n      for (SolrCore core : pendingDynamicCloses) {\n        if (! pendingDynamicLoads.contains(core.getName())) {  // Don't try close a core if it's being opened.\n          return core;\n        }\n      }\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0","date":1366659310,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreMaps#getCoreToClose().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreMaps[CoreContainer]#getCoreToClose().mjava","sourceNew":"  // Be a little careful. We don't want to either open or close a core unless it's _not_ being opened or closed by\n  // another thread. So within this lock we'll walk along the list of pending closes until we find something NOT in\n  // the list of threads currently being loaded or reloaded. The \"usual\" case will probably return the very first\n  // one anyway..\n  protected SolrCore getCoreToClose() {\n    synchronized (locker) {\n      for (SolrCore core : pendingCloses) {\n        if (! pendingCoreOps.contains(core.getName())) {\n          pendingCoreOps.add(core.getName());\n          pendingCloses.remove(core);\n          return core;\n        }\n      }\n    }\n    return null;\n  }\n\n","sourceOld":"  // Be a little careful. We don't want to either open or close a core unless it's _not_ being opened or closed by\n  // another thread. So within this lock we'll walk along the list of pending closes until we find something NOT in\n  // the list of threads currently being loaded or reloaded. The \"usual\" case will probably return the very first\n  // one anyway..\n  protected SolrCore getCoreToClose() {\n    synchronized (locker) {\n      for (SolrCore core : pendingCloses) {\n        if (! pendingCoreOps.contains(core.getName())) {\n          pendingCoreOps.add(core.getName());\n          pendingCloses.remove(core);\n          return core;\n        }\n      }\n    }\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["a837c064b67fa63a9394136e31218b908cdcf783"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"a837c064b67fa63a9394136e31218b908cdcf783":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"]},"commit2Childs":{"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a837c064b67fa63a9394136e31218b908cdcf783"],"c7c73b6560033b6dcc828fbcc94ba9315c20f3c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a837c064b67fa63a9394136e31218b908cdcf783":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}