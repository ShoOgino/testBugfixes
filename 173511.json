{"path":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","commits":[{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","sourceNew":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto));\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","sourceOld":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto));\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","sourceNew":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","sourceOld":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto));\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","sourceNew":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","sourceOld":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto));\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","sourceNew":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","sourceOld":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto));\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum#seekExact(BytesRef,boolean).mjava","sourceNew":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","sourceOld":"      @Override\n      public boolean seekExact(final BytesRef target, final boolean useCache) throws IOException {\n\n        if (index == null) {\n          throw new IllegalStateException(\"terms index was not loaded\");\n        }\n\n        if (term.bytes.length <= target.length) {\n          term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n        }\n\n        assert clearEOF();\n\n        // if (DEBUG) {\n        //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n        //   printSeekState();\n        // }\n\n        FST.Arc<BytesRef> arc;\n        int targetUpto;\n        BytesRef output;\n\n        targetBeforeCurrentLength = currentFrame.ord;\n\n        if (currentFrame != staticFrame) {\n\n          // We are already seek'd; find the common\n          // prefix of new seek term vs current term and\n          // re-use the corresponding seek state.  For\n          // example, if app first seeks to foobar, then\n          // seeks to foobaz, we can re-use the seek state\n          // for the first 5 bytes.\n\n          // if (DEBUG) {\n          //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n          // }\n\n          arc = arcs[0];\n          assert arc.isFinal();\n          output = arc.output;\n          targetUpto = 0;\n          \n          Frame lastFrame = stack[0];\n          assert validIndexPrefix <= term.length;\n\n          final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n          int cmp = 0;\n\n          // TODO: reverse vLong byte order for better FST\n          // prefix output sharing\n\n          // First compare up to valid seek frames:\n          while (targetUpto < targetLimit) {\n            cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n            // if (DEBUG) {\n            //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n            // }\n            if (cmp != 0) {\n              break;\n            }\n            arc = arcs[1+targetUpto];\n            //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n            //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n            //}\n            assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n            if (arc.isFinal()) {\n              lastFrame = stack[1+lastFrame.ord];\n            }\n            targetUpto++;\n          }\n\n          if (cmp == 0) {\n            final int targetUptoMid = targetUpto;\n\n            // Second compare the rest of the term, but\n            // don't save arc/output/frame; we only do this\n            // to find out if the target term is before,\n            // equal or after the current term\n            final int targetLimit2 = Math.min(target.length, term.length);\n            while (targetUpto < targetLimit2) {\n              cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n              // if (DEBUG) {\n              //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n              // }\n              if (cmp != 0) {\n                break;\n              }\n              targetUpto++;\n            }\n\n            if (cmp == 0) {\n              cmp = term.length - target.length;\n            }\n            targetUpto = targetUptoMid;\n          }\n\n          if (cmp < 0) {\n            // Common case: target term is after current\n            // term, ie, app is seeking multiple terms\n            // in sorted order\n            // if (DEBUG) {\n            //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n\n          } else if (cmp > 0) {\n            // Uncommon case: target term\n            // is before current term; this means we can\n            // keep the currentFrame but we must rewind it\n            // (so we scan from the start)\n            targetBeforeCurrentLength = 0;\n            // if (DEBUG) {\n            //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n            // }\n            currentFrame = lastFrame;\n            currentFrame.rewind();\n          } else {\n            // Target is exactly the same as current term\n            assert term.length == target.length;\n            if (termExists) {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current; return true\");\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  target is same as current but term doesn't exist\");\n              // }\n            }\n            //validIndexPrefix = currentFrame.depth;\n            //term.length = target.length;\n            //return termExists;\n          }\n\n        } else {\n\n          targetBeforeCurrentLength = -1;\n          arc = index.getFirstArc(arcs[0]);\n\n          // Empty string prefix must have an output (block) in the index!\n          assert arc.isFinal();\n          assert arc.output != null;\n\n          // if (DEBUG) {\n          //   System.out.println(\"    no seek state; push root frame\");\n          // }\n\n          output = arc.output;\n\n          currentFrame = staticFrame;\n\n          //term.length = 0;\n          targetUpto = 0;\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n        // }\n\n        while (targetUpto < target.length) {\n\n          final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n          final FST.Arc<BytesRef> nextArc = index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n          if (nextArc == null) {\n\n            // Index is exhausted\n            // if (DEBUG) {\n            //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n            // }\n            \n            validIndexPrefix = currentFrame.prefix;\n            //validIndexPrefix = targetUpto;\n\n            currentFrame.scanToFloorFrame(target);\n\n            if (!currentFrame.hasTerms) {\n              termExists = false;\n              term.bytes[targetUpto] = (byte) targetLabel;\n              term.length = 1+targetUpto;\n              // if (DEBUG) {\n              //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n\n            currentFrame.loadBlock();\n\n            final SeekStatus result = currentFrame.scanToTerm(target, true);            \n            if (result == SeekStatus.FOUND) {\n              // if (DEBUG) {\n              //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n              // }\n              return true;\n            } else {\n              // if (DEBUG) {\n              //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n              // }\n              return false;\n            }\n          } else {\n            // Follow this arc\n            arc = nextArc;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            // Aggregate output as we go:\n            assert arc.output != null;\n            if (arc.output != NO_OUTPUT) {\n              output = fstOutputs.add(output, arc.output);\n            }\n\n            // if (DEBUG) {\n            //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n            // }\n            targetUpto++;\n\n            if (arc.isFinal()) {\n              //if (DEBUG) System.out.println(\"    arc is final!\");\n              currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n              //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n            }\n          }\n        }\n\n        //validIndexPrefix = targetUpto;\n        validIndexPrefix = currentFrame.prefix;\n\n        currentFrame.scanToFloorFrame(target);\n\n        // Target term is entirely contained in the index:\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.length = targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n          // }\n\n          return false;\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["a0ae5e3ed1232483b7b8a014f175a5fe43595982","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["a0ae5e3ed1232483b7b8a014f175a5fe43595982","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["817882884229bace7dc5d1b75f6b0e4aa1e47122","3a119bbc8703c10faa329ec201c654b3a35a1e3e","5b6fdfce35d0adb18836cf8711abe487a934df33"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}