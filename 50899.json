{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","commits":[{"id":"d8d46584d4a299aaed53fdd79f1cd77f222aee1e","date":1331071171,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"hello\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: hello\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::??\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::??\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"hello\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: hello\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::??\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::??\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d05fd66bc3d76b969398420862e19c166453b335","date":1333069691,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"hello\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: hello\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::??\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::??\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07da04837dda68434fe9bba384d3c4faaa21235","date":1339673862,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = cs.getClass().getDeclaredField(\"lastError\");\n      field.setAccessible(true);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"429beac997b503380be63cd29639faebbc60eb47","date":1339738410,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = getCUSSExceptionField(cs);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = cs.getClass().getDeclaredField(\"lastError\");\n      field.setAccessible(true);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1572188101e23640cb33ef14d47ac743b5e930","date":1340165824,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      server.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = getCUSSExceptionField(cs);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      server.deleteByQuery( \"??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = getCUSSExceptionField(cs);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16397684d6a3d78f5cb4155626024eaed408d4d7","date":1418641569,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      server.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = getCUSSExceptionField(cs);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertEquals(\"Invalid Number: ignore_exception\", ex.getMessage());  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      server.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = getCUSSExceptionField(cs);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrClient concurrentClient = (ConcurrentUpdateSolrClient) client;\n      Field field = getConcurrentClientExceptionField(concurrentClient);\n      field.set(concurrentClient, null);\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(concurrentClient);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrServer server = getSolrServer();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      server.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      server.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (server instanceof HttpSolrServer) {\n      try {\n        server.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (server instanceof ConcurrentUpdateSolrServer) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrServer cs = (ConcurrentUpdateSolrServer) server;\n      Field field = getCUSSExceptionField(cs);\n      field.set(cs,  null);\n      cs.add(doc);\n      cs.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(cs);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignorig update test for client:\" + server.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4383b91725e5b335d0a9d5f24b122b813dddd0cc","date":1442106431,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError); \n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ConcurrentUpdateSolrClient concurrentClient = (ConcurrentUpdateSolrClient) client;\n      Field field = getConcurrentClientExceptionField(concurrentClient);\n      field.set(concurrentClient, null);\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      Throwable lastError = (Throwable)field.get(concurrentClient);\n      assertNotNull(\"Should throw exception!\", lastError); //XXX \n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65ff6ef880637c4ec23ec5bed2c6036058f4e42d","date":1481049262,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError); \n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d","date":1481116359,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError); \n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError); \n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\", 1.0f);\n    doc.addField(\"id\", \"DOCID2\", 1.0f);\n    doc.addField(\"name\", \"hello\", 1.0f);\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b91e97078e3f16849905e6185c71bddb6292e8f","date":1501107874,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a server exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(500, ex.code());\n      assertThat(ex.getMessage(), containsString(\" Can't generate internal string in PointField. use PointField.toInternalByteRef\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dbc9fc826d9caf8b3ddad28f3c1c0c5d8b1dd92","date":1501108969,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a server exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(500, ex.code());\n      assertThat(ex.getMessage(), containsString(\" Can't generate internal string in PointField. use PointField.toInternalByteRef\"));\n    } \n    catch (SolrServerException ex) {\n      assertThat(ex.getMessage(), containsString(\" Can't generate internal string in PointField. use PointField.toInternalByteRef\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a server exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(500, ex.code());\n      assertThat(ex.getMessage(), containsString(\" Can't generate internal string in PointField. use PointField.toInternalByteRef\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","date":1501254464,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a server exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(500, ex.code());\n      assertThat(ex.getMessage(), containsString(\" Can't generate internal string in PointField. use PointField.toInternalByteRef\"));\n    } \n    catch (SolrServerException ex) {\n      assertThat(ex.getMessage(), containsString(\" Can't generate internal string in PointField. use PointField.toInternalByteRef\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":["3dbc9fc826d9caf8b3ddad28f3c1c0c5d8b1dd92","1b91e97078e3f16849905e6185c71bddb6292e8f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"int\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1a307447328c95a00248512b40d7a5ff12ecd6a","date":1564817449,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    SolrException ex = expectThrows(SolrException.class, () -> client.query(query));\n    assertEquals(400, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n\n    //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n    // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n    ex = expectThrows(SolrException.class, () -> client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ));\n    assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    assertEquals(400, ex.code());\n\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      ex = expectThrows(SolrException.class, () -> client.add(doc));\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"contains multiple values for uniqueKey\") > 0);\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    SolrException ex = expectThrows(SolrException.class, () -> client.query(query));\n    assertEquals(400, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n\n    //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n    // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n    ex = expectThrows(SolrException.class, () -> client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ));\n    assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    assertEquals(400, ex.code());\n\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      ex = expectThrows(SolrException.class, () -> client.add(doc));\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"contains multiple values for uniqueKey\") > 0);\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan Hydahl","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    SolrException ex = expectThrows(SolrException.class, () -> client.query(query));\n    assertEquals(400, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n\n    //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n    // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n    ex = expectThrows(SolrException.class, () -> client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ));\n    assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    assertEquals(400, ex.code());\n\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      ex = expectThrows(SolrException.class, () -> client.add(doc));\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"contains multiple values for uniqueKey\") > 0);\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    try {\n      client.query( query );\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n    }\n    \n    try {\n      //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n      // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n      client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ); // query syntax error\n      Assert.fail(\"should have a number format exception\");\n    }\n    catch(SolrException ex) {\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    }\n    catch(Throwable t) {\n      t.printStackTrace();\n      Assert.fail(\"should have thrown a SolrException! not: \"+t);\n\n    }\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      try {\n        client.add(doc);\n        fail(\"Should throw exception!\");\n      } catch (SolrException ex) {\n        assertEquals(400, ex.code());\n        assertTrue(ex.getMessage().indexOf(\n            \"contains multiple values for uniqueKey\") > 0); // The reason should get passed through\n      } catch (Throwable t) {\n        Assert.fail(\"should have thrown a SolrException! not: \" + t);\n      }\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testErrorHandling().mjava","sourceNew":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    SolrException ex = expectThrows(SolrException.class, () -> client.query(query));\n    assertEquals(400, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n\n    //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n    // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n    ex = expectThrows(SolrException.class, () -> client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ));\n    assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    assertEquals(400, ex.code());\n\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      ex = expectThrows(SolrException.class, () -> client.add(doc));\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"contains multiple values for uniqueKey\") > 0);\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      if (log.isInfoEnabled()) {\n        log.info(\"Ignoring update test for client: {}\", client.getClass().getName());\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testErrorHandling() throws Exception\n  {    \n    SolrClient client = getSolrClient();\n\n    SolrQuery query = new SolrQuery();\n    query.set(CommonParams.QT, \"/analysis/field\");\n    query.set(AnalysisParams.FIELD_TYPE, \"pint\");\n    query.set(AnalysisParams.FIELD_VALUE, \"ignore_exception\");\n    SolrException ex = expectThrows(SolrException.class, () -> client.query(query));\n    assertEquals(400, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Invalid Number: ignore_exception\"));\n\n    //the df=text here is a kluge for the test to supply a default field in case there is none in schema.xml\n    // alternatively, the resulting assertion could be modified to assert that no default field is specified.\n    ex = expectThrows(SolrException.class, () -> client.deleteByQuery( \"{!df=text} ??::?? ignore_exception\" ));\n    assertTrue(ex.getMessage().indexOf(\"??::?? ignore_exception\")>0);  // The reason should get passed through\n    assertEquals(400, ex.code());\n\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"DOCID\");\n    doc.addField(\"id\", \"DOCID2\");\n    doc.addField(\"name\", \"hello\");\n\n    if (client instanceof HttpSolrClient) {\n      ex = expectThrows(SolrException.class, () -> client.add(doc));\n      assertEquals(400, ex.code());\n      assertTrue(ex.getMessage().indexOf(\"contains multiple values for uniqueKey\") > 0);\n    } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n      //XXX concurrentupdatesolrserver reports errors differently\n      ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n      concurrentClient.lastError = null;\n      concurrentClient.add(doc);\n      concurrentClient.blockUntilFinished();\n      assertNotNull(\"Should throw exception!\", concurrentClient.lastError);\n      assertEquals(\"Unexpected exception type\", \n          RemoteSolrException.class, concurrentClient.lastError.getClass());\n      assertTrue(\"Unexpected exception message: \" + concurrentClient.lastError.getMessage(), \n          concurrentClient.lastError.getMessage().contains(\"Remote error message: Document contains multiple values for uniqueKey\"));\n    } else {\n      log.info(\"Ignoring update test for client:\" + client.getClass().getName());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d8d46584d4a299aaed53fdd79f1cd77f222aee1e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["d1a307447328c95a00248512b40d7a5ff12ecd6a"],"b07da04837dda68434fe9bba384d3c4faaa21235":["d05fd66bc3d76b969398420862e19c166453b335"],"d05fd66bc3d76b969398420862e19c166453b335":["d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d":["4383b91725e5b335d0a9d5f24b122b813dddd0cc","65ff6ef880637c4ec23ec5bed2c6036058f4e42d"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"16397684d6a3d78f5cb4155626024eaed408d4d7":["7b1572188101e23640cb33ef14d47ac743b5e930"],"429beac997b503380be63cd29639faebbc60eb47":["b07da04837dda68434fe9bba384d3c4faaa21235"],"fb1921ba901ad34c1b448d0b8c98a563dfea7dd9":["3dbc9fc826d9caf8b3ddad28f3c1c0c5d8b1dd92"],"bafca15d8e408346a67f4282ad1143b88023893b":["16397684d6a3d78f5cb4155626024eaed408d4d7"],"f8061ddd97f3352007d927dae445884a6f3d857b":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","d1a307447328c95a00248512b40d7a5ff12ecd6a"],"3dbc9fc826d9caf8b3ddad28f3c1c0c5d8b1dd92":["1b91e97078e3f16849905e6185c71bddb6292e8f"],"7b1572188101e23640cb33ef14d47ac743b5e930":["429beac997b503380be63cd29639faebbc60eb47"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["acd9883560fd89e6448b2b447302fe543040cd4f","fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"1b91e97078e3f16849905e6185c71bddb6292e8f":["acd9883560fd89e6448b2b447302fe543040cd4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4383b91725e5b335d0a9d5f24b122b813dddd0cc":["bafca15d8e408346a67f4282ad1143b88023893b"],"9856095f7afb5a607bf5e65077615ed91273508c":["4383b91725e5b335d0a9d5f24b122b813dddd0cc","ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"d1a307447328c95a00248512b40d7a5ff12ecd6a":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"65ff6ef880637c4ec23ec5bed2c6036058f4e42d":["4383b91725e5b335d0a9d5f24b122b813dddd0cc"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","d1a307447328c95a00248512b40d7a5ff12ecd6a"],"acd9883560fd89e6448b2b447302fe543040cd4f":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"]},"commit2Childs":{"d8d46584d4a299aaed53fdd79f1cd77f222aee1e":["d05fd66bc3d76b969398420862e19c166453b335","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b07da04837dda68434fe9bba384d3c4faaa21235":["429beac997b503380be63cd29639faebbc60eb47"],"d05fd66bc3d76b969398420862e19c166453b335":["b07da04837dda68434fe9bba384d3c4faaa21235"],"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d":["9856095f7afb5a607bf5e65077615ed91273508c","acd9883560fd89e6448b2b447302fe543040cd4f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"16397684d6a3d78f5cb4155626024eaed408d4d7":["bafca15d8e408346a67f4282ad1143b88023893b"],"429beac997b503380be63cd29639faebbc60eb47":["7b1572188101e23640cb33ef14d47ac743b5e930"],"fb1921ba901ad34c1b448d0b8c98a563dfea7dd9":["f8061ddd97f3352007d927dae445884a6f3d857b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","d1a307447328c95a00248512b40d7a5ff12ecd6a","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693"],"bafca15d8e408346a67f4282ad1143b88023893b":["4383b91725e5b335d0a9d5f24b122b813dddd0cc"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"7b1572188101e23640cb33ef14d47ac743b5e930":["16397684d6a3d78f5cb4155626024eaed408d4d7"],"3dbc9fc826d9caf8b3ddad28f3c1c0c5d8b1dd92":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d8d46584d4a299aaed53fdd79f1cd77f222aee1e","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"1b91e97078e3f16849905e6185c71bddb6292e8f":["3dbc9fc826d9caf8b3ddad28f3c1c0c5d8b1dd92"],"4383b91725e5b335d0a9d5f24b122b813dddd0cc":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d","9856095f7afb5a607bf5e65077615ed91273508c","65ff6ef880637c4ec23ec5bed2c6036058f4e42d"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"d1a307447328c95a00248512b40d7a5ff12ecd6a":["6dc613ed6f75d1988140301ee8de8fdb056fa337","f8061ddd97f3352007d927dae445884a6f3d857b","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693"],"65ff6ef880637c4ec23ec5bed2c6036058f4e42d":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"acd9883560fd89e6448b2b447302fe543040cd4f":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","1b91e97078e3f16849905e6185c71bddb6292e8f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f8061ddd97f3352007d927dae445884a6f3d857b","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","9856095f7afb5a607bf5e65077615ed91273508c","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}