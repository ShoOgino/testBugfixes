{"path":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","commits":[{"id":"e4583d4aac44f313f9af74ab6d81baab3f976232","date":1352409883,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"/dev/null","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d2b26522f870cd9ff2faccbc2a5e1f9019366c98","287e9d40cdd01ccdb61d409156951f5f39aa6446","27343ef19aef2f3e8a951852c79c4110775e0d98"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"/dev/null","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    @Override\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","sourceOld":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    @Override\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","sourceOld":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"287e9d40cdd01ccdb61d409156951f5f39aa6446","date":1363387551,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    @Override\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      final long startNS;\n      long curNS = startNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return curNS - startNS;\n    }\n\n","sourceOld":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    @Override\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      long curNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return targetNS;\n    }\n\n","bugFix":["e4583d4aac44f313f9af74ab6d81baab3f976232"],"bugIntro":["d2b26522f870cd9ff2faccbc2a5e1f9019366c98"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2b26522f870cd9ff2faccbc2a5e1f9019366c98","date":1399316087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target.  Be sure to only call\n     *  this method when bytes > {@link #getMinPauseCheckBytes},\n     *  otherwise it will pause way too long!\n     *\n     *  @return the pause time in nano seconds */  \n    @Override\n    public long pause(long bytes) {\n\n      long startNS = System.nanoTime();\n\n      double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n      long targetNS;\n\n      // Sync'd to read + write lastNS:\n      synchronized (this) {\n\n        // Time we should sleep until; this is purely instantaneous\n        // rate (just adds seconds onto the last time we had paused to);\n        // maybe we should also offer decayed recent history one?\n        targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n        if (startNS >= targetNS) {\n          // OK, current time is already beyond the target sleep time,\n          // no pausing to do.\n\n          // Set to startNS, not targetNS, to enforce the instant rate, not\n          // the \"averaaged over all history\" rate:\n          lastNS = startNS;\n          return 0;\n        }\n\n        lastNS = targetNS;\n      }\n\n      long curNS = startNS;\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while (true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            // NOTE: except maybe on real-time JVMs, minimum realistic sleep time\n            // is 1 msec; if you pass just 1 nsec the default impl rounds\n            // this up to 1 msec:\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n\n      return curNS - startNS;\n    }\n\n","sourceOld":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target. NOTE: multiple threads\n     *  may safely use this, however the implementation is\n     *  not perfectly thread safe but likely in practice this\n     *  is harmless (just means in some rare cases the rate\n     *  might exceed the target).  It's best to call this\n     *  with a biggish count, not one byte at a time.\n     *  @return the pause time in nano seconds \n     * */\n    @Override\n    public long pause(long bytes) {\n      if (bytes == 1) {\n        return 0;\n      }\n\n      // TODO: this is purely instantaneous rate; maybe we\n      // should also offer decayed recent history one?\n      final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));\n      final long startNS;\n      long curNS = startNS = System.nanoTime();\n      if (lastNS < curNS) {\n        lastNS = curNS;\n      }\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while(true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n      return curNS - startNS;\n    }\n\n","bugFix":["e4583d4aac44f313f9af74ab6d81baab3f976232","287e9d40cdd01ccdb61d409156951f5f39aa6446"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27343ef19aef2f3e8a951852c79c4110775e0d98","date":1416915647,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target.  Be sure to only call\n     *  this method when bytes > {@link #getMinPauseCheckBytes},\n     *  otherwise it will pause way too long!\n     *\n     *  @return the pause time in nano seconds */  \n    @Override\n    public long pause(long bytes) {\n\n      long startNS = System.nanoTime();\n\n      double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n      long targetNS;\n\n      // Sync'd to read + write lastNS:\n      synchronized (this) {\n\n        // Time we should sleep until; this is purely instantaneous\n        // rate (just adds seconds onto the last time we had paused to);\n        // maybe we should also offer decayed recent history one?\n        targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n        if (startNS >= targetNS) {\n          // OK, current time is already beyond the target sleep time,\n          // no pausing to do.\n\n          // Set to startNS, not targetNS, to enforce the instant rate, not\n          // the \"averaaged over all history\" rate:\n          lastNS = startNS;\n          return 0;\n        }\n\n        lastNS = targetNS;\n      }\n\n      long curNS = startNS;\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while (true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            // NOTE: except maybe on real-time JVMs, minimum realistic sleep time\n            // is 1 msec; if you pass just 1 nsec the default impl rounds\n            // this up to 1 msec:\n            int sleepNS;\n            int sleepMS;\n            if (pauseNS > 100000L * Integer.MAX_VALUE) {\n              // Not really practical (sleeping for 25 days) but we shouldn't overflow int:\n              sleepMS = Integer.MAX_VALUE;\n              sleepNS = 0;\n            } else {\n              sleepMS = (int) (pauseNS/1000000);\n              sleepNS = (int) (pauseNS % 1000000);\n            }\n            Thread.sleep(sleepMS, sleepNS);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n\n      return curNS - startNS;\n    }\n\n","sourceOld":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target.  Be sure to only call\n     *  this method when bytes > {@link #getMinPauseCheckBytes},\n     *  otherwise it will pause way too long!\n     *\n     *  @return the pause time in nano seconds */  \n    @Override\n    public long pause(long bytes) {\n\n      long startNS = System.nanoTime();\n\n      double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n      long targetNS;\n\n      // Sync'd to read + write lastNS:\n      synchronized (this) {\n\n        // Time we should sleep until; this is purely instantaneous\n        // rate (just adds seconds onto the last time we had paused to);\n        // maybe we should also offer decayed recent history one?\n        targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n        if (startNS >= targetNS) {\n          // OK, current time is already beyond the target sleep time,\n          // no pausing to do.\n\n          // Set to startNS, not targetNS, to enforce the instant rate, not\n          // the \"averaaged over all history\" rate:\n          lastNS = startNS;\n          return 0;\n        }\n\n        lastNS = targetNS;\n      }\n\n      long curNS = startNS;\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while (true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            // NOTE: except maybe on real-time JVMs, minimum realistic sleep time\n            // is 1 msec; if you pass just 1 nsec the default impl rounds\n            // this up to 1 msec:\n            Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n\n      return curNS - startNS;\n    }\n\n","bugFix":["e4583d4aac44f313f9af74ab6d81baab3f976232"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/RateLimiter.SimpleRateLimiter#pause(long).mjava","sourceNew":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target.  Be sure to only call\n     *  this method when bytes &gt; {@link #getMinPauseCheckBytes},\n     *  otherwise it will pause way too long!\n     *\n     *  @return the pause time in nano seconds */  \n    @Override\n    public long pause(long bytes) {\n\n      long startNS = System.nanoTime();\n\n      double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n      long targetNS;\n\n      // Sync'd to read + write lastNS:\n      synchronized (this) {\n\n        // Time we should sleep until; this is purely instantaneous\n        // rate (just adds seconds onto the last time we had paused to);\n        // maybe we should also offer decayed recent history one?\n        targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n        if (startNS >= targetNS) {\n          // OK, current time is already beyond the target sleep time,\n          // no pausing to do.\n\n          // Set to startNS, not targetNS, to enforce the instant rate, not\n          // the \"averaaged over all history\" rate:\n          lastNS = startNS;\n          return 0;\n        }\n\n        lastNS = targetNS;\n      }\n\n      long curNS = startNS;\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while (true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            // NOTE: except maybe on real-time JVMs, minimum realistic sleep time\n            // is 1 msec; if you pass just 1 nsec the default impl rounds\n            // this up to 1 msec:\n            int sleepNS;\n            int sleepMS;\n            if (pauseNS > 100000L * Integer.MAX_VALUE) {\n              // Not really practical (sleeping for 25 days) but we shouldn't overflow int:\n              sleepMS = Integer.MAX_VALUE;\n              sleepNS = 0;\n            } else {\n              sleepMS = (int) (pauseNS/1000000);\n              sleepNS = (int) (pauseNS % 1000000);\n            }\n            Thread.sleep(sleepMS, sleepNS);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n\n      return curNS - startNS;\n    }\n\n","sourceOld":"    /** Pauses, if necessary, to keep the instantaneous IO\n     *  rate at or below the target.  Be sure to only call\n     *  this method when bytes > {@link #getMinPauseCheckBytes},\n     *  otherwise it will pause way too long!\n     *\n     *  @return the pause time in nano seconds */  \n    @Override\n    public long pause(long bytes) {\n\n      long startNS = System.nanoTime();\n\n      double secondsToPause = (bytes/1024./1024.) / mbPerSec;\n\n      long targetNS;\n\n      // Sync'd to read + write lastNS:\n      synchronized (this) {\n\n        // Time we should sleep until; this is purely instantaneous\n        // rate (just adds seconds onto the last time we had paused to);\n        // maybe we should also offer decayed recent history one?\n        targetNS = lastNS + (long) (1000000000 * secondsToPause);\n\n        if (startNS >= targetNS) {\n          // OK, current time is already beyond the target sleep time,\n          // no pausing to do.\n\n          // Set to startNS, not targetNS, to enforce the instant rate, not\n          // the \"averaaged over all history\" rate:\n          lastNS = startNS;\n          return 0;\n        }\n\n        lastNS = targetNS;\n      }\n\n      long curNS = startNS;\n\n      // While loop because Thread.sleep doesn't always sleep\n      // enough:\n      while (true) {\n        final long pauseNS = targetNS - curNS;\n        if (pauseNS > 0) {\n          try {\n            // NOTE: except maybe on real-time JVMs, minimum realistic sleep time\n            // is 1 msec; if you pass just 1 nsec the default impl rounds\n            // this up to 1 msec:\n            int sleepNS;\n            int sleepMS;\n            if (pauseNS > 100000L * Integer.MAX_VALUE) {\n              // Not really practical (sleeping for 25 days) but we shouldn't overflow int:\n              sleepMS = Integer.MAX_VALUE;\n              sleepNS = 0;\n            } else {\n              sleepMS = (int) (pauseNS/1000000);\n              sleepNS = (int) (pauseNS % 1000000);\n            }\n            Thread.sleep(sleepMS, sleepNS);\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n          curNS = System.nanoTime();\n          continue;\n        }\n        break;\n      }\n\n      return curNS - startNS;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["27343ef19aef2f3e8a951852c79c4110775e0d98"],"d2b26522f870cd9ff2faccbc2a5e1f9019366c98":["287e9d40cdd01ccdb61d409156951f5f39aa6446"],"e4583d4aac44f313f9af74ab6d81baab3f976232":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"287e9d40cdd01ccdb61d409156951f5f39aa6446":["7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e4583d4aac44f313f9af74ab6d81baab3f976232"],"7530de27b87b961b51f01bd1299b7004d46e8823":["e4583d4aac44f313f9af74ab6d81baab3f976232"],"27343ef19aef2f3e8a951852c79c4110775e0d98":["d2b26522f870cd9ff2faccbc2a5e1f9019366c98"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d2b26522f870cd9ff2faccbc2a5e1f9019366c98":["27343ef19aef2f3e8a951852c79c4110775e0d98"],"e4583d4aac44f313f9af74ab6d81baab3f976232":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"287e9d40cdd01ccdb61d409156951f5f39aa6446":["d2b26522f870cd9ff2faccbc2a5e1f9019366c98"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e4583d4aac44f313f9af74ab6d81baab3f976232","407687e67faf6e1f02a211ca078d8e3eed631027"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","287e9d40cdd01ccdb61d409156951f5f39aa6446"],"27343ef19aef2f3e8a951852c79c4110775e0d98":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}