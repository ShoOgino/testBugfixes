{"path":"lucene/codecs/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialUncompress().mjava","commits":[{"id":"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa","date":1349450075,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialUncompress().mjava","pathOld":"/dev/null","sourceNew":"  public void testPartialUncompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] uncompressed = randomArray();\n      final byte[] compressed = compress(uncompressed);\n      final int offset, length;\n      if (uncompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(uncompressed.length);\n        length = random().nextInt(uncompressed.length - offset);\n      }\n      final byte[] restored = uncompress(compressed, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(uncompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1","date":1351696336,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialUncompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialUncompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] uncompressed = randomArray();\n      final byte[] compressed = compress(uncompressed);\n      final int offset, length;\n      if (uncompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(uncompressed.length);\n        length = random().nextInt(uncompressed.length - offset);\n      }\n      final byte[] restored = uncompress(compressed, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(uncompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":null,"bugIntro":["175e4d353e3036fad2ad89ae6815c4418b4c3c8e"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"]},"commit2Childs":{"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}