{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/FieldReader.SegmentTermsEnum.Frame#scanToTermNonLeaf(BytesRef,boolean).mjava","commits":[{"id":"d289450fa5030c34b5e378c04bcb03a026aad9f4","date":1400178141,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/FieldReader.SegmentTermsEnum.Frame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"      // Target's prefix matches this block's prefix; we\n      // scan the entries check if the suffix matches.\n      public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n        //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n        assert nextEnt != -1;\n\n        if (nextEnt == entCount) {\n          if (exactOnly) {\n            fillTerm();\n            termExists = subCode == 0;\n          }\n          return SeekStatus.END;\n        }\n\n        assert prefixMatches(target);\n\n        // Loop over each entry (term or sub-block) in this block:\n        //nextTerm: while(nextEnt < entCount) {\n        nextTerm: while (true) {\n          nextEnt++;\n\n          final int code = suffixesReader.readVInt();\n          suffix = code >>> 1;\n          // if (DEBUG) {\n          //   BytesRef suffixBytesRef = new BytesRef();\n          //   suffixBytesRef.bytes = suffixBytes;\n          //   suffixBytesRef.offset = suffixesReader.getPosition();\n          //   suffixBytesRef.length = suffix;\n          //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n          // }\n\n          termExists = (code & 1) == 0;\n          final int termLen = prefix + suffix;\n          startBytePos = suffixesReader.getPosition();\n          suffixesReader.skipBytes(suffix);\n          if (termExists) {\n            state.termBlockOrd++;\n            subCode = 0;\n          } else {\n            subCode = suffixesReader.readVLong();\n            lastSubFP = fp - subCode;\n          }\n\n          final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n          int targetPos = target.offset + prefix;\n\n          // Loop over bytes in the suffix, comparing to\n          // the target\n          int bytePos = startBytePos;\n          while(true) {\n            final int cmp;\n            final boolean stop;\n            if (targetPos < targetLimit) {\n              cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n              stop = false;\n            } else {\n              assert targetPos == targetLimit;\n              cmp = termLen - target.length;\n              stop = true;\n            }\n\n            if (cmp < 0) {\n              // Current entry is still before the target;\n              // keep scanning\n\n              if (nextEnt == entCount) {\n                if (exactOnly) {\n                  fillTerm();\n                  //termExists = true;\n                }\n                // We are done scanning this block\n                break nextTerm;\n              } else {\n                continue nextTerm;\n              }\n            } else if (cmp > 0) {\n\n              // Done!  Current entry is after target --\n              // return NOT_FOUND:\n              fillTerm();\n\n              if (!exactOnly && !termExists) {\n                // We are on a sub-block, and caller wants\n                // us to position to the next term after\n                // the target, so we must recurse into the\n                // sub-frame(s):\n                currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                currentFrame.loadBlock();\n                while (currentFrame.next()) {\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                  currentFrame.loadBlock();\n                }\n              }\n                \n              //if (DEBUG) System.out.println(\"        not found\");\n              return SeekStatus.NOT_FOUND;\n            } else if (stop) {\n              // Exact match!\n\n              // This cannot be a sub-block because we\n              // would have followed the index to this\n              // sub-block from the start:\n\n              assert termExists;\n              fillTerm();\n              //if (DEBUG) System.out.println(\"        found!\");\n              return SeekStatus.FOUND;\n            }\n          }\n        }\n\n        // It is possible (and OK) that terms index pointed us\n        // at this block, but, we scanned the entire block and\n        // did not find the term to position to.  This happens\n        // when the target is after the last term in the block\n        // (but, before the next term in the index).  EG\n        // target could be foozzz, and terms index pointed us\n        // to the foo* block, but the last term in this block\n        // was fooz (and, eg, first term in the next block will\n        // bee fop).\n        //if (DEBUG) System.out.println(\"      block end\");\n        if (exactOnly) {\n          fillTerm();\n        }\n\n        // TODO: not consistent that in the\n        // not-exact case we don't next() into the next\n        // frame here\n        return SeekStatus.END;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e50f0da93c6dcee20d8792637b1786e2c34975e9","date":1400182475,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/FieldReader.SegmentTermsEnum.Frame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":null,"sourceOld":"      // Target's prefix matches this block's prefix; we\n      // scan the entries check if the suffix matches.\n      public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n        //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n        assert nextEnt != -1;\n\n        if (nextEnt == entCount) {\n          if (exactOnly) {\n            fillTerm();\n            termExists = subCode == 0;\n          }\n          return SeekStatus.END;\n        }\n\n        assert prefixMatches(target);\n\n        // Loop over each entry (term or sub-block) in this block:\n        //nextTerm: while(nextEnt < entCount) {\n        nextTerm: while (true) {\n          nextEnt++;\n\n          final int code = suffixesReader.readVInt();\n          suffix = code >>> 1;\n          // if (DEBUG) {\n          //   BytesRef suffixBytesRef = new BytesRef();\n          //   suffixBytesRef.bytes = suffixBytes;\n          //   suffixBytesRef.offset = suffixesReader.getPosition();\n          //   suffixBytesRef.length = suffix;\n          //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n          // }\n\n          termExists = (code & 1) == 0;\n          final int termLen = prefix + suffix;\n          startBytePos = suffixesReader.getPosition();\n          suffixesReader.skipBytes(suffix);\n          if (termExists) {\n            state.termBlockOrd++;\n            subCode = 0;\n          } else {\n            subCode = suffixesReader.readVLong();\n            lastSubFP = fp - subCode;\n          }\n\n          final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n          int targetPos = target.offset + prefix;\n\n          // Loop over bytes in the suffix, comparing to\n          // the target\n          int bytePos = startBytePos;\n          while(true) {\n            final int cmp;\n            final boolean stop;\n            if (targetPos < targetLimit) {\n              cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n              stop = false;\n            } else {\n              assert targetPos == targetLimit;\n              cmp = termLen - target.length;\n              stop = true;\n            }\n\n            if (cmp < 0) {\n              // Current entry is still before the target;\n              // keep scanning\n\n              if (nextEnt == entCount) {\n                if (exactOnly) {\n                  fillTerm();\n                  //termExists = true;\n                }\n                // We are done scanning this block\n                break nextTerm;\n              } else {\n                continue nextTerm;\n              }\n            } else if (cmp > 0) {\n\n              // Done!  Current entry is after target --\n              // return NOT_FOUND:\n              fillTerm();\n\n              if (!exactOnly && !termExists) {\n                // We are on a sub-block, and caller wants\n                // us to position to the next term after\n                // the target, so we must recurse into the\n                // sub-frame(s):\n                currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                currentFrame.loadBlock();\n                while (currentFrame.next()) {\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                  currentFrame.loadBlock();\n                }\n              }\n                \n              //if (DEBUG) System.out.println(\"        not found\");\n              return SeekStatus.NOT_FOUND;\n            } else if (stop) {\n              // Exact match!\n\n              // This cannot be a sub-block because we\n              // would have followed the index to this\n              // sub-block from the start:\n\n              assert termExists;\n              fillTerm();\n              //if (DEBUG) System.out.println(\"        found!\");\n              return SeekStatus.FOUND;\n            }\n          }\n        }\n\n        // It is possible (and OK) that terms index pointed us\n        // at this block, but, we scanned the entire block and\n        // did not find the term to position to.  This happens\n        // when the target is after the last term in the block\n        // (but, before the next term in the index).  EG\n        // target could be foozzz, and terms index pointed us\n        // to the foo* block, but the last term in this block\n        // was fooz (and, eg, first term in the next block will\n        // bee fop).\n        //if (DEBUG) System.out.println(\"      block end\");\n        if (exactOnly) {\n          fillTerm();\n        }\n\n        // TODO: not consistent that in the\n        // not-exact case we don't next() into the next\n        // frame here\n        return SeekStatus.END;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e50f0da93c6dcee20d8792637b1786e2c34975e9":["d289450fa5030c34b5e378c04bcb03a026aad9f4"],"d289450fa5030c34b5e378c04bcb03a026aad9f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e50f0da93c6dcee20d8792637b1786e2c34975e9":[],"d289450fa5030c34b5e378c04bcb03a026aad9f4":["e50f0da93c6dcee20d8792637b1786e2c34975e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d289450fa5030c34b5e378c04bcb03a026aad9f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e50f0da93c6dcee20d8792637b1786e2c34975e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}