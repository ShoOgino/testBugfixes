{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkQueries().mjava","commits":[{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkQueries().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#checkQueries().mjava","sourceNew":"  protected void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n    \n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n    \n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n    \n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n    \n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n    \n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n    \n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n    \n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n    \n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n    \n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n    \n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < shardCount; i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","sourceOld":"  private void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n    \n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n    \n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n    \n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n    \n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n    \n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n    \n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n    \n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n    \n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n    \n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n    \n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < shardCount; i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkQueries().mjava","pathOld":"/dev/null","sourceNew":"  protected void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n    \n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n    \n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n    \n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n    \n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n    \n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n    \n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n    \n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n    \n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n    \n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n    \n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < shardCount; i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkQueries().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest#checkQueries().mjava","sourceNew":"  protected void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n    \n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n    \n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n    \n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n    \n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n    \n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n    \n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n    \n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n    \n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n    \n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n    \n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < shardCount; i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","sourceOld":"  private void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n    \n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n    \n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n    \n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n    \n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n    \n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n    \n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n    \n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n    \n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n    \n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n    \n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < shardCount; i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkQueries().mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#checkQueries().mjava","sourceNew":"  protected void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n\n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n\n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n\n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n\n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < getShardCount(); i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","sourceOld":"  protected void checkQueries() throws Exception {\n\n    handle.put(\"_version_\", SKIPVAL);\n\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n\n    handle.put(\"response\", UNORDERED);  // get?ids=a,b,c requests are unordered\n    String ids = \"987654\";\n    for (int i=0; i<20; i++) {\n      query(\"qt\",\"/get\", \"id\",Integer.toString(i));\n      query(\"qt\",\"/get\", \"ids\",Integer.toString(i));\n      ids = ids + ',' + Integer.toString(i);\n      query(\"qt\",\"/get\", \"ids\",ids);\n    }\n    handle.remove(\"response\");\n\n\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\", \"*:*\", \"sort\", f + \" desc\");\n      query(\"q\", \"*:*\", \"sort\", f + \" asc\");\n    }\n    \n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" asc\");\n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"fl\", \"*,score\");\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 asc\", \"fl\", \"score\"); // test legacy\n                                                           // behavior -\n                                                           // \"score\"==\"*,score\"\n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"{!func}\" + i1);// does not expect maxScore. So if it comes\n                               // ,ignore it.\n                               // JavaBinCodec.writeSolrDocumentList()\n    // is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\", \"{!func}\" + i1, \"fl\", \"*,score\"); // even scores should match\n                                                 // exactly here\n    \n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n    \n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\", \"quick\");\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"0\");\n    query(\"q\", \"all\", \"fl\", \"foofoofoo\", \"start\", \"0\"); // no fields in returned\n                                                        // docs\n    query(\"q\", \"all\", \"fl\", \"id\", \"start\", \"100\");\n    \n    handle.put(\"score\", SKIPVAL);\n    query(\"q\", \"quick\", \"fl\", \"*,score\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"1\");\n    query(\"q\", \"all\", \"fl\", \"*,score\", \"start\", \"100\");\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"*,score\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"now their fox sat had put\", \"fl\", \"foofoofoo\", \"hl\", \"true\",\n        \"hl.fl\", t1);\n    \n    query(\"q\", \"matchesnothing\", \"fl\", \"*,score\");\n    \n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"count\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", -1, \"facet.sort\", \"index\", \"facet.mincount\", 2);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\");\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.offset\", 1);\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.mincount\", 2);\n    \n    // test faceting multiple things at once\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\", \"quick\",\n        \"facet.query\", \"all\", \"facet.query\", \"*:*\", \"facet.field\", t1);\n    \n    // test filter tagging, facet exclusion, and naming (multi-select facet\n    // support)\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.query\",\n        \"{!key=myquick}quick\", \"facet.query\", \"{!key=myall ex=a}all\",\n        \"facet.query\", \"*:*\", \"facet.field\", \"{!key=mykey ex=a}\" + t1,\n        \"facet.field\", \"{!key=other ex=b}\" + t1, \"facet.field\",\n        \"{!key=again ex=a,b}\" + t1, \"facet.field\", t1, \"fq\",\n        \"{!tag=a}id:[1 TO 7]\", \"fq\", \"{!tag=b}id:[3 TO 9]\");\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\",\n        \"{!ex=t1}SubjectTerms_mfacet\", \"fq\",\n        \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\",\n        \"facet.mincount\", \"1\");\n    \n    // test field that is valid in schema but missing in all shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\",\n        missingField, \"facet.mincount\", 2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\", \"*:*\", \"rows\", 100, \"facet\", \"true\", \"facet.field\", oddField,\n        \"facet.mincount\", 2);\n    \n    query(\"q\", \"*:*\", \"sort\", i1 + \" desc\", \"stats\", \"true\", \"stats.field\", i1);\n    \n    // Try to get better coverage for refinement queries by turning off over\n    // requesting.\n    // This makes it much more likely that we may not get the top facet values\n    // and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\", t1,\n        \"facet.limit\", 5, \"facet.shard.limit\", 5);\n    // check a complex key name\n    query(\"q\", \"*:*\", \"rows\", 0, \"facet\", \"true\", \"facet.field\",\n        \"{!key='a b/c \\\\' \\\\} foo'}\" + t1, \"facet.limit\", 5,\n        \"facet.shard.limit\", 5);\n    handle.remove(\"facet_fields\");\n    \n    query(\"q\", \"*:*\", \"sort\", \"n_tl1 desc\");\n    \n    // index the same document to two shards and make sure things\n    // don't blow up.\n    // assumes first n clients are first n shards\n    if (clients.size() >= 2) {\n      index(id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      for (int i = 0; i < shardCount; i++) {\n        index_specific(i, id, 100, i1, 107, t1, \"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\", \"duplicate\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"fox duplicate horses\", \"hl\", \"true\", \"hl.fl\", t1);\n      query(\"q\", \"*:*\", \"rows\", 100);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"abb23fcc2461782ab204e61213240feb77d355aa":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","2c30e4c1cee08b3b229a77991882594fe7250b66"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c30e4c1cee08b3b229a77991882594fe7250b66":["c7869f64c874ebf7f317d22c00baf2b6857797a6","abb23fcc2461782ab204e61213240feb77d355aa","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}