{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","commits":[{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>());\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad0d09e969f4763b0df4230f8e3f74357872a4e4","date":1459188769,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2464b43ee422a496b9232278eb1ab77ea36ba0c3","date":1508151941,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b213cb4b7b825687d73e7ec995c615eb0cf68305","date":1510236177,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b213cb4b7b825687d73e7ec995c615eb0cf68305":["2464b43ee422a496b9232278eb1ab77ea36ba0c3"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"2464b43ee422a496b9232278eb1ab77ea36ba0c3":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b213cb4b7b825687d73e7ec995c615eb0cf68305"]},"commit2Childs":{"b213cb4b7b825687d73e7ec995c615eb0cf68305":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["2464b43ee422a496b9232278eb1ab77ea36ba0c3"],"2464b43ee422a496b9232278eb1ab77ea36ba0c3":["b213cb4b7b825687d73e7ec995c615eb0cf68305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}