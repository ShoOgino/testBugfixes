{"path":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","commits":[{"id":"57bd4ed318156eaf70332a237f41e659603ce5fb","date":1379261612,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["437e65c578cab603d9201916b0e285f3d68aff45","4637747f71df783fc2014ef1f1e0418466e3bed6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51a9d4b7a551de3290b4c5dd2c60db4993160e57","date":1379263137,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f2e96099703c24c0c63d27806ba7020626b649b","date":1385214372,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d285ea522f4ccece252e83366423b739a17e17df","date":1394126445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4637747f71df783fc2014ef1f1e0418466e3bed6","date":1394196311,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["57bd4ed318156eaf70332a237f41e659603ce5fb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19","date":1400739326,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6549d5ea6b7b25525309b981de3ec92b4dff99d1","date":1408666035,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath)), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec083aa3f3ecd55f91c47009d49e45553f99bd77","date":1416002645,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3","date":1417215914,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                         FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b459e8a3dade13ab7cb9100d764358ea5412965e","date":1423160641,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"437e65c578cab603d9201916b0e285f3d68aff45","date":1427831677,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["57bd4ed318156eaf70332a237f41e659603ce5fb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de1635ba58109b4c7c7da50f4dad433333258904","date":1444503719,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT; \n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(@SuppressWarnings({\"rawtypes\"})NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    try {\n      return new AnalyzingInfixSuggester(FSDirectory.open(new File(indexPath).toPath()), indexAnalyzer,\n                                         queryAnalyzer, minPrefixChars, true, \n                                         allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n        };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":["7f2e96099703c24c0c63d27806ba7020626b649b","4637747f71df783fc2014ef1f1e0418466e3bed6"],"d285ea522f4ccece252e83366423b739a17e17df":["7f2e96099703c24c0c63d27806ba7020626b649b"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"437e65c578cab603d9201916b0e285f3d68aff45":["b459e8a3dade13ab7cb9100d764358ea5412965e"],"b7605579001505896d48b07160075a5c8b8e128e":["123698fbe83b595f9e084f0019cd35ab4a01d7f7","4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"f4abec28b874149a7223e32cc7a01704c27790de":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"de1635ba58109b4c7c7da50f4dad433333258904":["437e65c578cab603d9201916b0e285f3d68aff45"],"51a9d4b7a551de3290b4c5dd2c60db4993160e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","57bd4ed318156eaf70332a237f41e659603ce5fb"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"7f2e96099703c24c0c63d27806ba7020626b649b":["57bd4ed318156eaf70332a237f41e659603ce5fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ec083aa3f3ecd55f91c47009d49e45553f99bd77":["f4abec28b874149a7223e32cc7a01704c27790de"],"57bd4ed318156eaf70332a237f41e659603ce5fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["57bd4ed318156eaf70332a237f41e659603ce5fb","7f2e96099703c24c0c63d27806ba7020626b649b"],"b459e8a3dade13ab7cb9100d764358ea5412965e":["6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["7f2e96099703c24c0c63d27806ba7020626b649b","d285ea522f4ccece252e83366423b739a17e17df"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["de1635ba58109b4c7c7da50f4dad433333258904"],"fab172655716b96f7e42376116235017a922de3a":["b459e8a3dade13ab7cb9100d764358ea5412965e","437e65c578cab603d9201916b0e285f3d68aff45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"d285ea522f4ccece252e83366423b739a17e17df":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["f4abec28b874149a7223e32cc7a01704c27790de"],"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3":["b459e8a3dade13ab7cb9100d764358ea5412965e"],"437e65c578cab603d9201916b0e285f3d68aff45":["de1635ba58109b4c7c7da50f4dad433333258904","fab172655716b96f7e42376116235017a922de3a"],"b7605579001505896d48b07160075a5c8b8e128e":[],"f4abec28b874149a7223e32cc7a01704c27790de":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19":["6549d5ea6b7b25525309b981de3ec92b4dff99d1","b7605579001505896d48b07160075a5c8b8e128e"],"de1635ba58109b4c7c7da50f4dad433333258904":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"51a9d4b7a551de3290b4c5dd2c60db4993160e57":[],"7f2e96099703c24c0c63d27806ba7020626b649b":["96ea64d994d340044e0d57aeb6a5871539d10ca5","d285ea522f4ccece252e83366423b739a17e17df","74f45af4339b0daf7a95c820ab88c1aea74fbce0","4637747f71df783fc2014ef1f1e0418466e3bed6"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["b7605579001505896d48b07160075a5c8b8e128e","4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["51a9d4b7a551de3290b4c5dd2c60db4993160e57","57bd4ed318156eaf70332a237f41e659603ce5fb"],"ec083aa3f3ecd55f91c47009d49e45553f99bd77":["6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3"],"57bd4ed318156eaf70332a237f41e659603ce5fb":["51a9d4b7a551de3290b4c5dd2c60db4993160e57","7f2e96099703c24c0c63d27806ba7020626b649b","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"4637747f71df783fc2014ef1f1e0418466e3bed6":["96ea64d994d340044e0d57aeb6a5871539d10ca5","123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"b459e8a3dade13ab7cb9100d764358ea5412965e":["437e65c578cab603d9201916b0e285f3d68aff45","fab172655716b96f7e42376116235017a922de3a"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fab172655716b96f7e42376116235017a922de3a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","b7605579001505896d48b07160075a5c8b8e128e","51a9d4b7a551de3290b4c5dd2c60db4993160e57","74f45af4339b0daf7a95c820ab88c1aea74fbce0","fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}