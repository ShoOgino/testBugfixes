{"path":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","commits":[{"id":"3ca983bc42b1777a3becdc3d28a4a33339475613","date":1341662662,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","pathOld":"/dev/null","sourceNew":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ENGLISH).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279c7cd47f17e1e8b674a3741ff5f040bc680be","date":1341675760,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","sourceNew":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","sourceOld":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ENGLISH).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","pathOld":"/dev/null","sourceNew":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","pathOld":"/dev/null","sourceNew":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c4d0ac761aadb2f09981941103107c940d08bb4","date":1341917223,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","sourceNew":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n            \n            private boolean checkClassUse(String owner) {\n              final String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n                return true;\n              }\n              return false;\n            }\n            \n            private void reportSourceAndLine() {\n              final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n              if (source != null && lineNo >= 0) {\n                new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n              }\n              log(sb.toString(), Project.MSG_ERR);\n            }\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = checkClassUse(owner);\n              if (!found) {\n                final String printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                reportSourceAndLine();\n              }\n            }\n            \n            @Override\n            public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n              boolean found = checkClassUse(owner);\n              if (!found) {\n                final String printout = forbiddenFields.get(owner + '\\000' + name);\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden field access: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n               violations[0]++;\n               reportSourceAndLine();\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","sourceOld":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7f73df94cfb3e05fba3b55eaa6677855a369c35","date":1341945151,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","sourceNew":null,"sourceOld":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n            \n            private boolean checkClassUse(String owner) {\n              final String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n                return true;\n              }\n              return false;\n            }\n            \n            private void reportSourceAndLine() {\n              final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n              if (source != null && lineNo >= 0) {\n                new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n              }\n              log(sb.toString(), Project.MSG_ERR);\n            }\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = checkClassUse(owner);\n              if (!found) {\n                final String printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                reportSourceAndLine();\n              }\n            }\n            \n            @Override\n            public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n              boolean found = checkClassUse(owner);\n              if (!found) {\n                final String printout = forbiddenFields.get(owner + '\\000' + name);\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden field access: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n               violations[0]++;\n               reportSourceAndLine();\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#checkClass(Resource).mjava","sourceNew":null,"sourceOld":"  /** Parses a class given as Resource and checks for valid method invocations */\n  private int checkClass(final Resource res) throws IOException {\n    final InputStream stream = res.getInputStream();\n    try {\n      final int[] violations = new int[1];\n      new ClassReader(stream).accept(new ClassVisitor(Opcodes.ASM4) {\n        String className = null, source = null;\n        \n        @Override\n        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n          // save class name in source code format:\n          this.className = Type.getObjectType(name).getClassName();\n        }\n        \n        @Override\n        public void visitSource(String source, String debug) {\n          this.source = source;\n        }\n        \n        @Override\n        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n          return new MethodVisitor(Opcodes.ASM4) {\n            private int lineNo = -1;\n\n            @Override\n            public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n              boolean found = false;\n              String printout = forbiddenClasses.get(owner);\n              if (printout != null) {\n                found = true;\n                log(\"Forbidden class use: \" + printout, Project.MSG_ERR);\n              } else {\n                printout = forbiddenMethods.get(owner + '\\000' + new Method(name, desc));\n                if (printout != null) {\n                  found = true;\n                  log(\"Forbidden method invocation: \" + printout, Project.MSG_ERR);\n                }\n              }\n              if (found) {\n                violations[0]++;\n                final StringBuilder sb = new StringBuilder(\"  in \").append(className);\n                if (source != null && lineNo >= 0) {\n                  new Formatter(sb, Locale.ROOT).format(\" (%s:%d)\", source, lineNo).flush();\n                }\n                log(sb.toString(), Project.MSG_ERR);\n              }\n            }\n\n            @Override\n            public void visitLineNumber(int lineNo, Label start) {\n              this.lineNo = lineNo;\n            }\n          };\n        }\n      }, ClassReader.SKIP_FRAMES);\n      return violations[0];\n    } finally {\n      stream.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["46d8ada1fff8d18cb197c38c7983225162599948","c7f73df94cfb3e05fba3b55eaa6677855a369c35"],"c7f73df94cfb3e05fba3b55eaa6677855a369c35":["7c4d0ac761aadb2f09981941103107c940d08bb4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["3ca983bc42b1777a3becdc3d28a4a33339475613"],"2acf500f78aa12b92e371fd89c719291986b6b90":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9279c7cd47f17e1e8b674a3741ff5f040bc680be"],"3ca983bc42b1777a3becdc3d28a4a33339475613":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7f73df94cfb3e05fba3b55eaa6677855a369c35"],"7c4d0ac761aadb2f09981941103107c940d08bb4":["2acf500f78aa12b92e371fd89c719291986b6b90"],"46d8ada1fff8d18cb197c38c7983225162599948":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2acf500f78aa12b92e371fd89c719291986b6b90"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":[],"c7f73df94cfb3e05fba3b55eaa6677855a369c35":["aba371508186796cc6151d8223a5b4e16d02e26e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2acf500f78aa12b92e371fd89c719291986b6b90","3ca983bc42b1777a3becdc3d28a4a33339475613","46d8ada1fff8d18cb197c38c7983225162599948"],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["2acf500f78aa12b92e371fd89c719291986b6b90"],"2acf500f78aa12b92e371fd89c719291986b6b90":["7c4d0ac761aadb2f09981941103107c940d08bb4","46d8ada1fff8d18cb197c38c7983225162599948"],"3ca983bc42b1777a3becdc3d28a4a33339475613":["9279c7cd47f17e1e8b674a3741ff5f040bc680be"],"46d8ada1fff8d18cb197c38c7983225162599948":["aba371508186796cc6151d8223a5b4e16d02e26e"],"7c4d0ac761aadb2f09981941103107c940d08bb4":["c7f73df94cfb3e05fba3b55eaa6677855a369c35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}