{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#abortMergeOnX(boolean).mjava","commits":[{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#abortMergeOnX(boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testAbortCommitMerge().mjava","sourceNew":"  void abortMergeOnX(boolean useGetReader) throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      CountDownLatch waitForMerge = new CountDownLatch(1);\n      CountDownLatch waitForDeleteAll = new CountDownLatch(1);\n      try (IndexWriter writer = new IndexWriter(directory, newIndexWriterConfig()\n          .setMergePolicy(new MergeOnXMergePolicy(newMergePolicy(), useGetReader ? MergeTrigger.GET_READER : MergeTrigger.COMMIT))\n          .setMaxFullFlushMergeWaitMillis(30 * 1000)\n          .setMergeScheduler(new SerialMergeScheduler() {\n            @Override\n            public synchronized void merge(MergeSource mergeSource, MergeTrigger trigger) throws IOException {\n              waitForMerge.countDown();\n              try {\n                waitForDeleteAll.await();\n              } catch (InterruptedException e) {\n                throw new AssertionError(e);\n              }\n              super.merge(mergeSource, trigger);\n            }\n          }))) {\n\n        Document d1 = new Document();\n        d1.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        Document d2 = new Document();\n        d2.add(new StringField(\"id\", \"2\", Field.Store.NO));\n        Document d3 = new Document();\n        d3.add(new StringField(\"id\", \"3\", Field.Store.NO));\n        writer.addDocument(d1);\n        writer.flush();\n        writer.addDocument(d2);\n        Thread t = new Thread(() -> {\n          boolean success = false;\n          try {\n            if (useGetReader) {\n              writer.getReader().close();\n            } else {\n              writer.commit();\n            }\n            success = true;\n          } catch (IOException e) {\n            throw new AssertionError(e);\n          } finally {\n            if (success == false) {\n              waitForMerge.countDown();\n            }\n          }\n        });\n        t.start();\n        waitForMerge.await();\n        writer.deleteAll();\n        waitForDeleteAll.countDown();\n        t.join();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This test makes sure we release the merge readers on abort. MDW will fail if it\n   * can't close all files\n   */\n  public void testAbortCommitMerge() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      CountDownLatch waitForMerge = new CountDownLatch(1);\n      CountDownLatch waitForDeleteAll = new CountDownLatch(1);\n      try (IndexWriter writer = new IndexWriter(directory, newIndexWriterConfig()\n          .setMergePolicy(MERGE_ON_COMMIT_POLICY).setMaxCommitMergeWaitMillis(30 * 1000)\n          .setMergeScheduler(new SerialMergeScheduler() {\n            @Override\n            public synchronized void merge(MergeSource mergeSource, MergeTrigger trigger) throws IOException {\n              waitForMerge.countDown();\n              try {\n                waitForDeleteAll.await();\n              } catch (InterruptedException e) {\n                throw new AssertionError(e);\n              }\n              super.merge(mergeSource, trigger);\n            }\n          }))) {\n\n        Document d1 = new Document();\n        d1.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        Document d2 = new Document();\n        d2.add(new StringField(\"id\", \"2\", Field.Store.NO));\n        Document d3 = new Document();\n        d3.add(new StringField(\"id\", \"3\", Field.Store.NO));\n        writer.addDocument(d1);\n        writer.flush();\n        writer.addDocument(d2);\n        Thread t = new Thread(() -> {\n          try {\n            writer.commit();\n          } catch (IOException e) {\n            throw new AssertionError(e);\n          }\n        });\n        t.start();\n        waitForMerge.await();\n        writer.deleteAll();\n        waitForDeleteAll.countDown();\n        t.join();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}