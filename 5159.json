{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#tooDirty(CompressingStoredFieldsReader).mjava","commits":[{"id":"bd7962f4da329a4e559727022b752c5cefaee5da","date":1421356185,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#tooDirty(CompressingStoredFieldsReader).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Returns true if we should recompress this reader, even though we could bulk merge compressed data \n   * <p>\n   * The last chunk written for a segment is typically incomplete, so without recompressing,\n   * in some worst-case situations (e.g. frequent reopen with tiny flushes), over time the \n   * compression ratio can degrade. This is a safety switch.\n   */\n  boolean tooDirty(CompressingStoredFieldsReader candidate) {\n    // more than 1% dirty, or more than hard limit of 1024 dirty chunks\n    return candidate.getNumDirtyChunks() > 1024 || \n           candidate.getNumDirtyChunks() * 100 > candidate.getNumChunks();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45264aed0cfa8a8a55ae1292b0e336d29cd88401","date":1600361948,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#tooDirty(CompressingStoredFieldsReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#tooDirty(CompressingStoredFieldsReader).mjava","sourceNew":"  /** \n   * Returns true if we should recompress this reader, even though we could bulk merge compressed data \n   * <p>\n   * The last chunk written for a segment is typically incomplete, so without recompressing,\n   * in some worst-case situations (e.g. frequent reopen with tiny flushes), over time the \n   * compression ratio can degrade. This is a safety switch.\n   */\n  boolean tooDirty(CompressingStoredFieldsReader candidate) {\n    // more than 1% dirty, or more than hard limit of 1024 dirty chunks\n    return candidate.getNumDirtyChunks() > 1024 || \n           candidate.getNumDirtyDocs() * 100 > candidate.getNumDocs();\n  }\n\n","sourceOld":"  /** \n   * Returns true if we should recompress this reader, even though we could bulk merge compressed data \n   * <p>\n   * The last chunk written for a segment is typically incomplete, so without recompressing,\n   * in some worst-case situations (e.g. frequent reopen with tiny flushes), over time the \n   * compression ratio can degrade. This is a safety switch.\n   */\n  boolean tooDirty(CompressingStoredFieldsReader candidate) {\n    // more than 1% dirty, or more than hard limit of 1024 dirty chunks\n    return candidate.getNumDirtyChunks() > 1024 || \n           candidate.getNumDirtyChunks() * 100 > candidate.getNumChunks();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd7962f4da329a4e559727022b752c5cefaee5da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"45264aed0cfa8a8a55ae1292b0e336d29cd88401":["bd7962f4da329a4e559727022b752c5cefaee5da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["45264aed0cfa8a8a55ae1292b0e336d29cd88401"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bd7962f4da329a4e559727022b752c5cefaee5da"],"bd7962f4da329a4e559727022b752c5cefaee5da":["45264aed0cfa8a8a55ae1292b0e336d29cd88401"],"45264aed0cfa8a8a55ae1292b0e336d29cd88401":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}