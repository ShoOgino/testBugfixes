{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","commits":[{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + OrdsSegmentTermsEnum.brToString(target) + \" term=\" + OrdsSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        termOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        termOrd += suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen, ste.currentFrame.termOrd);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length, ste.currentFrame.termOrd);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"183f03e816db8a4c3db0ede28b1679d50aee7f52","date":1405935700,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + OrdsSegmentTermsEnum.brToString(target) + \" term=\" + OrdsSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      // Must save ord before we skip over a sub-block in case we push, below:\n      long prevTermOrd = termOrd;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        termOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        termOrd += suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen, prevTermOrd);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length, prevTermOrd);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + OrdsSegmentTermsEnum.brToString(target) + \" term=\" + OrdsSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        termOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        termOrd += suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen, ste.currentFrame.termOrd);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length, ste.currentFrame.termOrd);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + OrdsSegmentTermsEnum.brToString(target) + \" term=\" + OrdsSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      // Must save ord before we skip over a sub-block in case we push, below:\n      long prevTermOrd = termOrd;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        termOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        termOrd += suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen, prevTermOrd);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length(), prevTermOrd);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + OrdsSegmentTermsEnum.brToString(target) + \" term=\" + OrdsSegmentTermsEnum.brToString(ste.term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      // Must save ord before we skip over a sub-block in case we push, below:\n      long prevTermOrd = termOrd;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        termOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        termOrd += suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen, prevTermOrd);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length, prevTermOrd);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":["183f03e816db8a4c3db0ede28b1679d50aee7f52"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"183f03e816db8a4c3db0ede28b1679d50aee7f52":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["183f03e816db8a4c3db0ede28b1679d50aee7f52"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["183f03e816db8a4c3db0ede28b1679d50aee7f52"],"183f03e816db8a4c3db0ede28b1679d50aee7f52":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}