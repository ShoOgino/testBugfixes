{"path":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[TestCodecs.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[TestCodecs.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = TestCodecs.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (TestCodecs.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (TestCodecs.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+TestCodecs.random.nextInt(left-1);\n                upto2 += inc;\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (TestCodecs.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[LuceneTestCase.random.nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[LuceneTestCase.random.nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = LuceneTestCase.random.nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random, termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (LuceneTestCase.random.nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random, termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random, termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (LuceneTestCase.random.nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+LuceneTestCase.random.nextInt(left-1);\n                upto2 += inc;\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (LuceneTestCase.random.nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n        if (si.getCodec() instanceof Lucene3xCodec) {\n          // code below expects unicode sort order\n          continue;\n        }\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79db1323e6eae36f528470fcf59b0709cfe91ccd","date":1342017366,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, 0);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, 0);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, 0);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, false), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null, false), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null, false);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, true);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, false);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, 0);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, 0), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, 0);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsEnum docsAndFreqs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = docsAndFreqs = postings;\n              } else {\n                docs = docsAndFreqs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docsAndFreqs = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = _TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docs = _TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.FLAG_ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.FLAG_ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.FLAG_ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.docsAndPositions(null, null), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final DocsEnum docs;\n            final DocsAndPositionsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.docsAndPositions(null, null);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, DocsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.FLAG_ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.FLAG_ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.FLAG_ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FLAG_NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5311f0bff57ce15a23909f4cfb953773630534","date":1424827033,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                // nocommit: check\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb8dcd132c4d503fe16da5ce1b4efa011b7c5845","date":1427827225,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                // nocommit: asking for freq() here, but above when field.omitTF == false, PostingsEnum.NONE flag is passed?\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                // nocommit: check\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67e572298d7e4af324ac7ddbe13de700fcd069c0","date":1427827286,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                // nocommit: asking for freq() here, but above when field.omitTF == false, PostingsEnum.NONE flag is passed?\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b4e3cd382d0d075a0f1725649c084bb6510c483","date":1428096423,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum docs;\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n              if (postings != null) {\n                docs = postings;\n              } else {\n                docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n              }\n            } else {\n              postings = null;\n              docs = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE);\n            }\n            assertNotNull(docs);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = docs.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = docs.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = docs.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, docs.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator(null);\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs.Verify#_run().mjava","sourceNew":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","sourceOld":"    public void _run() throws Throwable {\n\n      for(int iter=0;iter<NUM_TEST_ITER;iter++) {\n        final FieldData field = fields[random().nextInt(fields.length)];\n        final TermsEnum termsEnum = termsDict.terms(field.fieldInfo.name).iterator();\n\n        int upto = 0;\n        // Test straight enum of the terms:\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final BytesRef expected = new BytesRef(field.terms[upto++].text2);\n          assertTrue(\"expected=\" + expected + \" vs actual \" + term, expected.bytesEquals(term));\n        }\n        assertEquals(upto, field.terms.length);\n\n        // Test random seek:\n        TermData term = field.terms[random().nextInt(field.terms.length)];\n        TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term.text2));\n        assertEquals(status, TermsEnum.SeekStatus.FOUND);\n        assertEquals(term.docs.length, termsEnum.docFreq());\n        if (field.omitTF) {\n          this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n        } else {\n          this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n        }\n\n        // Test random seek by ord:\n        final int idx = random().nextInt(field.terms.length);\n        term = field.terms[idx];\n        boolean success = false;\n        try {\n          termsEnum.seekExact(idx);\n          success = true;\n        } catch (UnsupportedOperationException uoe) {\n          // ok -- skip it\n        }\n        if (success) {\n          assertEquals(status, TermsEnum.SeekStatus.FOUND);\n          assertTrue(termsEnum.term().bytesEquals(new BytesRef(term.text2)));\n          assertEquals(term.docs.length, termsEnum.docFreq());\n          if (field.omitTF) {\n            this.verifyDocs(term.docs, term.positions, TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.NONE), false);\n          } else {\n            this.verifyDocs(term.docs, term.positions, termsEnum.postings(null, null, PostingsEnum.ALL), true);\n          }\n        }\n\n        // Test seek to non-existent terms:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek non-exist terms\");\n        }\n        for(int i=0;i<100;i++) {\n          final String text2 = TestUtil.randomUnicodeString(random()) + \".\";\n          status = termsEnum.seekCeil(new BytesRef(text2));\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        }\n\n        // Seek to each term, backwards:\n        if (VERBOSE) {\n          System.out.println(\"TEST: seek terms backwards\");\n        }\n        for(int i=field.terms.length-1;i>=0;i--) {\n          assertEquals(Thread.currentThread().getName() + \": field=\" + field.fieldInfo.name + \" term=\" + field.terms[i].text2, TermsEnum.SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(field.terms[i].text2)));\n          assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n        }\n\n        // Seek to each term by ord, backwards\n        for(int i=field.terms.length-1;i>=0;i--) {\n          try {\n            termsEnum.seekExact(i);\n            assertEquals(field.terms[i].docs.length, termsEnum.docFreq());\n            assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[i].text2)));\n          } catch (UnsupportedOperationException uoe) {\n          }\n        }\n\n        // Seek to non-existent empty-string term\n        status = termsEnum.seekCeil(new BytesRef(\"\"));\n        assertNotNull(status);\n        //assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n\n        // Make sure we're now pointing to first term\n        assertTrue(termsEnum.term().bytesEquals(new BytesRef(field.terms[0].text2)));\n\n        // Test docs enum\n        termsEnum.seekCeil(new BytesRef(\"\"));\n        upto = 0;\n        do {\n          term = field.terms[upto];\n          if (random().nextInt(3) == 1) {\n            final PostingsEnum postings;\n            if (!field.omitTF) {\n              // TODO: we should randomize which postings features are available, but\n              // need to coordinate this with the checks below that rely on such features\n              postings = termsEnum.postings(null, null, PostingsEnum.ALL);\n            } else {\n              postings = TestUtil.docs(random(), termsEnum, null, null, PostingsEnum.FREQS);\n            }\n            assertNotNull(postings);\n            int upto2 = -1;\n            boolean ended = false;\n            while(upto2 < term.docs.length-1) {\n              // Maybe skip:\n              final int left = term.docs.length-upto2;\n              int doc;\n              if (random().nextInt(3) == 1 && left >= 1) {\n                final int inc = 1+random().nextInt(left-1);\n                upto2 += inc;\n                if (random().nextInt(2) == 1) {\n                  doc = postings.advance(term.docs[upto2]);\n                  assertEquals(term.docs[upto2], doc);\n                } else {\n                  doc = postings.advance(1+term.docs[upto2]);\n                  if (doc == DocIdSetIterator.NO_MORE_DOCS) {\n                    // skipped past last doc\n                    assert upto2 == term.docs.length-1;\n                    ended = true;\n                    break;\n                  } else {\n                    // skipped to next doc\n                    assert upto2 < term.docs.length-1;\n                    if (doc >= term.docs[1+upto2]) {\n                      upto2++;\n                    }\n                  }\n                }\n              } else {\n                doc = postings.nextDoc();\n                assertTrue(doc != -1);\n                upto2++;\n              }\n              assertEquals(term.docs[upto2], doc);\n              if (!field.omitTF) {\n                assertEquals(term.positions[upto2].length, postings.freq());\n                if (random().nextInt(2) == 1) {\n                  this.verifyPositions(term.positions[upto2], postings);\n                }\n              }\n            }\n\n            if (!ended) {\n              assertEquals(DocIdSetIterator.NO_MORE_DOCS, postings.nextDoc());\n            }\n          }\n          upto++;\n\n        } while (termsEnum.next() != null);\n\n        assertEquals(upto, field.terms.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["6b4e3cd382d0d075a0f1725649c084bb6510c483"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["02331260bb246364779cb6f04919ca47900d01bb","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cb5311f0bff57ce15a23909f4cfb953773630534":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"aba371508186796cc6151d8223a5b4e16d02e26e":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8","79db1323e6eae36f528470fcf59b0709cfe91ccd"],"6b4e3cd382d0d075a0f1725649c084bb6510c483":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4","67e572298d7e4af324ac7ddbe13de700fcd069c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["79db1323e6eae36f528470fcf59b0709cfe91ccd"],"6613659748fe4411a7dcf85266e55db1f95f7315":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"eb8dcd132c4d503fe16da5ce1b4efa011b7c5845":["cb5311f0bff57ce15a23909f4cfb953773630534"],"79db1323e6eae36f528470fcf59b0709cfe91ccd":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"51f5280f31484820499077f41fcdfe92d527d9dc":["6613659748fe4411a7dcf85266e55db1f95f7315"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["02331260bb246364779cb6f04919ca47900d01bb"],"67e572298d7e4af324ac7ddbe13de700fcd069c0":["eb8dcd132c4d503fe16da5ce1b4efa011b7c5845"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8","79db1323e6eae36f528470fcf59b0709cfe91ccd"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","02331260bb246364779cb6f04919ca47900d01bb"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"02331260bb246364779cb6f04919ca47900d01bb":["322360ac5185a8446d3e0b530b2068bef67cd3d5"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"cb5311f0bff57ce15a23909f4cfb953773630534":["eb8dcd132c4d503fe16da5ce1b4efa011b7c5845"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["aba371508186796cc6151d8223a5b4e16d02e26e","79db1323e6eae36f528470fcf59b0709cfe91ccd","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"6b4e3cd382d0d075a0f1725649c084bb6510c483":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["02331260bb246364779cb6f04919ca47900d01bb"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"6613659748fe4411a7dcf85266e55db1f95f7315":["51f5280f31484820499077f41fcdfe92d527d9dc"],"eb8dcd132c4d503fe16da5ce1b4efa011b7c5845":["67e572298d7e4af324ac7ddbe13de700fcd069c0"],"79db1323e6eae36f528470fcf59b0709cfe91ccd":["aba371508186796cc6151d8223a5b4e16d02e26e","322360ac5185a8446d3e0b530b2068bef67cd3d5","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["cb5311f0bff57ce15a23909f4cfb953773630534","6b4e3cd382d0d075a0f1725649c084bb6510c483"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"67e572298d7e4af324ac7ddbe13de700fcd069c0":["6b4e3cd382d0d075a0f1725649c084bb6510c483"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["6613659748fe4411a7dcf85266e55db1f95f7315"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"02331260bb246364779cb6f04919ca47900d01bb":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}