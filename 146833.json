{"path":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","commits":[{"id":"e885d2b1e112b1d9db6a2dae82b3b493dfba1df1","date":1342716838,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"/dev/null","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(position.position, docsAndPositionsEnum.nextPosition());\n\n          // nocommit sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(payload);\n                assertEquals(position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            assertEquals(-1, docsAndPositionsEnum.startOffset());\n            assertEquals(-1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a434b20f16e875530b6c86775a3efaf148056c3b","date":1342877476,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // nocommit sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(position.position, docsAndPositionsEnum.nextPosition());\n\n          // nocommit sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(payload);\n                assertEquals(position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            assertEquals(-1, docsAndPositionsEnum.startOffset());\n            assertEquals(-1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d","date":1343058759,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"/dev/null","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"094f0d273d15943ff2daa367b891b16c672f66f1","date":1343063629,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // nocommit sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f1fcdd1f1811890e4a47cf79803b6f472696fa1","date":1343111304,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","date":1343203827,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"/dev/null","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8354bffbd37db6037b531bbf6eafa728e19f0b7a","date":1343733434,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS\", initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads();\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions)\");\n        }\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, false);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum\");\n      }\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, doCheckOffsets);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552","date":1344797146,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertFalse(\"should not have payload\", docsAndPositionsEnum.hasPayload());\n              } else {\n                assertTrue(\"should have payload but doesn't\", docsAndPositionsEnum.hasPayload());\n\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertFalse(\"2nd call to hasPayload should be false\", docsAndPositionsEnum.hasPayload());\n\n                assertNotNull(\"payload should not be null\", payload);\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95323da8eca89d45766013f5b300a865a5ac7dfb","date":1348933777,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPostingsFormat#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option]).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && random().nextInt(3) <= 2;\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && random().nextInt(3) <= 2;\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && random().nextInt(3) <= 2;\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && random().nextInt(3) <= 2;\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = random().nextDouble();\n    double payloadCheckChance = random().nextDouble();\n    double offsetCheckChance = random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"95323da8eca89d45766013f5b300a865a5ac7dfb":["2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":["ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d","1f1fcdd1f1811890e4a47cf79803b6f472696fa1"],"a434b20f16e875530b6c86775a3efaf148056c3b":["e885d2b1e112b1d9db6a2dae82b3b493dfba1df1"],"094f0d273d15943ff2daa367b891b16c672f66f1":["a434b20f16e875530b6c86775a3efaf148056c3b","ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d"],"1f1fcdd1f1811890e4a47cf79803b6f472696fa1":["ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1f1fcdd1f1811890e4a47cf79803b6f472696fa1"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552":["02331260bb246364779cb6f04919ca47900d01bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["094f0d273d15943ff2daa367b891b16c672f66f1","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","02331260bb246364779cb6f04919ca47900d01bb"],"e885d2b1e112b1d9db6a2dae82b3b493dfba1df1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8354bffbd37db6037b531bbf6eafa728e19f0b7a":["322360ac5185a8446d3e0b530b2068bef67cd3d5"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["1f1fcdd1f1811890e4a47cf79803b6f472696fa1"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["d6f074e73200c07d54f242d3880a8da5a35ff97b","2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["95323da8eca89d45766013f5b300a865a5ac7dfb"],"02331260bb246364779cb6f04919ca47900d01bb":["8354bffbd37db6037b531bbf6eafa728e19f0b7a"]},"commit2Childs":{"ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","094f0d273d15943ff2daa367b891b16c672f66f1","1f1fcdd1f1811890e4a47cf79803b6f472696fa1"],"95323da8eca89d45766013f5b300a865a5ac7dfb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":[],"a434b20f16e875530b6c86775a3efaf148056c3b":["094f0d273d15943ff2daa367b891b16c672f66f1"],"094f0d273d15943ff2daa367b891b16c672f66f1":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"1f1fcdd1f1811890e4a47cf79803b6f472696fa1":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","aba371508186796cc6151d8223a5b4e16d02e26e","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552":["95323da8eca89d45766013f5b300a865a5ac7dfb","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ddf662c415c0d0ad543e5314fcdf8396cd2f1b8d","aba371508186796cc6151d8223a5b4e16d02e26e","e885d2b1e112b1d9db6a2dae82b3b493dfba1df1"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"e885d2b1e112b1d9db6a2dae82b3b493dfba1df1":["a434b20f16e875530b6c86775a3efaf148056c3b"],"8354bffbd37db6037b531bbf6eafa728e19f0b7a":["02331260bb246364779cb6f04919ca47900d01bb"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["8354bffbd37db6037b531bbf6eafa728e19f0b7a"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"02331260bb246364779cb6f04919ca47900d01bb":["2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}