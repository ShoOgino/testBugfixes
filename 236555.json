{"path":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","commits":[{"id":"5003664d14ef48a0557ce1d8a684b15d62efe912","date":1539883534,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"/dev/null","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (totalHits >= totalHitsThreshold\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5374ec368ef9441d694af8df95b2ffbae3d7f03b","date":1548748689,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (totalHits > totalHitsThreshold\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (totalHits >= totalHitsThreshold\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (totalHits > totalHitsThreshold\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09bee0b4882762434fd0b5095fc34ee6058442e1","date":1569398789,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float bottomScore = Float.NEGATIVE_INFINITY;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5319c194edd3bf49f39c6d198107ed213c1d3670","date":1569842580,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float bottomScore = Float.NEGATIVE_INFINITY;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      minScore = bottomScore;\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float bottomScore = Float.NEGATIVE_INFINITY;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f00d3f1ad3bbb957062c4871ec23f49edda800c6","date":1569925943,"type":4,"author":"jimczi","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":null,"sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float bottomScore = Float.NEGATIVE_INFINITY;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      minScore = bottomScore;\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db0ef4e326916fc107ab6e066754d3ecba5197b","date":1570005243,"type":1,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable,boolean).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()) {\n      boolean hasChanged = false;\n      if (isQueueFull()) {\n        // since we tie-break on doc id and collect in doc id order, we can require\n        // the next float\n        float localMinScore = Math.nextUp(pqTop.score);\n        if (localMinScore > minCompetitiveScore) {\n          hasChanged = true;\n          minCompetitiveScore = localMinScore;\n          if (bottomValueChecker != null) {\n            // we don't use the next float here since we register a minimum value\n            // for other segments that might have smaller doc ids\n            bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n          }\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null) {\n        float globalMinScore = bottomValueChecker.getBottomValue();\n        if (globalMinScore > minCompetitiveScore) {\n          assert isQueueFull() == false || bottomValueChecker.getBottomValue() > Math.nextUp(pqTop.score);\n          hasChanged = true;\n          minCompetitiveScore = bottomValueChecker.getBottomValue();\n        }\n      }\n\n      if (hasChanged) {\n        scorer.setMinCompetitiveScore(minCompetitiveScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer, boolean checkQueue) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()) {\n      boolean hasChanged = false;\n      if (checkQueue && isQueueFull()) {\n        // since we tie-break on doc id and collect in doc id order, we can require\n        // the next float\n        float localMinScore = Math.nextUp(pqTop.score);\n        if (localMinScore > minCompetitiveScore) {\n          hasChanged = true;\n          minCompetitiveScore = localMinScore;\n          if (bottomValueChecker != null) {\n            // we don't use the next float here since we register a minimum value\n            // for other segments that might have smaller doc ids\n            bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n          }\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null) {\n        float globalMinScore = bottomValueChecker.getBottomValue();\n        if (globalMinScore > minCompetitiveScore) {\n          assert isQueueFull() == false || bottomValueChecker.getBottomValue() > Math.nextUp(pqTop.score);\n          hasChanged = true;\n          minCompetitiveScore = bottomValueChecker.getBottomValue();\n        }\n      }\n\n      if (hasChanged) {\n        scorer.setMinCompetitiveScore(minCompetitiveScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c10c01b195758b50e02599868e4093eb712f57","date":1570008306,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      float bottomScore = 0f;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        // since we tie-break on doc id and collect in doc id order, we can require\n        // the next float\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()) {\n      boolean hasChanged = false;\n      if (isQueueFull()) {\n        // since we tie-break on doc id and collect in doc id order, we can require\n        // the next float\n        float localMinScore = Math.nextUp(pqTop.score);\n        if (localMinScore > minCompetitiveScore) {\n          hasChanged = true;\n          minCompetitiveScore = localMinScore;\n          if (bottomValueChecker != null) {\n            // we don't use the next float here since we register a minimum value\n            // for other segments that might have smaller doc ids\n            bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n          }\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null) {\n        float globalMinScore = bottomValueChecker.getBottomValue();\n        if (globalMinScore > minCompetitiveScore) {\n          assert isQueueFull() == false || bottomValueChecker.getBottomValue() > Math.nextUp(pqTop.score);\n          hasChanged = true;\n          minCompetitiveScore = bottomValueChecker.getBottomValue();\n        }\n      }\n\n      if (hasChanged) {\n        scorer.setMinCompetitiveScore(minCompetitiveScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float localMinScore = Math.nextUp(pqTop.score);\n      if (localMinScore > minCompetitiveScore) {\n        scorer.setMinCompetitiveScore(localMinScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        minCompetitiveScore = localMinScore;\n        if (minScoreAcc!= null) {\n          // we don't use the next float but we register the document\n          // id so that other leaves can require it if they are after\n          // the current maximum\n          minScoreAcc.accumulate(pqTop.doc, pqTop.score);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      float bottomScore = 0f;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        // since we tie-break on doc id and collect in doc id order, we can require\n        // the next float\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd320327ef03681a94238b48abfe570f0fdd7387","date":1571660290,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float localMinScore = Math.nextUp(pqTop.score);\n      if (localMinScore > minCompetitiveScore) {\n        scorer.setMinCompetitiveScore(localMinScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        minCompetitiveScore = localMinScore;\n        if (minScoreAcc != null) {\n          // we don't use the next float but we register the document\n          // id so that other leaves can require it if they are after\n          // the current maximum\n          minScoreAcc.accumulate(pqTop.doc, pqTop.score);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float localMinScore = Math.nextUp(pqTop.score);\n      if (localMinScore > minCompetitiveScore) {\n        scorer.setMinCompetitiveScore(localMinScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        minCompetitiveScore = localMinScore;\n        if (minScoreAcc!= null) {\n          // we don't use the next float but we register the document\n          // id so that other leaves can require it if they are after\n          // the current maximum\n          minScoreAcc.accumulate(pqTop.doc, pqTop.score);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector#updateMinCompetitiveScore(Scorable).mjava","sourceNew":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && pqTop != null\n          && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float localMinScore = Math.nextUp(pqTop.score);\n      if (localMinScore > minCompetitiveScore) {\n        scorer.setMinCompetitiveScore(localMinScore);\n        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n        minCompetitiveScore = localMinScore;\n        if (minScoreAcc != null) {\n          // we don't use the next float but we register the document\n          // id so that other leaves can require it if they are after\n          // the current maximum\n          minScoreAcc.accumulate(pqTop.doc, pqTop.score);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void updateMinCompetitiveScore(Scorable scorer) throws IOException {\n    if (hitsThresholdChecker.isThresholdReached()\n          && ((bottomValueChecker != null && bottomValueChecker.getBottomValue() > 0)\n          || (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY))) { // -Infinity is the score of sentinels\n      // since we tie-break on doc id and collect in doc id order, we can require\n      // the next float\n      float bottomScore = Float.NEGATIVE_INFINITY;\n\n      if (pqTop != null && pqTop.score != Float.NEGATIVE_INFINITY) {\n        bottomScore = Math.nextUp(pqTop.score);\n\n        if (bottomValueChecker != null) {\n          bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);\n        }\n      }\n\n      // Global bottom can only be greater than or equal to the local bottom score\n      // The updating of global bottom score for this hit before getting here should\n      // ensure that\n      if (bottomValueChecker != null && bottomValueChecker.getBottomValue() > bottomScore) {\n        bottomScore = bottomValueChecker.getBottomValue();\n      }\n\n      scorer.setMinCompetitiveScore(bottomScore);\n      totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"807314aa41c10866aec273a0e54fd0d24d8971de":["f0c10c01b195758b50e02599868e4093eb712f57"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd320327ef03681a94238b48abfe570f0fdd7387":["807314aa41c10866aec273a0e54fd0d24d8971de"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["09bee0b4882762434fd0b5095fc34ee6058442e1","cd320327ef03681a94238b48abfe570f0fdd7387"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f0c10c01b195758b50e02599868e4093eb712f57":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["09bee0b4882762434fd0b5095fc34ee6058442e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"09bee0b4882762434fd0b5095fc34ee6058442e1":["e19eef45a852c3316ae52fdf941731448ece967a"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["09bee0b4882762434fd0b5095fc34ee6058442e1"],"807314aa41c10866aec273a0e54fd0d24d8971de":["cd320327ef03681a94238b48abfe570f0fdd7387"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"cd320327ef03681a94238b48abfe570f0fdd7387":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f0c10c01b195758b50e02599868e4093eb712f57"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"f0c10c01b195758b50e02599868e4093eb712f57":["807314aa41c10866aec273a0e54fd0d24d8971de"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["e19eef45a852c3316ae52fdf941731448ece967a"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"09bee0b4882762434fd0b5095fc34ee6058442e1":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","5319c194edd3bf49f39c6d198107ed213c1d3670"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}