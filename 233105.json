{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindowMultipleScorers(LeafCollector,Bits,int,int,int,int).mjava","commits":[{"id":"5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c","date":1445865000,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindowMultipleScorers(LeafCollector,Bits,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanScorer#scoreWindow(LeafCollector,Bits,int,int,int).mjava","sourceNew":"  private void scoreWindowMultipleScorers(LeafCollector collector, Bits acceptDocs, int windowBase, int windowMin, int windowMax, int maxFreq) throws IOException {\n    while (maxFreq < minShouldMatch && maxFreq + tail.size() >= minShouldMatch) {\n      // a match is still possible\n      final BulkScorerAndDoc candidate = tail.pop();\n      candidate.advance(windowMin);\n      if (candidate.next < windowMax) {\n        leads[maxFreq++] = candidate;\n      } else {\n        head.add(candidate);\n      }\n    }\n\n    if (maxFreq >= minShouldMatch) {\n      // There might be matches in other scorers from the tail too\n      for (int i = 0; i < tail.size(); ++i) {\n        leads[maxFreq++] = tail.get(i);\n      }\n      tail.clear();\n\n      scoreWindowIntoBitSetAndReplay(collector, acceptDocs, windowBase, windowMin, windowMax, leads, maxFreq);\n    }\n\n    // Push back scorers into head and tail\n    for (int i = 0; i < maxFreq; ++i) {\n      final BulkScorerAndDoc evicted = head.insertWithOverflow(leads[i]);\n      if (evicted != null) {\n        tail.add(evicted);\n      }\n    }\n  }\n\n","sourceOld":"  private void scoreWindow(LeafCollector collector, Bits acceptDocs, int windowBase, int windowMin, int windowMax) throws IOException {\n    // Fill 'leads' with all scorers from 'head' that are in the right window\n    leads[0] = head.pop();\n    int maxFreq = 1;\n    while (head.size() > 0 && head.top().next < windowMax) {\n      leads[maxFreq++] = head.pop();\n    }\n\n    while (maxFreq < minShouldMatch && maxFreq + tail.size() >= minShouldMatch) {\n      // a match is still possible\n      final BulkScorerAndDoc candidate = tail.pop();\n      candidate.advance(windowMin);\n      if (candidate.next < windowMax) {\n        leads[maxFreq++] = candidate;\n      } else {\n        head.add(candidate);\n      }\n    }\n\n    if (maxFreq >= minShouldMatch) {\n      // There might be matches in other scorers from the tail too\n      for (int i = 0; i < tail.size(); ++i) {\n        leads[maxFreq++] = tail.get(i);\n      }\n      tail.clear();\n\n      scoreWindow(collector, acceptDocs, windowBase, windowMin, windowMax, leads, maxFreq);\n    }\n\n    // Push back scorers into head and tail\n    for (int i = 0; i < maxFreq; ++i) {\n      final BulkScorerAndDoc evicted = head.insertWithOverflow(leads[i]);\n      if (evicted != null) {\n        tail.add(evicted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c"]},"commit2Childs":{"5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5c83732c32d5a6ea6a1ca930daa241ddec2f4c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}