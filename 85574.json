{"path":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","commits":[{"id":"b1197d6f54676973038ad402280d80a139dfd27b","date":1455734228,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"/dev/null","sourceNew":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> shards = clusterState.getSlices(collectionName);\n      if (shards != null) {\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> shards = clusterState.getSlices(collectionName);\n      if (shards != null) {\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> shards = clusterState.getSlices(collectionName);\n      if (shards != null) {\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> shards = clusterState.getSlices(collectionName);\n      if (shards != null) {\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":["b1197d6f54676973038ad402280d80a139dfd27b"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      Collection<Slice> shards = clusterState.getSlices(collectionName);\n      if (shards != null) {\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af3e10d8a1fbcc5c79b22f7477e79de467dd326c","date":1515178406,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  private static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691","date":1516909549,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive(); // this config is actually # seconds, not # tries\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000); // thus numRetries is roughly number of seconds\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive();\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000);\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,CoreContainer,SolrResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#waitForActiveCollection(String,ZkNodeProps,CoreContainer,SolrResponse).mjava","sourceNew":"  public static void waitForActiveCollection(String collectionName, CoreContainer cc, SolrResponse createCollResponse)\n      throws KeeperException, InterruptedException {\n\n    if (createCollResponse.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + createCollResponse.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (createCollResponse.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive(); // this config is actually # seconds, not # tries\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000); // thus numRetries is roughly number of seconds\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","sourceOld":"  public static void waitForActiveCollection(String collectionName, ZkNodeProps message, CoreContainer cc, SolrResponse response)\n      throws KeeperException, InterruptedException {\n\n    if (response.getResponse().get(\"exception\") != null) {\n      // the main called failed, don't wait\n      log.info(\"Not waiting for active collection due to exception: \" + response.getResponse().get(\"exception\"));\n      return;\n    }\n    \n    if (response.getResponse().get(\"failure\") != null) {\n      // TODO: we should not wait for Replicas we know failed\n    }\n    \n    String replicaNotAlive = null;\n    String replicaState = null;\n    String nodeNotLive = null;\n\n    CloudConfig ccfg = cc.getConfig().getCloudConfig();\n    Integer numRetries = ccfg.getCreateCollectionWaitTimeTillActive(); // this config is actually # seconds, not # tries\n    Boolean checkLeaderOnly = ccfg.isCreateCollectionCheckLeaderActive();\n    log.info(\"Wait for new collection to be active for at most \" + numRetries + \" seconds. Check all shard \"\n        + (checkLeaderOnly ? \"leaders\" : \"replicas\"));\n    ZkStateReader zkStateReader = cc.getZkController().getZkStateReader();\n    for (int i = 0; i < numRetries; i++) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collectionName);\n      \n      if (docCollection != null && docCollection.getSlices() != null) {\n        Collection<Slice> shards = docCollection.getSlices();\n        replicaNotAlive = null;\n        for (Slice shard : shards) {\n          Collection<Replica> replicas;\n          if (!checkLeaderOnly) replicas = shard.getReplicas();\n          else {\n            replicas = new ArrayList<Replica>();\n            replicas.add(shard.getLeader());\n          }\n          for (Replica replica : replicas) {\n            String state = replica.getStr(ZkStateReader.STATE_PROP);\n            log.debug(\"Checking replica status, collection={} replica={} state={}\", collectionName,\n                replica.getCoreUrl(), state);\n            if (!clusterState.liveNodesContain(replica.getNodeName())\n                || !state.equals(Replica.State.ACTIVE.toString())) {\n              replicaNotAlive = replica.getCoreUrl();\n              nodeNotLive = replica.getNodeName();\n              replicaState = state;\n              break;\n            }\n          }\n          if (replicaNotAlive != null) break;\n        }\n\n        if (replicaNotAlive == null) return;\n      }\n      Thread.sleep(1000); // thus numRetries is roughly number of seconds\n    }\n    if (nodeNotLive != null && replicaState != null) {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE \"\n              + (replicaState.equals(Replica.State.ACTIVE.toString()) ? \"node \" + nodeNotLive + \" is not live\"\n                  : \"replica \" + replicaNotAlive + \" is in state of \" + replicaState.toString()) + \" with timeout=\" + numRetries);\n    } else {\n      log.error(\"Timed out waiting for new collection's replicas to become ACTIVE with timeout=\" + numRetries);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b1197d6f54676973038ad402280d80a139dfd27b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b94236357aaa22b76c10629851fe4e376e0cea82":["344b0840364d990b29b97467bfcc766ff8325d11","af3e10d8a1fbcc5c79b22f7477e79de467dd326c"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","344b0840364d990b29b97467bfcc766ff8325d11"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691"],"af3e10d8a1fbcc5c79b22f7477e79de467dd326c":["344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["b1197d6f54676973038ad402280d80a139dfd27b"],"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cbd743a4843f513f793670e3ab0e272bf824faf"]},"commit2Childs":{"b1197d6f54676973038ad402280d80a139dfd27b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"b94236357aaa22b76c10629851fe4e376e0cea82":["6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"af3e10d8a1fbcc5c79b22f7477e79de467dd326c":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"344b0840364d990b29b97467bfcc766ff8325d11":["b94236357aaa22b76c10629851fe4e376e0cea82","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","af3e10d8a1fbcc5c79b22f7477e79de467dd326c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1197d6f54676973038ad402280d80a139dfd27b"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","344b0840364d990b29b97467bfcc766ff8325d11"],"6857f8205f8c5b4ff39a54d8aebb4fdfb7cfb691":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}