{"path":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.HighFreqDocsAndPositionsEnum#advance(int).mjava","commits":[{"id":"172cf08877d0e6738a51edd238c4dc5ffc088345","date":1342794823,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.HighFreqDocsAndPositionsEnum#advance(int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public int advance(int target) {\n\n      /*\n      upto++;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      }\n      final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);\n      if (index < 0) {\n        upto = -index - 1;\n      } else {\n        upto = index;\n      }\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      posUpto = hasOffsets ? -3 : -1;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      } else {\n        return docID();\n      }\n      */\n\n      //System.out.println(\"  advance target=\" + target + \" cur=\" + docID() + \" upto=\" + upto + \" of \" + docIDs.length);\n      // if (DEBUG) {\n      //   System.out.println(\"advance target=\" + target + \" len=\" + docIDs.length);\n      // }\n      upto++;\n      if (upto == docIDs.length) {\n        return docID = NO_MORE_DOCS;\n      }\n\n      // First \"grow\" outwards, since most advances are to\n      // nearby docs:\n      int inc = 10;\n      int nextUpto = upto+10;\n      int low;\n      int high;\n      while (true) {\n        //System.out.println(\"  grow nextUpto=\" + nextUpto + \" inc=\" + inc);\n        if (nextUpto >= docIDs.length) {\n          low = nextUpto-inc;\n          high = docIDs.length-1;\n          break;\n        }\n        //System.out.println(\"    docID=\" + docIDs[nextUpto]);\n\n        if (target <= docIDs[nextUpto]) {\n          low = nextUpto-inc;\n          high = nextUpto;\n          break;\n        }\n        inc *= 2;\n        nextUpto += inc;\n      }\n\n      // Now do normal binary search\n      //System.out.println(\"    after fwd: low=\" + low + \" high=\" + high);\n\n      while (true) {\n\n        if (low > high) {\n          // Not exactly found\n          //System.out.println(\"    break: no match\");\n          upto = low;\n          break;\n        }\n\n        int mid = (low + high) >>> 1;\n        int cmp = docIDs[mid] - target;\n        //System.out.println(\"    bsearch low=\" + low + \" high=\" + high+ \": docIDs[\" + mid + \"]=\" + docIDs[mid]);\n\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          // Found target\n          upto = mid;\n          //System.out.println(\"    break: match\");\n          break;\n        }\n      }\n\n      //System.out.println(\"    end upto=\" + upto + \" docID=\" + (upto >= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));\n\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      if (upto == docIDs.length) {\n        //System.out.println(\"    return END\");\n        return docID = NO_MORE_DOCS;\n      } else {\n        //System.out.println(\"    return docID=\" + docIDs[upto] + \" upto=\" + upto);\n        posUpto = -posJump;\n        curPositions = positions[upto];\n        return docID = docIDs[upto];\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.HighFreqDocsAndPositionsEnum#advance(int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public int advance(int target) {\n\n      /*\n      upto++;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      }\n      final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);\n      if (index < 0) {\n        upto = -index - 1;\n      } else {\n        upto = index;\n      }\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      posUpto = hasOffsets ? -3 : -1;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      } else {\n        return docID();\n      }\n      */\n\n      //System.out.println(\"  advance target=\" + target + \" cur=\" + docID() + \" upto=\" + upto + \" of \" + docIDs.length);\n      // if (DEBUG) {\n      //   System.out.println(\"advance target=\" + target + \" len=\" + docIDs.length);\n      // }\n      upto++;\n      if (upto == docIDs.length) {\n        return docID = NO_MORE_DOCS;\n      }\n\n      // First \"grow\" outwards, since most advances are to\n      // nearby docs:\n      int inc = 10;\n      int nextUpto = upto+10;\n      int low;\n      int high;\n      while (true) {\n        //System.out.println(\"  grow nextUpto=\" + nextUpto + \" inc=\" + inc);\n        if (nextUpto >= docIDs.length) {\n          low = nextUpto-inc;\n          high = docIDs.length-1;\n          break;\n        }\n        //System.out.println(\"    docID=\" + docIDs[nextUpto]);\n\n        if (target <= docIDs[nextUpto]) {\n          low = nextUpto-inc;\n          high = nextUpto;\n          break;\n        }\n        inc *= 2;\n        nextUpto += inc;\n      }\n\n      // Now do normal binary search\n      //System.out.println(\"    after fwd: low=\" + low + \" high=\" + high);\n\n      while (true) {\n\n        if (low > high) {\n          // Not exactly found\n          //System.out.println(\"    break: no match\");\n          upto = low;\n          break;\n        }\n\n        int mid = (low + high) >>> 1;\n        int cmp = docIDs[mid] - target;\n        //System.out.println(\"    bsearch low=\" + low + \" high=\" + high+ \": docIDs[\" + mid + \"]=\" + docIDs[mid]);\n\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          // Found target\n          upto = mid;\n          //System.out.println(\"    break: match\");\n          break;\n        }\n      }\n\n      //System.out.println(\"    end upto=\" + upto + \" docID=\" + (upto >= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));\n\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      if (upto == docIDs.length) {\n        //System.out.println(\"    return END\");\n        return docID = NO_MORE_DOCS;\n      } else {\n        //System.out.println(\"    return docID=\" + docIDs[upto] + \" upto=\" + upto);\n        posUpto = -posJump;\n        curPositions = positions[upto];\n        return docID = docIDs[upto];\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.HighFreqDocsAndPositionsEnum#advance(int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public int advance(int target) {\n\n      /*\n      upto++;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      }\n      final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);\n      if (index < 0) {\n        upto = -index - 1;\n      } else {\n        upto = index;\n      }\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      posUpto = hasOffsets ? -3 : -1;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      } else {\n        return docID();\n      }\n      */\n\n      //System.out.println(\"  advance target=\" + target + \" cur=\" + docID() + \" upto=\" + upto + \" of \" + docIDs.length);\n      // if (DEBUG) {\n      //   System.out.println(\"advance target=\" + target + \" len=\" + docIDs.length);\n      // }\n      upto++;\n      if (upto == docIDs.length) {\n        return docID = NO_MORE_DOCS;\n      }\n\n      // First \"grow\" outwards, since most advances are to\n      // nearby docs:\n      int inc = 10;\n      int nextUpto = upto+10;\n      int low;\n      int high;\n      while (true) {\n        //System.out.println(\"  grow nextUpto=\" + nextUpto + \" inc=\" + inc);\n        if (nextUpto >= docIDs.length) {\n          low = nextUpto-inc;\n          high = docIDs.length-1;\n          break;\n        }\n        //System.out.println(\"    docID=\" + docIDs[nextUpto]);\n\n        if (target <= docIDs[nextUpto]) {\n          low = nextUpto-inc;\n          high = nextUpto;\n          break;\n        }\n        inc *= 2;\n        nextUpto += inc;\n      }\n\n      // Now do normal binary search\n      //System.out.println(\"    after fwd: low=\" + low + \" high=\" + high);\n\n      while (true) {\n\n        if (low > high) {\n          // Not exactly found\n          //System.out.println(\"    break: no match\");\n          upto = low;\n          break;\n        }\n\n        int mid = (low + high) >>> 1;\n        int cmp = docIDs[mid] - target;\n        //System.out.println(\"    bsearch low=\" + low + \" high=\" + high+ \": docIDs[\" + mid + \"]=\" + docIDs[mid]);\n\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          // Found target\n          upto = mid;\n          //System.out.println(\"    break: match\");\n          break;\n        }\n      }\n\n      //System.out.println(\"    end upto=\" + upto + \" docID=\" + (upto >= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));\n\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      if (upto == docIDs.length) {\n        //System.out.println(\"    return END\");\n        return docID = NO_MORE_DOCS;\n      } else {\n        //System.out.println(\"    return docID=\" + docIDs[upto] + \" upto=\" + upto);\n        posUpto = -posJump;\n        curPositions = positions[upto];\n        return docID = docIDs[upto];\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","date":1346834651,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.HighFreqDocsAndPositionsEnum#advance(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.HighFreqDocsAndPositionsEnum#advance(int).mjava","sourceNew":"    @Override\n    public int advance(int target) {\n\n      /*\n      upto++;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      }\n      final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);\n      if (index < 0) {\n        upto = -index - 1;\n      } else {\n        upto = index;\n      }\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      posUpto = hasOffsets ? -3 : -1;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      } else {\n        return docID();\n      }\n      */\n\n      //System.out.println(\"  advance target=\" + target + \" cur=\" + docID() + \" upto=\" + upto + \" of \" + docIDs.length);\n      // if (DEBUG) {\n      //   System.out.println(\"advance target=\" + target + \" len=\" + docIDs.length);\n      // }\n      upto++;\n      if (upto == docIDs.length) {\n        return docID = NO_MORE_DOCS;\n      }\n\n      // First \"grow\" outwards, since most advances are to\n      // nearby docs:\n      int inc = 10;\n      int nextUpto = upto+10;\n      int low;\n      int high;\n      while (true) {\n        //System.out.println(\"  grow nextUpto=\" + nextUpto + \" inc=\" + inc);\n        if (nextUpto >= docIDs.length) {\n          low = nextUpto-inc;\n          high = docIDs.length-1;\n          break;\n        }\n        //System.out.println(\"    docID=\" + docIDs[nextUpto]);\n\n        if (target <= docIDs[nextUpto]) {\n          low = nextUpto-inc;\n          high = nextUpto;\n          break;\n        }\n        inc *= 2;\n        nextUpto += inc;\n      }\n\n      // Now do normal binary search\n      //System.out.println(\"    after fwd: low=\" + low + \" high=\" + high);\n\n      while (true) {\n\n        if (low > high) {\n          // Not exactly found\n          //System.out.println(\"    break: no match\");\n          upto = low;\n          break;\n        }\n\n        int mid = (low + high) >>> 1;\n        int cmp = docIDs[mid] - target;\n        //System.out.println(\"    bsearch low=\" + low + \" high=\" + high+ \": docIDs[\" + mid + \"]=\" + docIDs[mid]);\n\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          // Found target\n          upto = mid;\n          //System.out.println(\"    break: match\");\n          break;\n        }\n      }\n\n      //System.out.println(\"    end upto=\" + upto + \" docID=\" + (upto >= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));\n\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      if (upto == docIDs.length) {\n        //System.out.println(\"    return END\");\n        return docID = NO_MORE_DOCS;\n      } else {\n        //System.out.println(\"    return docID=\" + docIDs[upto] + \" upto=\" + upto);\n        posUpto = -posJump;\n        curPositions = positions[upto];\n        return docID = docIDs[upto];\n      }\n    }\n\n","sourceOld":"    @Override\n    public int advance(int target) {\n\n      /*\n      upto++;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      }\n      final int index = Arrays.binarySearch(docIDs, upto, docIDs.length, target);\n      if (index < 0) {\n        upto = -index - 1;\n      } else {\n        upto = index;\n      }\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      posUpto = hasOffsets ? -3 : -1;\n      if (upto == docIDs.length) {\n        return NO_MORE_DOCS;\n      } else {\n        return docID();\n      }\n      */\n\n      //System.out.println(\"  advance target=\" + target + \" cur=\" + docID() + \" upto=\" + upto + \" of \" + docIDs.length);\n      // if (DEBUG) {\n      //   System.out.println(\"advance target=\" + target + \" len=\" + docIDs.length);\n      // }\n      upto++;\n      if (upto == docIDs.length) {\n        return docID = NO_MORE_DOCS;\n      }\n\n      // First \"grow\" outwards, since most advances are to\n      // nearby docs:\n      int inc = 10;\n      int nextUpto = upto+10;\n      int low;\n      int high;\n      while (true) {\n        //System.out.println(\"  grow nextUpto=\" + nextUpto + \" inc=\" + inc);\n        if (nextUpto >= docIDs.length) {\n          low = nextUpto-inc;\n          high = docIDs.length-1;\n          break;\n        }\n        //System.out.println(\"    docID=\" + docIDs[nextUpto]);\n\n        if (target <= docIDs[nextUpto]) {\n          low = nextUpto-inc;\n          high = nextUpto;\n          break;\n        }\n        inc *= 2;\n        nextUpto += inc;\n      }\n\n      // Now do normal binary search\n      //System.out.println(\"    after fwd: low=\" + low + \" high=\" + high);\n\n      while (true) {\n\n        if (low > high) {\n          // Not exactly found\n          //System.out.println(\"    break: no match\");\n          upto = low;\n          break;\n        }\n\n        int mid = (low + high) >>> 1;\n        int cmp = docIDs[mid] - target;\n        //System.out.println(\"    bsearch low=\" + low + \" high=\" + high+ \": docIDs[\" + mid + \"]=\" + docIDs[mid]);\n\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          // Found target\n          upto = mid;\n          //System.out.println(\"    break: match\");\n          break;\n        }\n      }\n\n      //System.out.println(\"    end upto=\" + upto + \" docID=\" + (upto >= docIDs.length ? NO_MORE_DOCS : docIDs[upto]));\n\n      if (liveDocs != null) {\n        while (upto < docIDs.length) {\n          if (liveDocs.get(docIDs[upto])) {\n            break;\n          }\n          upto++;\n        }\n      }\n      if (upto == docIDs.length) {\n        //System.out.println(\"    return END\");\n        return docID = NO_MORE_DOCS;\n      } else {\n        //System.out.println(\"    return docID=\" + docIDs[upto] + \" upto=\" + upto);\n        posUpto = -posJump;\n        curPositions = positions[upto];\n        return docID = docIDs[upto];\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","172cf08877d0e6738a51edd238c4dc5ffc088345"],"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["172cf08877d0e6738a51edd238c4dc5ffc088345"],"172cf08877d0e6738a51edd238c4dc5ffc088345":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","172cf08877d0e6738a51edd238c4dc5ffc088345"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":[],"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","172cf08877d0e6738a51edd238c4dc5ffc088345","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"172cf08877d0e6738a51edd238c4dc5ffc088345":["aba371508186796cc6151d8223a5b4e16d02e26e","3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}