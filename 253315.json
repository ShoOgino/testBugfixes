{"path":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","commits":[{"id":"290c401c31db375e771805c3ba7ac5f64c7370dc","date":1192034795,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"/dev/null","sourceNew":"  protected void tearDown() throws Exception {\n    if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n      fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  protected void tearDown() throws Exception {\n    if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n      // Clear the failure so that we don't just keep\n      // failing subsequent test cases\n      ConcurrentMergeScheduler.clearUnhandledExceptions();\n      fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n    }\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n      fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e69f59b863731d864bf3047235e718f0f88f8841","date":1250105498,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n      // Clear the failure so that we don't just keep\n      // failing subsequent test cases\n      ConcurrentMergeScheduler.clearUnhandledExceptions();\n      fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["558b125bbf6fa91eb5355da7e849d46edaf735bc","558b125bbf6fa91eb5355da7e849d46edaf735bc","558b125bbf6fa91eb5355da7e849d46edaf735bc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"efa6f2b2265151f8faaf69272253e065734ec9d4","date":1250942675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    super.tearDown();\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9fa6d7a7e7208b52f1b0c4c87005d34ab0dd37dc","date":1251117853,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    TokenStream.setOnlyUseNewAPI(savedAPISetting);\n    super.tearDown();\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8d1458a2543cbd30cbfe7929be4dcb5c5251659","date":1254582241,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    TokenStream.setOnlyUseNewAPI(savedAPISetting);\n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a046c0c310bc77931fc8441bd920053b607dd14","date":1254584734,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    TokenStream.setOnlyUseNewAPI(savedAPISetting);\n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1326054a8d3aa66382d49decc7f330955c9c6f71","date":1257386139,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @Override\n  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","sourceOld":"  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"48a042c3df37e281328101a2e1dbb50202b08915","date":1266742053,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @Override\n  protected void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","sourceOld":"  @Override\n  protected void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":["558b125bbf6fa91eb5355da7e849d46edaf735bc","558b125bbf6fa91eb5355da7e849d46edaf735bc","558b125bbf6fa91eb5355da7e849d46edaf735bc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5ff9e61d5748484a6d8e00a9cb7689cb4841922","date":1266772579,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @Override\n  protected void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n    \n    super.tearDown();\n  }\n\n","sourceOld":"  @Override\n  protected void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCase#tearDown().mjava","sourceNew":"  @Override\n  protected void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n    \n    super.tearDown();\n  }\n\n","sourceOld":"  @Override\n  protected void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the \n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n      \n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n    \n    super.tearDown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"48a042c3df37e281328101a2e1dbb50202b08915":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"e69f59b863731d864bf3047235e718f0f88f8841":["e82780afe6097066eb5befb86e9432f077667e3d"],"0a046c0c310bc77931fc8441bd920053b607dd14":["9fa6d7a7e7208b52f1b0c4c87005d34ab0dd37dc","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"efa6f2b2265151f8faaf69272253e065734ec9d4":["e69f59b863731d864bf3047235e718f0f88f8841"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["0a046c0c310bc77931fc8441bd920053b607dd14"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["9fa6d7a7e7208b52f1b0c4c87005d34ab0dd37dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"290c401c31db375e771805c3ba7ac5f64c7370dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d5ff9e61d5748484a6d8e00a9cb7689cb4841922":["48a042c3df37e281328101a2e1dbb50202b08915"],"e82780afe6097066eb5befb86e9432f077667e3d":["290c401c31db375e771805c3ba7ac5f64c7370dc"],"9fa6d7a7e7208b52f1b0c4c87005d34ab0dd37dc":["efa6f2b2265151f8faaf69272253e065734ec9d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d5ff9e61d5748484a6d8e00a9cb7689cb4841922"]},"commit2Childs":{"48a042c3df37e281328101a2e1dbb50202b08915":["d5ff9e61d5748484a6d8e00a9cb7689cb4841922"],"e69f59b863731d864bf3047235e718f0f88f8841":["efa6f2b2265151f8faaf69272253e065734ec9d4"],"0a046c0c310bc77931fc8441bd920053b607dd14":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"efa6f2b2265151f8faaf69272253e065734ec9d4":["9fa6d7a7e7208b52f1b0c4c87005d34ab0dd37dc"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["48a042c3df37e281328101a2e1dbb50202b08915"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["0a046c0c310bc77931fc8441bd920053b607dd14"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["290c401c31db375e771805c3ba7ac5f64c7370dc"],"290c401c31db375e771805c3ba7ac5f64c7370dc":["e82780afe6097066eb5befb86e9432f077667e3d"],"d5ff9e61d5748484a6d8e00a9cb7689cb4841922":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"e82780afe6097066eb5befb86e9432f077667e3d":["e69f59b863731d864bf3047235e718f0f88f8841"],"9fa6d7a7e7208b52f1b0c4c87005d34ab0dd37dc":["0a046c0c310bc77931fc8441bd920053b607dd14","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}