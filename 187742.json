{"path":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","commits":[{"id":"c7e79e31f55cbb444e3023d430a340658755aa31","date":1357666399,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch);\n    }\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["89205ca052ebf6aadc59a88698d262c718c616ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch);\n    }\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ca415055c1401a2359adfb8f5d3fbf3887f95d7","date":1438554679,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch);\n    }\n    return query;\n  }\n\n","bugFix":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"bugIntro":["89205ca052ebf6aadc59a88698d262c718c616ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a08695eb0e2c01d06dd662674e3136641f093be","date":1450145331,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    boolean doMinMatched = doMinMatched(clauses, config.lowercaseOperators);\n    if (doMinMatched && query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":["89205ca052ebf6aadc59a88698d262c718c616ed"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89205ca052ebf6aadc59a88698d262c718c616ed","date":1465540166,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7","c7e79e31f55cbb444e3023d430a340658755aa31","8a08695eb0e2c01d06dd662674e3136641f093be"],"bugIntro":["f78578dc643ac34ccf47f0bc6fa8e97a1704a084"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, config.minShouldMatch, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (QueryParserConfigurationException e) {\n      throw e; // Don't ignore configuration exceptions\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (QueryParserConfigurationException e) {\n      throw e; // Don't ignore configuration exceptions\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b360a3d5b9d443b4e880d2c92724cffd7def8db","date":1490740768,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (QueryParserConfigurationException e) {\n      throw e; // Don't ignore configuration exceptions\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36d81030ef9ff5ae6820e560c0833127181c7a2c","date":1490873946,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (QueryParserConfigurationException e) {\n      throw e; // Don't ignore configuration exceptions\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f78578dc643ac34ccf47f0bc6fa8e97a1704a084","date":1591013591,"type":3,"author":"Yuriy Koval","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#parseOriginalQuery(ExtendedSolrQueryParser,String,List[Clause],ExtendedDismaxConfiguration).mjava","sourceNew":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = config.solrParams.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","sourceOld":"  /**\n   * Parses the user's original query.  This method attempts to cleanly parse the specified query string using the specified parser, any Exceptions are ignored resulting in null being returned.\n   *\n   * @param up parser used\n   * @param mainUserQuery query string that is parsed\n   * @param clauses used to dictate \"min should match\" logic\n   * @param config Configuration options for this parse request\n   * @return the resulting query with \"min should match\" rules applied as specified in the config.\n   * @see #parseEscapedQuery\n   */\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up,\n      String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n    \n    Query query = null;\n    try {\n      up.setRemoveStopFilter(!config.stopwords);\n      up.exceptions = true;\n      query = up.parse(mainUserQuery);\n      \n      if (shouldRemoveStopFilter(config, query)) {\n        // if the query was all stop words, remove none of them\n        up.setRemoveStopFilter(true);\n        query = up.parse(mainUserQuery);          \n      }\n    } catch (Exception e) {\n      // ignore failure and reparse later after escaping reserved chars\n      up.exceptions = false;\n    }\n    \n    if(query == null) {\n      return null;\n    }\n    // For correct lucene queries, turn off mm processing if no explicit mm spec was provided\n    // and there were explicit operators (except for AND).\n    if (query instanceof BooleanQuery) {\n      // config.minShouldMatch holds the value of mm which MIGHT have come from the user,\n      // but could also have been derived from q.op.\n      String mmSpec = config.minShouldMatch;\n\n      if (foundOperators(clauses, config.lowercaseOperators)) {\n        mmSpec = params.get(DisMaxParams.MM, \"0%\"); // Use provided mm spec if present, otherwise turn off mm processing\n      }\n      query = SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmSpec, config.mmAutoRelax);\n    }\n    return query;\n  }\n\n","bugFix":["89205ca052ebf6aadc59a88698d262c718c616ed"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["e55782fb51a6e9789542818eb2161a3247f39ace"],"89205ca052ebf6aadc59a88698d262c718c616ed":["8a08695eb0e2c01d06dd662674e3136641f093be"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":["c03778630c4604270d88c148afb8c7de35b51d3c"],"c03778630c4604270d88c148afb8c7de35b51d3c":["89205ca052ebf6aadc59a88698d262c718c616ed"],"e55782fb51a6e9789542818eb2161a3247f39ace":["89205ca052ebf6aadc59a88698d262c718c616ed"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8a08695eb0e2c01d06dd662674e3136641f093be","89205ca052ebf6aadc59a88698d262c718c616ed"],"3ca415055c1401a2359adfb8f5d3fbf3887f95d7":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["c7e79e31f55cbb444e3023d430a340658755aa31"],"f78578dc643ac34ccf47f0bc6fa8e97a1704a084":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a08695eb0e2c01d06dd662674e3136641f093be":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7"],"c7e79e31f55cbb444e3023d430a340658755aa31":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c7e79e31f55cbb444e3023d430a340658755aa31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f78578dc643ac34ccf47f0bc6fa8e97a1704a084"]},"commit2Childs":{"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["f78578dc643ac34ccf47f0bc6fa8e97a1704a084"],"89205ca052ebf6aadc59a88698d262c718c616ed":["c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":[],"c03778630c4604270d88c148afb8c7de35b51d3c":["36d81030ef9ff5ae6820e560c0833127181c7a2c"],"e55782fb51a6e9789542818eb2161a3247f39ace":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3ca415055c1401a2359adfb8f5d3fbf3887f95d7":["8a08695eb0e2c01d06dd662674e3136641f093be"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7"],"f78578dc643ac34ccf47f0bc6fa8e97a1704a084":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7e79e31f55cbb444e3023d430a340658755aa31","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"8a08695eb0e2c01d06dd662674e3136641f093be":["89205ca052ebf6aadc59a88698d262c718c616ed","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c7e79e31f55cbb444e3023d430a340658755aa31":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["36d81030ef9ff5ae6820e560c0833127181c7a2c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}