{"path":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd83550e4b0bdd36e7d9dca9273264100782440b","date":1385761753,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2","date":1391685460,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<String,Facets>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.shutdown();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad2a673349939e48652bf304cccf673c3412198f","date":1409585169,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":["19f5022544a8fc895776356d1b35a4b46d05945c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new FixedBitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new FixedBitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6","date":1424027250,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n            @Override\n            public String toString(String field) {\n              return \"drillSidewaysTestFilter\";\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n            @Override\n            public String toString(String field) {\n              return \"drillSidewaysTestFilter\";\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new FilteredQuery(q, filter);\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n            @Override\n            public String toString(String field) {\n              return \"drillSidewaysTestFilter\";\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n            @Override\n            public String toString(String field) {\n              return \"drillSidewaysTestFilter\";\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n            @Override\n            public String toString(String field) {\n              return \"drillSidewaysTestFilter\";\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new FilteredQuery(q, filter);\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d52e48927ca4ef3655a261f2230b968b6fdf3608","date":1444652107,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n            return new RandomAccessWeight(this) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n                  \n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0) {\n                  bits.set(docID);\n                }\n              }\n              return new BitDocIdSet(bits);\n            }\n            @Override\n            public String toString(String field) {\n              return \"drillSidewaysTestFilter\";\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n            return new RandomAccessWeight(this) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n\n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n            return new RandomAccessWeight(this) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n                  \n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new RandomAccessWeight(this, boost) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n\n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n            return new RandomAccessWeight(this) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n\n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new RandomAccessWeight(this, boost) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n\n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n            return new RandomAccessWeight(this) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n                  \n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e59d3612d24b4c29c5affe50a48f7fa0e342d4ec","date":1479218146,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new RandomAccessWeight(this, boost) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n\n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new RandomAccessWeight(this, boost) {\n              @Override\n              protected Bits getMatchingDocs(final LeafReaderContext context) throws IOException {\n                return new Bits() {\n\n                  @Override\n                  public boolean get(int docID) {\n                    try {\n                      return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                    } catch (NumberFormatException | IOException e) {\n                      throw new RuntimeException(e);\n                    }\n                  }\n\n                  @Override\n                  public int length() {\n                    return context.reader().maxDoc();\n                  }\n\n                };\n              }\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91eb857a56b1a3a6659c666f88e2398347fc1c5a","date":1483442809,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new SimpleCollector() {\n                             int lastDocID;\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                               lastDocID = -1;\n                             }\n\n                            @Override\n                            public boolean needsScores() {\n                              return false;\n                            }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr) {\n            @Override\n            protected Facets buildFacetsResult(FacetsCollector drillDowns, FacetsCollector[] drillSideways, String[] drillSidewaysDims) throws IOException {\n              Map<String,Facets> drillSidewaysFacets = new HashMap<>();\n              Facets drillDownFacets = getTaxonomyFacetCounts(taxoReader, config, drillDowns);\n              if (drillSideways != null) {\n                for(int i=0;i<drillSideways.length;i++) {\n                  drillSidewaysFacets.put(drillSidewaysDims[i],\n                                          getTaxonomyFacetCounts(taxoReader, config, drillSideways[i]));\n                }\n              }\n\n              if (drillSidewaysFacets.isEmpty()) {\n                return drillDownFacets;\n              } else {\n                return new MultiFacets(drillSidewaysFacets, drillDownFacets);\n              }\n\n            }\n          };\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder()\n            .add(q, Occur.MUST)\n            .add(filter, Occur.FILTER)\n            .build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"706a7a3396c030cc66dda92a0492eb492131c4c0","date":1509705614,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public IndexReader.CacheHelper getCacheHelper(LeafReaderContext context) {\n                return null;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public IndexReader.CacheHelper getCacheHelper(LeafReaderContext context) {\n                return null;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da1460d7a5dea2658e7b8e4f6e632e53ade440ac","date":1510316270,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public IndexReader.CacheHelper getCacheHelper(LeafReaderContext context) {\n                return null;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c226b0eeb8b028f572020f459851a663a2c064e","date":1542377651,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7","date":1552575873,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c6c784f777a2cc8fa014507ea129526822714d","date":1579733373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(300);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"132e4d2b791f182f095041c89860f21eb11c31a5","date":1600099601,"type":3,"author":"Julie Tibshirani","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(300);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = getNewSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(300);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"680b6449f09827f58fe987aff279e014c311d966","date":1600247985,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(300);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = getNewSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(300);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\n              \"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\"\n                      + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for (int dim = 0; dim < numDims; dim++) {\n      Set<String> values = new HashSet<>();\n      while (values.size() < valueCount) {\n        String s = TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      }\n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<>();\n    for (int i = 0; i < numDocs; i++) {\n      Doc doc = new Doc();\n      doc.id = \"\" + i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for (int dim = 0; dim < numDims; dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length - 1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for (int i = 0; i < numDims; i++) {\n      config.setMultiValued(\"dim\" + i, true);\n    }\n\n    boolean doUseDV = random().nextBoolean();\n\n    for (Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(new SortedDocValuesField(\"id\", new BytesRef(rawDoc.id)));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for (int dim = 0; dim < numDims; dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(tw, doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = TestUtil.nextInt(random(), 1, (int) (numDocs * 0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n\n    if (doUseDV) {\n      sortedSetDVState = new DefaultSortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for (int iter = 0; iter < numIters; iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown\n                + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] { dimValues[dim][random().nextInt(dimValues[dim].length)] };\n          } else {\n            int orCount = TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for (int i = 0; i < orCount; i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for (int j = 0; j < i; j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for (int i = 0; i < values.length; i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for (int dim = 0; dim < numDims; dim++) {\n        if (drillDowns[dim] != null) {\n          for (String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Query filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Query() {\n\n          @Override\n          public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n            return new ConstantScoreWeight(this, boost) {\n\n              @Override\n              public Scorer scorer(LeafReaderContext context) throws IOException {\n                DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n                return new ConstantScoreScorer(this, score(), scoreMode, new TwoPhaseIterator(approximation) {\n\n                  @Override\n                  public boolean matches() throws IOException {\n                    int docID = approximation.docID();\n                    return (Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0;\n                  }\n\n                  @Override\n                  public float matchCost() {\n                    return 1000f;\n                  }\n                });\n              }\n\n              @Override\n              public boolean isCacheable(LeafReaderContext ctx) {\n                return false;\n              }\n\n            };\n          }\n\n          @Override\n          public void visit(QueryVisitor visitor) {\n\n          }\n\n          @Override\n          public String toString(String field) {\n            return \"drillSidewaysTestFilter\";\n          }\n\n          @Override\n          public boolean equals(Object o) {\n            return o == this;\n          }\n\n          @Override\n          public int hashCode() {\n            return System.identityHashCode(this);\n          }\n        };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      getNewDrillSideways(s, config, tr).search(ddq, new SimpleCollector() {\n        int lastDocID;\n\n        @Override\n        public void collect(int doc) {\n          assert doc > lastDocID;\n          lastDocID = doc;\n        }\n\n        @Override\n        protected void doSetNextReader(LeafReaderContext context) throws IOException {\n          lastDocID = -1;\n        }\n\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, because in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        getNewDrillSidewaysScoreSubdocsAtOnce(s, config, tr).search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = getNewDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = getNewDrillSidewaysBuildFacetsResult(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String, Float> scores = new HashMap<>();\n      for (ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      Query q = ddq;\n      if (filter != null) {\n        q = new BooleanQuery.Builder().add(q, Occur.MUST).add(filter, Occur.FILTER).build();\n      }\n      TopDocs ddqHits = s.search(q, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits.value);\n      for (int i = 0; i < expected.hits.size(); i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    w.close();\n    IOUtils.close(r, tr, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e59d3612d24b4c29c5affe50a48f7fa0e342d4ec":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["e59d3612d24b4c29c5affe50a48f7fa0e342d4ec"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"132e4d2b791f182f095041c89860f21eb11c31a5":["57c6c784f777a2cc8fa014507ea129526822714d"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"680b6449f09827f58fe987aff279e014c311d966":["57c6c784f777a2cc8fa014507ea129526822714d","132e4d2b791f182f095041c89860f21eb11c31a5"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["417142ff08fda9cf0b72d5133e63097a166c6458","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["1db68e96dd908fcd79ef809095822736aa601d08"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["21d36d0db865f7b84026b447bec653469a6e66df"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ae73da626f97850c922c42736f808d0378e165f0"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"9c226b0eeb8b028f572020f459851a663a2c064e":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"40640359164f629dd440a47df2e145d084ce9645":["30fc8c22124fdcf9d76449bd2fa04decbe74e2e2"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["21019aa828c8c9b0153877543a8b3f200bf2ca19","91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"57c6c784f777a2cc8fa014507ea129526822714d":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"ae73da626f97850c922c42736f808d0378e165f0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"706a7a3396c030cc66dda92a0492eb492131c4c0":["91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","706a7a3396c030cc66dda92a0492eb492131c4c0"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["9c226b0eeb8b028f572020f459851a663a2c064e"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80c55596a764e2d397e982828e75fcac5ce430a0":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4edc984f0f4ac77c37e48ace2932f780f888453c"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e59d3612d24b4c29c5affe50a48f7fa0e342d4ec"],"6613659748fe4411a7dcf85266e55db1f95f7315":["40640359164f629dd440a47df2e145d084ce9645"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["d52e48927ca4ef3655a261f2230b968b6fdf3608","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["d0ef034a4f10871667ae75181537775ddcf8ade4","ad2a673349939e48652bf304cccf673c3412198f"],"417142ff08fda9cf0b72d5133e63097a166c6458":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac","9fc47cb7b4346802411bb432f501ed0673d7119e"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"0e7bc21595222ae4f75509300fbb7726691f387f":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["0e7bc21595222ae4f75509300fbb7726691f387f"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"ad2a673349939e48652bf304cccf673c3412198f":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["680b6449f09827f58fe987aff279e014c311d966"]},"commit2Childs":{"e59d3612d24b4c29c5affe50a48f7fa0e342d4ec":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","21019aa828c8c9b0153877543a8b3f200bf2ca19"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["f03e4bed5023ec3ef93a771b8888cae991cf448d","706a7a3396c030cc66dda92a0492eb492131c4c0","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"132e4d2b791f182f095041c89860f21eb11c31a5":["680b6449f09827f58fe987aff279e014c311d966"],"1db68e96dd908fcd79ef809095822736aa601d08":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"680b6449f09827f58fe987aff279e014c311d966":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["4edc984f0f4ac77c37e48ace2932f780f888453c"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["56572ec06f1407c066d6b7399413178b33176cd8","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","93dd449115a9247533e44bab47e8429e5dccbc6d"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2":["40640359164f629dd440a47df2e145d084ce9645"],"9c226b0eeb8b028f572020f459851a663a2c064e":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"40640359164f629dd440a47df2e145d084ce9645":["6613659748fe4411a7dcf85266e55db1f95f7315"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"57c6c784f777a2cc8fa014507ea129526822714d":["132e4d2b791f182f095041c89860f21eb11c31a5","680b6449f09827f58fe987aff279e014c311d966"],"ae73da626f97850c922c42736f808d0378e165f0":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"706a7a3396c030cc66dda92a0492eb492131c4c0":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["80c55596a764e2d397e982828e75fcac5ce430a0"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["57c6c784f777a2cc8fa014507ea129526822714d"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cc728b07df73b197e6d940d27f9b08b63918f13","21d36d0db865f7b84026b447bec653469a6e66df"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["30fc8c22124fdcf9d76449bd2fa04decbe74e2e2"],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["9c226b0eeb8b028f572020f459851a663a2c064e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae73da626f97850c922c42736f808d0378e165f0","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["21019aa828c8c9b0153877543a8b3f200bf2ca19"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"21d36d0db865f7b84026b447bec653469a6e66df":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","ad2a673349939e48652bf304cccf673c3412198f"],"0e7bc21595222ae4f75509300fbb7726691f387f":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["e59d3612d24b4c29c5affe50a48f7fa0e342d4ec","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"ad2a673349939e48652bf304cccf673c3412198f":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f03e4bed5023ec3ef93a771b8888cae991cf448d","56572ec06f1407c066d6b7399413178b33176cd8","15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}