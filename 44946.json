{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","commits":[{"id":"b940572a59da1b42b6c20ab5278155b12816807a","date":1462388874,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd78ba595fa6cdd7fff930f26d154d13a823fa47","date":1462400514,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"291857aeee5ec20518ddce131ac4362c0075ebe1","date":1467882201,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"920b078f38927d1129b28d683b5e89228a27edc0","date":1474295383,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d34a674b360fc9af16fceeb9df37363eceb3484","date":1474378553,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e91774ac3ed0db43b41f92ae954c447e50bdfb","date":1474437614,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64b273d51a6540272668680ece9f8b686ff0004","date":1492404078,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (cluster.getSolrClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15ac2153c8e082a2a01cfc713bfa7cb1cf9d709c","date":1510261138,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder()\n        .withZkHost(cluster.getZkServer().getZkAddress())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8","date":1520696743,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder()\n        .withZkHost(cluster.getZkServer().getZkAddress())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":["15ac2153c8e082a2a01cfc713bfa7cb1cf9d709c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"177e0a3b3d5d15f9cc40e392177343f6945f0fec","date":1539157346,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),\n        false, true, TIMEOUT);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(COLLECTION, \"conf\", 2, 1).process(cluster.getSolrClient());\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),\n        false, true, TIMEOUT);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":["177e0a3b3d5d15f9cc40e392177343f6945f0fec","a64b273d51a6540272668680ece9f8b686ff0004","b940572a59da1b42b6c20ab5278155b12816807a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      if (log.isInfoEnabled()) {\n        log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n      }\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  @Test\n  public void testRouting() throws Exception {\n    CollectionAdminRequest.createCollection(\"routing_collection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.waitForActiveCollection(\"routing_collection\", 2, 2);\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = getRandomClient().request(request, \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(response);\n    }\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    final UpdateResponse uResponse = new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), \"routing_collection\");\n    if (getRandomClient().isDirectUpdatesToLeadersOnly()) {\n      checkSingleServer(uResponse.getResponse());\n    }\n\n    QueryResponse qResponse = getRandomClient().query(\"routing_collection\", new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClientBuilder\n        (Collections.singletonList(cluster.getZkServer().getZkAddress()), Optional.empty())\n        .withParallelUpdates(true)\n        .build()) {\n      threadedClient.setDefaultCollection(\"routing_collection\");\n      response = threadedClient.request(request);\n      if (threadedClient.isDirectUpdatesToLeadersOnly()) {\n        checkSingleServer(response);\n      }\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(\"routing_collection\");\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, \"routing_collection\"));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", getRandomClient().query(\"routing_collection\", solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, \"routing_collection\");\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"15ac2153c8e082a2a01cfc713bfa7cb1cf9d709c":["a64b273d51a6540272668680ece9f8b686ff0004"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["291857aeee5ec20518ddce131ac4362c0075ebe1"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"03e91774ac3ed0db43b41f92ae954c447e50bdfb":["920b078f38927d1129b28d683b5e89228a27edc0","7d34a674b360fc9af16fceeb9df37363eceb3484"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["177e0a3b3d5d15f9cc40e392177343f6945f0fec"],"a64b273d51a6540272668680ece9f8b686ff0004":["291857aeee5ec20518ddce131ac4362c0075ebe1"],"73450c0955930295d34703e7ddbfc6973b7a121a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b940572a59da1b42b6c20ab5278155b12816807a"],"177e0a3b3d5d15f9cc40e392177343f6945f0fec":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"b940572a59da1b42b6c20ab5278155b12816807a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"920b078f38927d1129b28d683b5e89228a27edc0":["291857aeee5ec20518ddce131ac4362c0075ebe1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","291857aeee5ec20518ddce131ac4362c0075ebe1"],"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b940572a59da1b42b6c20ab5278155b12816807a"],"7d34a674b360fc9af16fceeb9df37363eceb3484":["920b078f38927d1129b28d683b5e89228a27edc0"],"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8":["15ac2153c8e082a2a01cfc713bfa7cb1cf9d709c"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"291857aeee5ec20518ddce131ac4362c0075ebe1":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dc613ed6f75d1988140301ee8de8fdb056fa337"]},"commit2Childs":{"15ac2153c8e082a2a01cfc713bfa7cb1cf9d709c":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"03e91774ac3ed0db43b41f92ae954c447e50bdfb":[],"a64b273d51a6540272668680ece9f8b686ff0004":["15ac2153c8e082a2a01cfc713bfa7cb1cf9d709c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"73450c0955930295d34703e7ddbfc6973b7a121a":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","291857aeee5ec20518ddce131ac4362c0075ebe1"],"177e0a3b3d5d15f9cc40e392177343f6945f0fec":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"b940572a59da1b42b6c20ab5278155b12816807a":["73450c0955930295d34703e7ddbfc6973b7a121a","bd78ba595fa6cdd7fff930f26d154d13a823fa47"],"920b078f38927d1129b28d683b5e89228a27edc0":["03e91774ac3ed0db43b41f92ae954c447e50bdfb","7d34a674b360fc9af16fceeb9df37363eceb3484"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7d34a674b360fc9af16fceeb9df37363eceb3484":["03e91774ac3ed0db43b41f92ae954c447e50bdfb"],"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8":["177e0a3b3d5d15f9cc40e392177343f6945f0fec"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["73450c0955930295d34703e7ddbfc6973b7a121a","b940572a59da1b42b6c20ab5278155b12816807a","bd78ba595fa6cdd7fff930f26d154d13a823fa47","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"291857aeee5ec20518ddce131ac4362c0075ebe1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","a64b273d51a6540272668680ece9f8b686ff0004","920b078f38927d1129b28d683b5e89228a27edc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","03e91774ac3ed0db43b41f92ae954c447e50bdfb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}