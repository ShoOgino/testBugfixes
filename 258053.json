{"path":"contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse#intersect(LineSegment,Point2D,Point2D).mjava","commits":[{"id":"04a4a94db1eb59c8583adb166acfe686a031bedc","date":1230622637,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse#intersect(LineSegment,Point2D,Point2D).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Determines if a line segment intersects the ellipse and if so finds the\n   * point(s) of intersection.\n   * \n   * @param seg\n   *            Line segment to test for intersection\n   * @param pt0\n   *            OUT - intersection point (if it exists)\n   * @param pt1\n   *            OUT - second intersection point (if it exists)\n   * \n   * @return Returns the number of intersection points (0, 1, or 2).\n   */\n  public int intersect(LineSegment seg, Point2D pt0, Point2D pt1) {\n    if (pt0 == null)\n      pt0 = new Point2D();\n    if (pt1 == null)\n      pt1 = new Point2D();\n\n    // Solution is found by paramterizing the line segment and\n    // substituting those values into the ellipse equation.\n    // Results in a quadratic equation.\n    double x1 = center.x();\n    double y1 = center.y();\n    double u1 = seg.A.x();\n    double v1 = seg.A.y();\n    double u2 = seg.B.x();\n    double v2 = seg.B.y();\n    double dx = u2 - u1;\n    double dy = v2 - v1;\n    double q0 = k1 * SQR(u1 - x1) + k2 * (u1 - x1) * (v1 - y1) + k3\n        * SQR(v1 - y1) - 1;\n    double q1 = (2 * k1 * dx * (u1 - x1)) + (k2 * dx * (v1 - y1))\n        + (k2 * dy * (u1 - x1)) + (2 * k3 * dy * (v1 - y1));\n    double q2 = (k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy));\n\n    // Compare q1^2 to 4*q0*q2 to see how quadratic solves\n    double d = SQR(q1) - (4 * q0 * q2);\n    if (d < 0) {\n      // Roots are complex valued. Line containing the segment does\n      // not intersect the ellipse\n      return 0;\n    }\n\n    if (d == 0) {\n      // One real-valued root - line is tangent to the ellipse\n      double t = -q1 / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        return 1;\n      } else\n        return 0;\n    } else {\n      // Two distinct real-valued roots. Solve for the roots and see if\n      // they fall along the line segment\n      int n = 0;\n      double q = Math.sqrt(d);\n      double t = (-q1 - q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        n++;\n      }\n\n      // 2nd root\n      t = (-q1 + q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        if (n == 0) {\n          pt0.x(u1 + t * dx);\n          pt0.y(v1 + t * dy);\n          n++;\n        } else {\n          pt1.x(u1 + t * dx);\n          pt1.y(v1 + t * dy);\n          n++;\n        }\n      }\n      return n;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse#intersect(LineSegment,Point2D,Point2D).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse#intersect(LineSegment,Point2D,Point2D).mjava","sourceNew":"  /**\n   * Determines if a line segment intersects the ellipse and if so finds the\n   * point(s) of intersection.\n   * \n   * @param seg\n   *            Line segment to test for intersection\n   * @param pt0\n   *            OUT - intersection point (if it exists)\n   * @param pt1\n   *            OUT - second intersection point (if it exists)\n   * \n   * @return Returns the number of intersection points (0, 1, or 2).\n   */\n  public int intersect(LineSegment seg, Point2D pt0, Point2D pt1) {\n    if (pt0 == null)\n      pt0 = new Point2D();\n    if (pt1 == null)\n      pt1 = new Point2D();\n\n    // Solution is found by parameterizing the line segment and\n    // substituting those values into the ellipse equation.\n    // Results in a quadratic equation.\n    double x1 = center.x();\n    double y1 = center.y();\n    double u1 = seg.A.x();\n    double v1 = seg.A.y();\n    double u2 = seg.B.x();\n    double v2 = seg.B.y();\n    double dx = u2 - u1;\n    double dy = v2 - v1;\n    double q0 = k1 * SQR(u1 - x1) + k2 * (u1 - x1) * (v1 - y1) + k3\n        * SQR(v1 - y1) - 1;\n    double q1 = (2 * k1 * dx * (u1 - x1)) + (k2 * dx * (v1 - y1))\n        + (k2 * dy * (u1 - x1)) + (2 * k3 * dy * (v1 - y1));\n    double q2 = (k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy));\n\n    // Compare q1^2 to 4*q0*q2 to see how quadratic solves\n    double d = SQR(q1) - (4 * q0 * q2);\n    if (d < 0) {\n      // Roots are complex valued. Line containing the segment does\n      // not intersect the ellipse\n      return 0;\n    }\n\n    if (d == 0) {\n      // One real-valued root - line is tangent to the ellipse\n      double t = -q1 / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        return 1;\n      } else\n        return 0;\n    } else {\n      // Two distinct real-valued roots. Solve for the roots and see if\n      // they fall along the line segment\n      int n = 0;\n      double q = Math.sqrt(d);\n      double t = (-q1 - q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        n++;\n      }\n\n      // 2nd root\n      t = (-q1 + q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        if (n == 0) {\n          pt0.x(u1 + t * dx);\n          pt0.y(v1 + t * dy);\n          n++;\n        } else {\n          pt1.x(u1 + t * dx);\n          pt1.y(v1 + t * dy);\n          n++;\n        }\n      }\n      return n;\n    }\n  }\n\n","sourceOld":"  /**\n   * Determines if a line segment intersects the ellipse and if so finds the\n   * point(s) of intersection.\n   * \n   * @param seg\n   *            Line segment to test for intersection\n   * @param pt0\n   *            OUT - intersection point (if it exists)\n   * @param pt1\n   *            OUT - second intersection point (if it exists)\n   * \n   * @return Returns the number of intersection points (0, 1, or 2).\n   */\n  public int intersect(LineSegment seg, Point2D pt0, Point2D pt1) {\n    if (pt0 == null)\n      pt0 = new Point2D();\n    if (pt1 == null)\n      pt1 = new Point2D();\n\n    // Solution is found by paramterizing the line segment and\n    // substituting those values into the ellipse equation.\n    // Results in a quadratic equation.\n    double x1 = center.x();\n    double y1 = center.y();\n    double u1 = seg.A.x();\n    double v1 = seg.A.y();\n    double u2 = seg.B.x();\n    double v2 = seg.B.y();\n    double dx = u2 - u1;\n    double dy = v2 - v1;\n    double q0 = k1 * SQR(u1 - x1) + k2 * (u1 - x1) * (v1 - y1) + k3\n        * SQR(v1 - y1) - 1;\n    double q1 = (2 * k1 * dx * (u1 - x1)) + (k2 * dx * (v1 - y1))\n        + (k2 * dy * (u1 - x1)) + (2 * k3 * dy * (v1 - y1));\n    double q2 = (k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy));\n\n    // Compare q1^2 to 4*q0*q2 to see how quadratic solves\n    double d = SQR(q1) - (4 * q0 * q2);\n    if (d < 0) {\n      // Roots are complex valued. Line containing the segment does\n      // not intersect the ellipse\n      return 0;\n    }\n\n    if (d == 0) {\n      // One real-valued root - line is tangent to the ellipse\n      double t = -q1 / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        return 1;\n      } else\n        return 0;\n    } else {\n      // Two distinct real-valued roots. Solve for the roots and see if\n      // they fall along the line segment\n      int n = 0;\n      double q = Math.sqrt(d);\n      double t = (-q1 - q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        n++;\n      }\n\n      // 2nd root\n      t = (-q1 + q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        if (n == 0) {\n          pt0.x(u1 + t * dx);\n          pt0.y(v1 + t * dy);\n          n++;\n        } else {\n          pt1.x(u1 + t * dx);\n          pt1.y(v1 + t * dy);\n          n++;\n        }\n      }\n      return n;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse#intersect(LineSegment,Point2D,Point2D).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse#intersect(LineSegment,Point2D,Point2D).mjava","sourceNew":"  /**\n   * Determines if a line segment intersects the ellipse and if so finds the\n   * point(s) of intersection.\n   * \n   * @param seg\n   *            Line segment to test for intersection\n   * @param pt0\n   *            OUT - intersection point (if it exists)\n   * @param pt1\n   *            OUT - second intersection point (if it exists)\n   * \n   * @return Returns the number of intersection points (0, 1, or 2).\n   */\n  public int intersect(LineSegment seg, Point2D pt0, Point2D pt1) {\n    if (pt0 == null)\n      pt0 = new Point2D();\n    if (pt1 == null)\n      pt1 = new Point2D();\n\n    // Solution is found by parameterizing the line segment and\n    // substituting those values into the ellipse equation.\n    // Results in a quadratic equation.\n    double x1 = center.x();\n    double y1 = center.y();\n    double u1 = seg.A.x();\n    double v1 = seg.A.y();\n    double u2 = seg.B.x();\n    double v2 = seg.B.y();\n    double dx = u2 - u1;\n    double dy = v2 - v1;\n    double q0 = k1 * SQR(u1 - x1) + k2 * (u1 - x1) * (v1 - y1) + k3\n        * SQR(v1 - y1) - 1;\n    double q1 = (2 * k1 * dx * (u1 - x1)) + (k2 * dx * (v1 - y1))\n        + (k2 * dy * (u1 - x1)) + (2 * k3 * dy * (v1 - y1));\n    double q2 = (k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy));\n\n    // Compare q1^2 to 4*q0*q2 to see how quadratic solves\n    double d = SQR(q1) - (4 * q0 * q2);\n    if (d < 0) {\n      // Roots are complex valued. Line containing the segment does\n      // not intersect the ellipse\n      return 0;\n    }\n\n    if (d == 0) {\n      // One real-valued root - line is tangent to the ellipse\n      double t = -q1 / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        return 1;\n      } else\n        return 0;\n    } else {\n      // Two distinct real-valued roots. Solve for the roots and see if\n      // they fall along the line segment\n      int n = 0;\n      double q = Math.sqrt(d);\n      double t = (-q1 - q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        n++;\n      }\n\n      // 2nd root\n      t = (-q1 + q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        if (n == 0) {\n          pt0.x(u1 + t * dx);\n          pt0.y(v1 + t * dy);\n          n++;\n        } else {\n          pt1.x(u1 + t * dx);\n          pt1.y(v1 + t * dy);\n          n++;\n        }\n      }\n      return n;\n    }\n  }\n\n","sourceOld":"  /**\n   * Determines if a line segment intersects the ellipse and if so finds the\n   * point(s) of intersection.\n   * \n   * @param seg\n   *            Line segment to test for intersection\n   * @param pt0\n   *            OUT - intersection point (if it exists)\n   * @param pt1\n   *            OUT - second intersection point (if it exists)\n   * \n   * @return Returns the number of intersection points (0, 1, or 2).\n   */\n  public int intersect(LineSegment seg, Point2D pt0, Point2D pt1) {\n    if (pt0 == null)\n      pt0 = new Point2D();\n    if (pt1 == null)\n      pt1 = new Point2D();\n\n    // Solution is found by parameterizing the line segment and\n    // substituting those values into the ellipse equation.\n    // Results in a quadratic equation.\n    double x1 = center.x();\n    double y1 = center.y();\n    double u1 = seg.A.x();\n    double v1 = seg.A.y();\n    double u2 = seg.B.x();\n    double v2 = seg.B.y();\n    double dx = u2 - u1;\n    double dy = v2 - v1;\n    double q0 = k1 * SQR(u1 - x1) + k2 * (u1 - x1) * (v1 - y1) + k3\n        * SQR(v1 - y1) - 1;\n    double q1 = (2 * k1 * dx * (u1 - x1)) + (k2 * dx * (v1 - y1))\n        + (k2 * dy * (u1 - x1)) + (2 * k3 * dy * (v1 - y1));\n    double q2 = (k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy));\n\n    // Compare q1^2 to 4*q0*q2 to see how quadratic solves\n    double d = SQR(q1) - (4 * q0 * q2);\n    if (d < 0) {\n      // Roots are complex valued. Line containing the segment does\n      // not intersect the ellipse\n      return 0;\n    }\n\n    if (d == 0) {\n      // One real-valued root - line is tangent to the ellipse\n      double t = -q1 / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        return 1;\n      } else\n        return 0;\n    } else {\n      // Two distinct real-valued roots. Solve for the roots and see if\n      // they fall along the line segment\n      int n = 0;\n      double q = Math.sqrt(d);\n      double t = (-q1 - q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        // Intersection occurs along line segment\n        pt0.x(u1 + t * dx);\n        pt0.y(v1 + t * dy);\n        n++;\n      }\n\n      // 2nd root\n      t = (-q1 + q) / (2 * q2);\n      if (0 <= t && t <= 1) {\n        if (n == 0) {\n          pt0.x(u1 + t * dx);\n          pt0.y(v1 + t * dy);\n          n++;\n        } else {\n          pt1.x(u1 + t * dx);\n          pt1.y(v1 + t * dy);\n          n++;\n        }\n      }\n      return n;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04a4a94db1eb59c8583adb166acfe686a031bedc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["add7d922e63099fbce8f0a1b31216df7ef5067f1"]},"commit2Childs":{"04a4a94db1eb59c8583adb166acfe686a031bedc":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}