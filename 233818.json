{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<String>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<String>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<String>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<String>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<String>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<String>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76","date":1406617066,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String,InfoStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#cleanupOldIndexFiles(Directory,String).mjava","sourceNew":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile, InfoStream infoStream) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happen during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"cleanupOldIndexFiles(): failed on error \" + t.getMessage());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Cleans up the index directory from old index files. This method uses the\n   * last commit found by {@link #getLastCommit(Directory)}. If it matches the\n   * expected segmentsFile, then all files not referenced by this commit point\n   * are deleted.\n   * <p>\n   * <b>NOTE:</b> this method does a best effort attempt to clean the index\n   * directory. It suppresses any exceptions that occur, as this can be retried\n   * the next time.\n   */\n  public static void cleanupOldIndexFiles(Directory dir, String segmentsFile) {\n    try {\n      IndexCommit commit = getLastCommit(dir);\n      // commit == null means weird IO errors occurred, ignore them\n      // if there were any IO errors reading the expected commit point (i.e.\n      // segments files mismatch), then ignore that commit either.\n      if (commit != null && commit.getSegmentsFileName().equals(segmentsFile)) {\n        Set<String> commitFiles = new HashSet<>();\n        commitFiles.addAll(commit.getFileNames());\n        commitFiles.add(IndexFileNames.SEGMENTS_GEN);\n        Matcher matcher = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n        for (String file : dir.listAll()) {\n          if (!commitFiles.contains(file)\n              && (matcher.reset(file).matches() || file.startsWith(IndexFileNames.SEGMENTS))) {\n            try {\n              dir.deleteFile(file);\n            } catch (Throwable t) {\n              // suppress, it's just a best effort\n            }\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // ignore any errors that happens during this state and only log it. this\n      // cleanup will have a chance to succeed the next time we get a new\n      // revision.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"]},"commit2Childs":{"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}