{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","commits":[{"id":"50b84d7eef0fc32233dd6251567fdbdb10c4cda7","date":1365707213,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnapp(Shape).mjava","sourceNew":"  protected Rectangle gridSnap(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    double minX = Double.POSITIVE_INFINITY, maxX = Double.NEGATIVE_INFINITY;\n    double minY = Double.POSITIVE_INFINITY, maxY = Double.NEGATIVE_INFINITY;\n    for (Cell cell : cells) {\n      assert cell.getLevel() <= detailLevel;\n      Rectangle cellR = cell.getShape().getBoundingBox();\n\n      minX = Math.min(minX, cellR.getMinX());\n      maxX = Math.max(maxX, cellR.getMaxX());\n      minY = Math.min(minY, cellR.getMinY());\n      maxY = Math.max(maxY, cellR.getMaxY());\n    }\n    return ctx.makeRectangle(minX, maxX, minY, maxY);\n  }\n\n","sourceOld":"  protected Rectangle gridSnapp(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    double minX = Double.POSITIVE_INFINITY, maxX = Double.NEGATIVE_INFINITY;\n    double minY = Double.POSITIVE_INFINITY, maxY = Double.NEGATIVE_INFINITY;\n    for (Cell cell : cells) {\n      assert cell.getLevel() <= detailLevel;\n      Rectangle cellR = cell.getShape().getBoundingBox();\n\n      minX = Math.min(minX, cellR.getMinX());\n      maxX = Math.max(maxX, cellR.getMaxX());\n      minY = Math.min(minY, cellR.getMinY());\n      maxY = Math.max(maxY, cellR.getMaxY());\n    }\n    return ctx.makeRectangle(minX, maxX, minY, maxY);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c812573c5617c5a3eff581b09251df3030455fbb","date":1392316648,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Rectangle gridSnap(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<Shape>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<Shape>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Rectangle gridSnap(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    double minX = Double.POSITIVE_INFINITY, maxX = Double.NEGATIVE_INFINITY;\n    double minY = Double.POSITIVE_INFINITY, maxY = Double.NEGATIVE_INFINITY;\n    for (Cell cell : cells) {\n      assert cell.getLevel() <= detailLevel;\n      Rectangle cellR = cell.getShape().getBoundingBox();\n\n      minX = Math.min(minX, cellR.getMinX());\n      maxX = Math.max(maxX, cellR.getMaxX());\n      minY = Math.min(minY, cellR.getMinY());\n      maxY = Math.max(maxY, cellR.getMaxY());\n    }\n    return ctx.makeRectangle(minX, maxX, minY, maxY);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Rectangle gridSnap(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Rectangle gridSnap(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<Shape>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<Shape>(cellShapes, ctx).getBoundingBox();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f54c29b684839e16d0a7ffd41ee8a1e93e905184","date":1395120410,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Rectangle gridSnap(Shape snapMe) {\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bbe72b1a752bdee427ae5d2bc9f2a847b51a628","date":1395439624,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (ctx.isGeo()) {\n      //A hack; works around issue with (dateline) wrap-around when the point or rect is exactly\n      // adjacent to the dateline.\n      if (snapMe instanceof Point) {\n        snapMe = snapMe.getBoundingBox();\n      }\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdd4e2cfcc97713644621a92fd9babf5ed8e9a6a","date":1395639545,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (snapMe instanceof Point) {\n      snapMe = snapMe.getBoundingBox();\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (ctx.isGeo()) {\n      //A hack; works around issue with (dateline) wrap-around when the point or rect is exactly\n      // adjacent to the dateline.\n      if (snapMe instanceof Point) {\n        snapMe = snapMe.getBoundingBox();\n      }\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (snapMe instanceof Point) {\n      snapMe = snapMe.getBoundingBox();\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    CellIterator cells = grid.getTreeCellIterator(snapMe, detailLevel);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(1024);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (snapMe instanceof Point) {\n      snapMe = snapMe.getBoundingBox();\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    List<Cell> cells = grid.getCells(snapMe, detailLevel, false, true);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(cells.size());\n    for (Cell cell : cells) {\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0521546db127e358ced1772a9d696dbdd255b203","date":1403202289,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#gridSnap(Shape).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#gridSnap(Shape).mjava","sourceNew":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (snapMe instanceof Point) {\n      snapMe = snapMe.getBoundingBox();\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    CellIterator cells = grid.getTreeCellIterator(snapMe, detailLevel);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(1024);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","sourceOld":"  protected Shape gridSnap(Shape snapMe) {\n    if (snapMe == null)\n      return null;\n    if (snapMe instanceof ShapePair) {\n      ShapePair me = (ShapePair) snapMe;\n      return new ShapePair(gridSnap(me.shape1), gridSnap(me.shape2), me.biasContainsThenWithin);\n    }\n    if (snapMe instanceof Point) {\n      snapMe = snapMe.getBoundingBox();\n    }\n    //The next 4 lines mimic PrefixTreeStrategy.createIndexableFields()\n    double distErrPct = ((PrefixTreeStrategy) strategy).getDistErrPct();\n    double distErr = SpatialArgs.calcDistanceFromErrPct(snapMe, distErrPct, ctx);\n    int detailLevel = grid.getLevelForDistance(distErr);\n    CellIterator cells = grid.getTreeCellIterator(snapMe, detailLevel);\n\n    //calc bounding box of cells.\n    List<Shape> cellShapes = new ArrayList<>(1024);\n    while (cells.hasNext()) {\n      Cell cell = cells.next();\n      if (!cell.isLeaf())\n        continue;\n      cellShapes.add(cell.getShape());\n    }\n    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fdd4e2cfcc97713644621a92fd9babf5ed8e9a6a":["9bbe72b1a752bdee427ae5d2bc9f2a847b51a628"],"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c812573c5617c5a3eff581b09251df3030455fbb"],"c812573c5617c5a3eff581b09251df3030455fbb":["50b84d7eef0fc32233dd6251567fdbdb10c4cda7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9bbe72b1a752bdee427ae5d2bc9f2a847b51a628":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["fdd4e2cfcc97713644621a92fd9babf5ed8e9a6a"],"0521546db127e358ced1772a9d696dbdd255b203":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0521546db127e358ced1772a9d696dbdd255b203"],"50b84d7eef0fc32233dd6251567fdbdb10c4cda7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fdd4e2cfcc97713644621a92fd9babf5ed8e9a6a":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["9bbe72b1a752bdee427ae5d2bc9f2a847b51a628"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"c812573c5617c5a3eff581b09251df3030455fbb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50b84d7eef0fc32233dd6251567fdbdb10c4cda7"],"9bbe72b1a752bdee427ae5d2bc9f2a847b51a628":["fdd4e2cfcc97713644621a92fd9babf5ed8e9a6a"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["0521546db127e358ced1772a9d696dbdd255b203"],"0521546db127e358ced1772a9d696dbdd255b203":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"50b84d7eef0fc32233dd6251567fdbdb10c4cda7":["c812573c5617c5a3eff581b09251df3030455fbb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}