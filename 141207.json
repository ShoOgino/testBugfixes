{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","commits":[{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":1,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,IndexReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, IndexReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = getIndexReader();\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b","date":1328532481,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarityProvider(schema.getSimilarityProvider());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a5469a71486c4c1e313c7fcb08188d7111195c2","date":1333407337,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n\n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b71270589e15ba8ded04828dc24cd7d9d5d7cdaf","date":1341697699,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.indexDir = getIndexDir(dir);\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22659e4b60cbbd3c13216360578240ddeca2d8b4","date":1341827398,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.indexDir = getIndexDir(dir);\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e7f30683f53928b2fce016e6430c9795caff22","date":1341839598,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.indexDir = getIndexDir(dir);\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.indexDir = getIndexDir(dir);\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n    \n    if (dir instanceof FSDirectory) {\n      FSDirectory fsDirectory = (FSDirectory) dir;\n      indexDir = fsDirectory.getDirectory().getAbsolutePath();\n    } else {\n      log.warn(\"WARNING: Directory impl does not support setting indexDir: \" + dir.getClass().getName());\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.indexDir = getIndexDir(dir);\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.indexDir = getIndexDir(dir);\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b3d16cba9355e2e97962eb1c441bbd0b6735c15","date":1357426290,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    for(FieldInfo fieldInfo : atomicReader.getFieldInfos()) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ce568448269aad19a317e537eefc0993934c9d","date":1361139215,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09c8567c25c02eeeb3e719841606a1269f3538ca","date":1361155063,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,String,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#SolrIndexSearcher(SolrCore,IndexSchema,String,DirectoryReader,boolean,boolean,boolean,DirectoryFactory).mjava","sourceNew":"  public SolrIndexSearcher(SolrCore core, String path, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.path = path;\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","sourceOld":"  public SolrIndexSearcher(SolrCore core, IndexSchema schema, String name, DirectoryReader r, boolean closeReader, boolean enableCache, boolean reserveDirectory, DirectoryFactory directoryFactory) throws IOException {\n    super(r);\n    this.directoryFactory = directoryFactory;\n    this.reader = r;\n    this.atomicReader = SlowCompositeReaderWrapper.wrap(r);\n    this.core = core;\n    this.schema = schema;\n    this.name = \"Searcher@\" + Integer.toHexString(hashCode()) + (name!=null ? \" \"+name : \"\");\n    log.info(\"Opening \" + this.name);\n\n    Directory dir = r.directory();\n    \n    if (reserveDirectory) {\n      // keep the directory from being released while we use it\n      directoryFactory.incRef(dir);\n    }\n\n    this.closeReader = closeReader;\n    setSimilarity(schema.getSimilarity());\n\n    SolrConfig solrConfig = core.getSolrConfig();\n    queryResultWindowSize = solrConfig.queryResultWindowSize;\n    queryResultMaxDocsCached = solrConfig.queryResultMaxDocsCached;\n    useFilterForSortedQuery = solrConfig.useFilterForSortedQuery;\n    enableLazyFieldLoading = solrConfig.enableLazyFieldLoading;\n    \n    cachingEnabled=enableCache;\n    if (cachingEnabled) {\n      ArrayList<SolrCache> clist = new ArrayList<SolrCache>();\n      fieldValueCache = solrConfig.fieldValueCacheConfig==null ? null : solrConfig.fieldValueCacheConfig.newInstance();\n      if (fieldValueCache!=null) clist.add(fieldValueCache);\n      filterCache= solrConfig.filterCacheConfig==null ? null : solrConfig.filterCacheConfig.newInstance();\n      if (filterCache!=null) clist.add(filterCache);\n      queryResultCache = solrConfig.queryResultCacheConfig==null ? null : solrConfig.queryResultCacheConfig.newInstance();\n      if (queryResultCache!=null) clist.add(queryResultCache);\n      documentCache = solrConfig.documentCacheConfig==null ? null : solrConfig.documentCacheConfig.newInstance();\n      if (documentCache!=null) clist.add(documentCache);\n\n      if (solrConfig.userCacheConfigs == null) {\n        cacheMap = noGenericCaches;\n      } else {\n        cacheMap = new HashMap<String,SolrCache>(solrConfig.userCacheConfigs.length);\n        for (CacheConfig userCacheConfig : solrConfig.userCacheConfigs) {\n          SolrCache cache = null;\n          if (userCacheConfig != null) cache = userCacheConfig.newInstance();\n          if (cache != null) {\n            cacheMap.put(cache.name(), cache);\n            clist.add(cache);\n          }\n        }\n      }\n\n      cacheList = clist.toArray(new SolrCache[clist.size()]);\n    } else {\n      filterCache=null;\n      queryResultCache=null;\n      documentCache=null;\n      fieldValueCache=null;\n      cacheMap = noGenericCaches;\n      cacheList= noCaches;\n    }\n    \n    // TODO: This option has been dead/noop since 3.1, should we re-enable it?\n//    optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;\n    optimizer = null;\n    \n    fieldNames = new HashSet<String>();\n    fieldInfos = atomicReader.getFieldInfos();\n    for(FieldInfo fieldInfo : fieldInfos) {\n      fieldNames.add(fieldInfo.name);\n    }\n\n    // do this at the end since an exception in the constructor means we won't close    \n    numOpens.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","4b3d16cba9355e2e97962eb1c441bbd0b6735c15"],"04e7f30683f53928b2fce016e6430c9795caff22":["4a5469a71486c4c1e313c7fcb08188d7111195c2","b71270589e15ba8ded04828dc24cd7d9d5d7cdaf"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b71270589e15ba8ded04828dc24cd7d9d5d7cdaf":["4a5469a71486c4c1e313c7fcb08188d7111195c2"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["b71270589e15ba8ded04828dc24cd7d9d5d7cdaf"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","96d207426bd26fa5c1014e26d21d87603aea68b7"],"09c8567c25c02eeeb3e719841606a1269f3538ca":["4b3d16cba9355e2e97962eb1c441bbd0b6735c15","d0ce568448269aad19a317e537eefc0993934c9d"],"4b3d16cba9355e2e97962eb1c441bbd0b6735c15":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"4a5469a71486c4c1e313c7fcb08188d7111195c2":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4a5469a71486c4c1e313c7fcb08188d7111195c2","b71270589e15ba8ded04828dc24cd7d9d5d7cdaf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22659e4b60cbbd3c13216360578240ddeca2d8b4":["4a5469a71486c4c1e313c7fcb08188d7111195c2","b71270589e15ba8ded04828dc24cd7d9d5d7cdaf"],"f2126b84bd093fa3d921582a109a0ee578c28126":["b71270589e15ba8ded04828dc24cd7d9d5d7cdaf","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d0ce568448269aad19a317e537eefc0993934c9d"],"d0ce568448269aad19a317e537eefc0993934c9d":["4b3d16cba9355e2e97962eb1c441bbd0b6735c15"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"04e7f30683f53928b2fce016e6430c9795caff22":[],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"b71270589e15ba8ded04828dc24cd7d9d5d7cdaf":["04e7f30683f53928b2fce016e6430c9795caff22","d9405f486872f1e416304dfe389741f4ee2f8a4d","fe33227f6805edab2036cbb80645cc4e2d1fa424","22659e4b60cbbd3c13216360578240ddeca2d8b4","f2126b84bd093fa3d921582a109a0ee578c28126"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["4a5469a71486c4c1e313c7fcb08188d7111195c2"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4b3d16cba9355e2e97962eb1c441bbd0b6735c15","f2126b84bd093fa3d921582a109a0ee578c28126"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"09c8567c25c02eeeb3e719841606a1269f3538ca":[],"4b3d16cba9355e2e97962eb1c441bbd0b6735c15":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09c8567c25c02eeeb3e719841606a1269f3538ca","d0ce568448269aad19a317e537eefc0993934c9d"],"4a5469a71486c4c1e313c7fcb08188d7111195c2":["04e7f30683f53928b2fce016e6430c9795caff22","b71270589e15ba8ded04828dc24cd7d9d5d7cdaf","fe33227f6805edab2036cbb80645cc4e2d1fa424","22659e4b60cbbd3c13216360578240ddeca2d8b4"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["96d207426bd26fa5c1014e26d21d87603aea68b7","5cab9a86bd67202d20b6adc463008c8e982b070a"],"22659e4b60cbbd3c13216360578240ddeca2d8b4":[],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"d0ce568448269aad19a317e537eefc0993934c9d":["09c8567c25c02eeeb3e719841606a1269f3538ca","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","04e7f30683f53928b2fce016e6430c9795caff22","09c8567c25c02eeeb3e719841606a1269f3538ca","fe33227f6805edab2036cbb80645cc4e2d1fa424","22659e4b60cbbd3c13216360578240ddeca2d8b4","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}