{"path":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    // assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ce70cdb9511a671e0e15d4dc93b8334c86b6e681","072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    // assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    // assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fe8a5796aac9407e45e1b61a6b48615ab98759d","date":1329836859,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(\"leader\",\"true\",\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(\"leader\",\"true\",\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(\"leader\",\"true\",\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    // assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(\"leader\",\"true\",\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(\"leader\",\"true\",\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(\"leader\",\"true\",\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    // assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(\"leader\",\"true\",\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(\"leader\",\"true\",\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(\"leader\",\"true\",\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(\"leader\",\"true\",\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of it's own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrServer client0 = clients.get(0);\n    SolrServer client1 = clients.get(1);\n    SolrServer client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrServer client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","0fe8a5796aac9407e45e1b61a6b48615ab98759d"],"abb23fcc2461782ab204e61213240feb77d355aa":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bafca15d8e408346a67f4282ad1143b88023893b":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"0fe8a5796aac9407e45e1b61a6b48615ab98759d":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["0fe8a5796aac9407e45e1b61a6b48615ab98759d"]},"commit2Childs":{"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["bafca15d8e408346a67f4282ad1143b88023893b"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0fe8a5796aac9407e45e1b61a6b48615ab98759d"],"bafca15d8e408346a67f4282ad1143b88023893b":["abb23fcc2461782ab204e61213240feb77d355aa"],"0fe8a5796aac9407e45e1b61a6b48615ab98759d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d22ac6a4146774c1bc8400160fc0b6150294e92","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}