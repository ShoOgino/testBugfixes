{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","commits":[{"id":"5cad50ed6659649a0edef71b8cf56280b0bdadd7","date":1385496862,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecuive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label = new FacetLabel(uniqueValues[index], '/');\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label = new FacetLabel(uniqueValues[i], '/');\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecuive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label = new FacetLabel(uniqueValues[index], '/');\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label = new FacetLabel(uniqueValues[i], '/');\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe9946d3cd818d329255e4c325597ac3480503e","date":1385580921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      // nocommit remove\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecuive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label = new FacetLabel(uniqueValues[index], '/');\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label = new FacetLabel(uniqueValues[i], '/');\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd83550e4b0bdd36e7d9dca9273264100782440b","date":1385761753,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      // nocommit remove\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56d44586f4c409c6c6c5942b9f0227df806b7300","date":1386027853,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = FacetLabel.EMPTY;\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = _TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = TestUtil.getTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        Files.delete(f.toPath());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        assertTrue(f.delete());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    Path tmpDir = createTempDir(\"testLableToOrdinal\");\n    Path f = tmpDir.resolve(\"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        Files.delete(f);\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    File tmpDir = createTempDir(\"testLableToOrdinal\");\n    File f = new File(tmpDir, \"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        Files.delete(f.toPath());\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ae0982c0457fa3cfe0cda93a327c573fbe6f874","date":1507039114,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestUTF8TaxonomyWriterCache#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal#testL2O().mjava","sourceNew":"  public void testRandom() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    UTF8TaxonomyWriterCache cache = new UTF8TaxonomyWriterCache();\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    Set<String> uniqueValuesSet = new HashSet<>();\n    while (uniqueValuesSet.size() < numUniqueValues) {\n      int numParts = TestUtil.nextInt(random(), 1, 5);\n      StringBuilder b = new StringBuilder();\n      for (int i=0;i<numParts;i++) {\n          String part = null;\n          while (true) {\n            part = TestUtil.randomRealisticUnicodeString(random(), 16);\n            part = part.replace(\"/\", \"\");\n            if (part.length() > 0) {\n              break;\n            }\n          }\n\n          if (i > 0) {\n            b.append('/');\n          }\n          b.append(part);\n      }\n      uniqueValuesSet.add(b.toString());\n    }\n    String[] uniqueValues = uniqueValuesSet.toArray(new String[0]);\n\n    int ordUpto = 0;\n    for (int i = 0; i < n; i++) {\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = ordUpto++;\n        map.addLabel(label, ord1);\n        cache.put(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = cache.get(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testL2O() throws Exception {\n    LabelToOrdinal map = new LabelToOrdinalMap();\n\n    CompactLabelToOrdinal compact = new CompactLabelToOrdinal(2000000, 0.15f, 3);\n\n    final int n = atLeast(10 * 1000);\n    final int numUniqueValues = 50 * 1000;\n\n    String[] uniqueValues = new String[numUniqueValues];\n    byte[] buffer = new byte[50];\n\n    Random random = random();\n    for (int i = 0; i < numUniqueValues;) {\n      random.nextBytes(buffer);\n      int size = 1 + random.nextInt(buffer.length);\n\n      // This test is turning random bytes into a string,\n      // this is asking for trouble.\n      CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .onMalformedInput(CodingErrorAction.REPLACE);\n      uniqueValues[i] = decoder.decode(ByteBuffer.wrap(buffer, 0, size)).toString();\n      // we cannot have empty path components, so eliminate all prefix as well\n      // as middle consecutive delimiter chars.\n      uniqueValues[i] = uniqueValues[i].replaceAll(\"/+\", \"/\");\n      if (uniqueValues[i].startsWith(\"/\")) {\n        uniqueValues[i] = uniqueValues[i].substring(1);\n      }\n      if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {\n        i++;\n      }\n    }\n\n    Path tmpDir = createTempDir(\"testLableToOrdinal\");\n    Path f = tmpDir.resolve(\"CompactLabelToOrdinalTest.tmp\");\n    int flushInterval = 10;\n\n    for (int i = 0; i < n; i++) {\n      if (i > 0 && i % flushInterval == 0) {\n        compact.flush(f);    \n        compact = CompactLabelToOrdinal.open(f, 0.15f, 3);\n        Files.delete(f);\n        if (flushInterval < (n / 10)) {\n          flushInterval *= 10;\n        }\n      }\n\n      int index = random.nextInt(numUniqueValues);\n      FacetLabel label;\n      String s = uniqueValues[index];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n\n      assertEquals(ord1, ord2);\n\n      if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {\n        ord1 = compact.getNextOrdinal();\n        map.addLabel(label, ord1);\n        compact.addLabel(label, ord1);\n      }\n    }\n\n    for (int i = 0; i < numUniqueValues; i++) {\n      FacetLabel label;\n      String s = uniqueValues[i];\n      if (s.length() == 0) {\n        label = new FacetLabel();\n      } else {\n        label = new FacetLabel(s.split(\"/\"));\n      }\n      int ord1 = map.getOrdinal(label);\n      int ord2 = compact.getOrdinal(label);\n      assertEquals(ord1, ord2);\n    }\n  }\n\n","bugFix":null,"bugIntro":["f65fd14fae96cef54e47a1dd64e0066022091316"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["f4abec28b874149a7223e32cc7a01704c27790de"],"5eb2511ababf862ea11e10761c70ee560cd84510":["d0d579490a72f2e6297eaa648940611234c57cf1","7d89d7e4e5101347833eea558851bf4209218619"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["7d89d7e4e5101347833eea558851bf4209218619","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"f4abec28b874149a7223e32cc7a01704c27790de":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"7d89d7e4e5101347833eea558851bf4209218619":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d0d579490a72f2e6297eaa648940611234c57cf1":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["5eb2511ababf862ea11e10761c70ee560cd84510"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5cad50ed6659649a0edef71b8cf56280b0bdadd7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["bbe9946d3cd818d329255e4c325597ac3480503e"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","56d44586f4c409c6c6c5942b9f0227df806b7300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"bbe9946d3cd818d329255e4c325597ac3480503e":["5cad50ed6659649a0edef71b8cf56280b0bdadd7"]},"commit2Childs":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5eb2511ababf862ea11e10761c70ee560cd84510":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"6613659748fe4411a7dcf85266e55db1f95f7315":["7d89d7e4e5101347833eea558851bf4209218619","d0d579490a72f2e6297eaa648940611234c57cf1"],"f4abec28b874149a7223e32cc7a01704c27790de":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"d0d579490a72f2e6297eaa648940611234c57cf1":["5eb2511ababf862ea11e10761c70ee560cd84510"],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["f4abec28b874149a7223e32cc7a01704c27790de"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5cad50ed6659649a0edef71b8cf56280b0bdadd7","3cc728b07df73b197e6d940d27f9b08b63918f13"],"5cad50ed6659649a0edef71b8cf56280b0bdadd7":["bbe9946d3cd818d329255e4c325597ac3480503e"],"fd83550e4b0bdd36e7d9dca9273264100782440b":["56d44586f4c409c6c6c5942b9f0227df806b7300"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6613659748fe4411a7dcf85266e55db1f95f7315"],"bbe9946d3cd818d329255e4c325597ac3480503e":["fd83550e4b0bdd36e7d9dca9273264100782440b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}