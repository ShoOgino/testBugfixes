{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#writeBitSet(DocIdSetIterator,IndexOutput,byte).mjava","commits":[{"id":"03e17b020972a0d6e8d6823f545571a66646a167","date":1547847724,"type":0,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#writeBitSet(DocIdSetIterator,IndexOutput,byte).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Writes the docIDs from it to out, in logical blocks, one for each 65536 docIDs in monotonically\n   * increasing gap-less order.\n   * The caller must keep track of the number of jump-table entries (returned by this method) as well as the\n   * denseRankPower and provide them when constructing an IndexedDISI for reading.\n   * @param it  the document IDs.\n   * @param out destination for the blocks.\n   * @param denseRankPower for {@link Method#DENSE} blocks, a rank will be written every {@code 2^denseRankPower} docIDs.\n   *                       Values &lt; 7 (every 128 docIDs) or &gt; 15 (every 32768 docIDs) disables DENSE rank.\n   *                       Recommended values are 8-12: Every 256-4096 docIDs or 4-64 longs.\n   *                       {@link #DEFAULT_DENSE_RANK_POWER} is 9: Every 512 docIDs.\n   *                       This should be stored in meta and used when creating an instance of IndexedDISI.\n   * @throws IOException if there was an error writing to out.\n   * @return the number of jump-table entries following the blocks, -1 for no entries.\n   *         This should be stored in meta and used when creating an instance of IndexedDISI.\n   */\n  static short writeBitSet(DocIdSetIterator it, IndexOutput out, byte denseRankPower) throws IOException {\n    final long origo = out.getFilePointer(); // All jumps are relative to the origo\n    if ((denseRankPower < 7 || denseRankPower > 15) && denseRankPower != -1) {\n      throw new IllegalArgumentException(\"Acceptable values for denseRankPower are 7-15 (every 128-32768 docIDs). \" +\n          \"The provided power was \" + denseRankPower + \" (every \" + (int)Math.pow(2, denseRankPower) + \" docIDs)\");\n    }\n    int totalCardinality = 0;\n    int blockCardinality = 0;\n    final FixedBitSet buffer = new FixedBitSet(1<<16);\n    int[] jumps = new int[ArrayUtil.oversize(1, Integer.BYTES*2)];\n    int prevBlock = -1;\n    int jumpBlockIndex = 0;\n\n    for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n      final int block = doc >>> 16;\n      if (prevBlock != -1 && block != prevBlock) {\n        // Track offset+index from previous block up to current\n        jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n        jumpBlockIndex = prevBlock+1;\n        // Flush block\n        flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n        // Reset for next block\n        buffer.clear(0, buffer.length());\n        totalCardinality += blockCardinality;\n        blockCardinality = 0;\n      }\n      buffer.set(doc & 0xFFFF);\n      blockCardinality++;\n      prevBlock = block;\n    }\n    if (blockCardinality > 0) {\n      jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n      totalCardinality += blockCardinality;\n      flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n      buffer.clear(0, buffer.length());\n      prevBlock++;\n    }\n    final int lastBlock = prevBlock == -1 ? 0 : prevBlock; // There will always be at least 1 block (NO_MORE_DOCS)\n    // Last entry is a SPARSE with blockIndex == 32767 and the single entry 65535, which becomes the docID NO_MORE_DOCS\n    // To avoid creating 65K jump-table entries, only a single entry is created pointing to the offset of the\n    // NO_MORE_DOCS block, with the jumpBlockIndex set to the logical EMPTY block after all real blocks.\n    jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, lastBlock, lastBlock+1);\n    buffer.set(DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n    flush(DocIdSetIterator.NO_MORE_DOCS >>> 16, buffer, 1, denseRankPower, out);\n    // offset+index jump-table stored at the end\n    return flushBlockJumps(jumps, lastBlock+1, out, origo);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c89f1ef80a9432f4eabaeda9a1e135cd72e60836","date":1547972642,"type":0,"author":"Tommaso Teofili","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#writeBitSet(DocIdSetIterator,IndexOutput,byte).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Writes the docIDs from it to out, in logical blocks, one for each 65536 docIDs in monotonically\n   * increasing gap-less order.\n   * The caller must keep track of the number of jump-table entries (returned by this method) as well as the\n   * denseRankPower and provide them when constructing an IndexedDISI for reading.\n   * @param it  the document IDs.\n   * @param out destination for the blocks.\n   * @param denseRankPower for {@link Method#DENSE} blocks, a rank will be written every {@code 2^denseRankPower} docIDs.\n   *                       Values &lt; 7 (every 128 docIDs) or &gt; 15 (every 32768 docIDs) disables DENSE rank.\n   *                       Recommended values are 8-12: Every 256-4096 docIDs or 4-64 longs.\n   *                       {@link #DEFAULT_DENSE_RANK_POWER} is 9: Every 512 docIDs.\n   *                       This should be stored in meta and used when creating an instance of IndexedDISI.\n   * @throws IOException if there was an error writing to out.\n   * @return the number of jump-table entries following the blocks, -1 for no entries.\n   *         This should be stored in meta and used when creating an instance of IndexedDISI.\n   */\n  static short writeBitSet(DocIdSetIterator it, IndexOutput out, byte denseRankPower) throws IOException {\n    final long origo = out.getFilePointer(); // All jumps are relative to the origo\n    if ((denseRankPower < 7 || denseRankPower > 15) && denseRankPower != -1) {\n      throw new IllegalArgumentException(\"Acceptable values for denseRankPower are 7-15 (every 128-32768 docIDs). \" +\n          \"The provided power was \" + denseRankPower + \" (every \" + (int)Math.pow(2, denseRankPower) + \" docIDs)\");\n    }\n    int totalCardinality = 0;\n    int blockCardinality = 0;\n    final FixedBitSet buffer = new FixedBitSet(1<<16);\n    int[] jumps = new int[ArrayUtil.oversize(1, Integer.BYTES*2)];\n    int prevBlock = -1;\n    int jumpBlockIndex = 0;\n\n    for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n      final int block = doc >>> 16;\n      if (prevBlock != -1 && block != prevBlock) {\n        // Track offset+index from previous block up to current\n        jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n        jumpBlockIndex = prevBlock+1;\n        // Flush block\n        flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n        // Reset for next block\n        buffer.clear(0, buffer.length());\n        totalCardinality += blockCardinality;\n        blockCardinality = 0;\n      }\n      buffer.set(doc & 0xFFFF);\n      blockCardinality++;\n      prevBlock = block;\n    }\n    if (blockCardinality > 0) {\n      jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n      totalCardinality += blockCardinality;\n      flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n      buffer.clear(0, buffer.length());\n      prevBlock++;\n    }\n    final int lastBlock = prevBlock == -1 ? 0 : prevBlock; // There will always be at least 1 block (NO_MORE_DOCS)\n    // Last entry is a SPARSE with blockIndex == 32767 and the single entry 65535, which becomes the docID NO_MORE_DOCS\n    // To avoid creating 65K jump-table entries, only a single entry is created pointing to the offset of the\n    // NO_MORE_DOCS block, with the jumpBlockIndex set to the logical EMPTY block after all real blocks.\n    jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, lastBlock, lastBlock+1);\n    buffer.set(DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n    flush(DocIdSetIterator.NO_MORE_DOCS >>> 16, buffer, 1, denseRankPower, out);\n    // offset+index jump-table stored at the end\n    return flushBlockJumps(jumps, lastBlock+1, out, origo);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f94c392daa8f5708186bede16c84eafad4cdd2","date":1599578873,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#writeBitSet(DocIdSetIterator,IndexOutput,byte).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene80/IndexedDISI#writeBitSet(DocIdSetIterator,IndexOutput,byte).mjava","sourceNew":"  /**\n   * Writes the docIDs from it to out, in logical blocks, one for each 65536 docIDs in monotonically\n   * increasing gap-less order.\n   * The caller must keep track of the number of jump-table entries (returned by this method) as well as the\n   * denseRankPower and provide them when constructing an IndexedDISI for reading.\n   * @param it  the document IDs.\n   * @param out destination for the blocks.\n   * @param denseRankPower for {@link Method#DENSE} blocks, a rank will be written every {@code 2^denseRankPower} docIDs.\n   *                       Values &lt; 7 (every 128 docIDs) or &gt; 15 (every 32768 docIDs) disables DENSE rank.\n   *                       Recommended values are 8-12: Every 256-4096 docIDs or 4-64 longs.\n   *                       {@link #DEFAULT_DENSE_RANK_POWER} is 9: Every 512 docIDs.\n   *                       This should be stored in meta and used when creating an instance of IndexedDISI.\n   * @throws IOException if there was an error writing to out.\n   * @return the number of jump-table entries following the blocks, -1 for no entries.\n   *         This should be stored in meta and used when creating an instance of IndexedDISI.\n   */\n  static short writeBitSet(DocIdSetIterator it, IndexOutput out, byte denseRankPower) throws IOException {\n    final long origo = out.getFilePointer(); // All jumps are relative to the origo\n    if ((denseRankPower < 7 || denseRankPower > 15) && denseRankPower != -1) {\n      throw new IllegalArgumentException(\"Acceptable values for denseRankPower are 7-15 (every 128-32768 docIDs). \" +\n          \"The provided power was \" + denseRankPower + \" (every \" + (int)Math.pow(2, denseRankPower) + \" docIDs)\");\n    }\n    int totalCardinality = 0;\n    int blockCardinality = 0;\n    final FixedBitSet buffer = new FixedBitSet(1<<16);\n    int[] jumps = new int[ArrayUtil.oversize(1, Integer.BYTES*2)];\n    int prevBlock = -1;\n    int jumpBlockIndex = 0;\n\n    for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n      final int block = doc >>> 16;\n      if (prevBlock != -1 && block != prevBlock) {\n        // Track offset+index from previous block up to current\n        jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n        jumpBlockIndex = prevBlock+1;\n        // Flush block\n        flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n        // Reset for next block\n        buffer.clear(0, buffer.length());\n        totalCardinality += blockCardinality;\n        blockCardinality = 0;\n      }\n      buffer.set(doc & 0xFFFF);\n      blockCardinality++;\n      prevBlock = block;\n    }\n    if (blockCardinality > 0) {\n      jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n      totalCardinality += blockCardinality;\n      flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n      buffer.clear(0, buffer.length());\n      prevBlock++;\n    }\n    final int lastBlock = prevBlock == -1 ? 0 : prevBlock; // There will always be at least 1 block (NO_MORE_DOCS)\n    // Last entry is a SPARSE with blockIndex == 32767 and the single entry 65535, which becomes the docID NO_MORE_DOCS\n    // To avoid creating 65K jump-table entries, only a single entry is created pointing to the offset of the\n    // NO_MORE_DOCS block, with the jumpBlockIndex set to the logical EMPTY block after all real blocks.\n    jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, lastBlock, lastBlock+1);\n    buffer.set(DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n    flush(DocIdSetIterator.NO_MORE_DOCS >>> 16, buffer, 1, denseRankPower, out);\n    // offset+index jump-table stored at the end\n    return flushBlockJumps(jumps, lastBlock+1, out);\n  }\n\n","sourceOld":"  /**\n   * Writes the docIDs from it to out, in logical blocks, one for each 65536 docIDs in monotonically\n   * increasing gap-less order.\n   * The caller must keep track of the number of jump-table entries (returned by this method) as well as the\n   * denseRankPower and provide them when constructing an IndexedDISI for reading.\n   * @param it  the document IDs.\n   * @param out destination for the blocks.\n   * @param denseRankPower for {@link Method#DENSE} blocks, a rank will be written every {@code 2^denseRankPower} docIDs.\n   *                       Values &lt; 7 (every 128 docIDs) or &gt; 15 (every 32768 docIDs) disables DENSE rank.\n   *                       Recommended values are 8-12: Every 256-4096 docIDs or 4-64 longs.\n   *                       {@link #DEFAULT_DENSE_RANK_POWER} is 9: Every 512 docIDs.\n   *                       This should be stored in meta and used when creating an instance of IndexedDISI.\n   * @throws IOException if there was an error writing to out.\n   * @return the number of jump-table entries following the blocks, -1 for no entries.\n   *         This should be stored in meta and used when creating an instance of IndexedDISI.\n   */\n  static short writeBitSet(DocIdSetIterator it, IndexOutput out, byte denseRankPower) throws IOException {\n    final long origo = out.getFilePointer(); // All jumps are relative to the origo\n    if ((denseRankPower < 7 || denseRankPower > 15) && denseRankPower != -1) {\n      throw new IllegalArgumentException(\"Acceptable values for denseRankPower are 7-15 (every 128-32768 docIDs). \" +\n          \"The provided power was \" + denseRankPower + \" (every \" + (int)Math.pow(2, denseRankPower) + \" docIDs)\");\n    }\n    int totalCardinality = 0;\n    int blockCardinality = 0;\n    final FixedBitSet buffer = new FixedBitSet(1<<16);\n    int[] jumps = new int[ArrayUtil.oversize(1, Integer.BYTES*2)];\n    int prevBlock = -1;\n    int jumpBlockIndex = 0;\n\n    for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n      final int block = doc >>> 16;\n      if (prevBlock != -1 && block != prevBlock) {\n        // Track offset+index from previous block up to current\n        jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n        jumpBlockIndex = prevBlock+1;\n        // Flush block\n        flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n        // Reset for next block\n        buffer.clear(0, buffer.length());\n        totalCardinality += blockCardinality;\n        blockCardinality = 0;\n      }\n      buffer.set(doc & 0xFFFF);\n      blockCardinality++;\n      prevBlock = block;\n    }\n    if (blockCardinality > 0) {\n      jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, jumpBlockIndex, prevBlock+1);\n      totalCardinality += blockCardinality;\n      flush(prevBlock, buffer, blockCardinality, denseRankPower, out);\n      buffer.clear(0, buffer.length());\n      prevBlock++;\n    }\n    final int lastBlock = prevBlock == -1 ? 0 : prevBlock; // There will always be at least 1 block (NO_MORE_DOCS)\n    // Last entry is a SPARSE with blockIndex == 32767 and the single entry 65535, which becomes the docID NO_MORE_DOCS\n    // To avoid creating 65K jump-table entries, only a single entry is created pointing to the offset of the\n    // NO_MORE_DOCS block, with the jumpBlockIndex set to the logical EMPTY block after all real blocks.\n    jumps = addJumps(jumps, out.getFilePointer()-origo, totalCardinality, lastBlock, lastBlock+1);\n    buffer.set(DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n    flush(DocIdSetIterator.NO_MORE_DOCS >>> 16, buffer, 1, denseRankPower, out);\n    // offset+index jump-table stored at the end\n    return flushBlockJumps(jumps, lastBlock+1, out, origo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"03e17b020972a0d6e8d6823f545571a66646a167":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","03e17b020972a0d6e8d6823f545571a66646a167"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["03e17b020972a0d6e8d6823f545571a66646a167"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9f94c392daa8f5708186bede16c84eafad4cdd2"]},"commit2Childs":{"03e17b020972a0d6e8d6823f545571a66646a167":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","c9f94c392daa8f5708186bede16c84eafad4cdd2"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":[],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["03e17b020972a0d6e8d6823f545571a66646a167","c89f1ef80a9432f4eabaeda9a1e135cd72e60836"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}