{"path":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","commits":[{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (context.ord == 0) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (cacheEntryHasReasonableWorstCaseSize(ReaderUtil.getTopLevelContext(context).reader().maxDoc())\n            && policy.shouldCache(in.getQuery(), context)) {\n          final Scorer scorer = in.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n      if (context.ord == 0) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (cacheEntryHasReasonableWorstCaseSize(ReaderUtil.getTopLevelContext(context).reader().maxDoc())\n            && policy.shouldCache(in.getQuery(), context)) {\n          final Scorer scorer = in.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context, acceptDocs);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      // we apply acceptDocs as an approximation\n      if (acceptDocs == null) {\n        return new ConstantScoreScorer(this, 0f, disi);\n      } else {\n        final TwoPhaseIterator twoPhaseView = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            final int doc = approximation.docID();\n            return acceptDocs.get(doc);\n          }\n        };\n        return new ConstantScoreScorer(this, 0f, twoPhaseView);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0bf09e549fa47b894ce44baafdf8031eba2445c6","date":1436204317,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (cacheEntryHasReasonableWorstCaseSize(ReaderUtil.getTopLevelContext(context).reader().maxDoc())\n            && policy.shouldCache(in.getQuery(), context)) {\n          final Scorer scorer = in.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (context.ord == 0) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (cacheEntryHasReasonableWorstCaseSize(ReaderUtil.getTopLevelContext(context).reader().maxDoc())\n            && policy.shouldCache(in.getQuery(), context)) {\n          final Scorer scorer = in.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"bugIntro":["0e98a4d8e18e7296a274ca283df84a76544bd753"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"631e24c389c59f74b6d125a2a4cb909d6fbfa356","date":1445957240,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (shouldCache(context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (cacheEntryHasReasonableWorstCaseSize(ReaderUtil.getTopLevelContext(context).reader().maxDoc())\n            && policy.shouldCache(in.getQuery(), context)) {\n          final Scorer scorer = in.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"bugIntro":["0e98a4d8e18e7296a274ca283df84a76544bd753"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aac61ee5b4492f174e60bd54939aba9539906edf","date":1461245473,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery(), context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (shouldCache(context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":null,"bugIntro":["0e98a4d8e18e7296a274ca283df84a76544bd753"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25f40dbcd244dc82447a23719db34376cdcc9cfe","date":1461323366,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery(), context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":null,"bugIntro":["0e98a4d8e18e7296a274ca283df84a76544bd753"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa","date":1461326984,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":null,"bugIntro":["0e98a4d8e18e7296a274ca283df84a76544bd753"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet = get(in.getQuery(), context);\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery(), context)) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":null,"bugIntro":["0e98a4d8e18e7296a274ca283df84a76544bd753"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","date":1491224823,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(false);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e98a4d8e18e7296a274ca283df84a76544bd753","date":1491296430,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(false);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorer(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorer(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorer(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorer(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ConstantScoreScorer(this, 0f, disi);\n    }\n\n","bugFix":["0f4464508ee83288c8c4585b533f9faaa93aa314","aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa","631e24c389c59f74b6d125a2a4cb909d6fbfa356","d211216c83f01894810543d1c107160a9ae3650b","25f40dbcd244dc82447a23719db34376cdcc9cfe","0bf09e549fa47b894ce44baafdf8031eba2445c6","aac61ee5b4492f174e60bd54939aba9539906edf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24f3e9c0fc20b3107388ec853a6fbad9f891b461","date":1502359844,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(Long.MAX_VALUE);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(false);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d6ba405c7c8192661bdf7ce782181d12f3162a6","date":1502361392,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(Long.MAX_VALUE);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(false);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(Long.MAX_VALUE);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(false);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(Long.MAX_VALUE);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      ScorerSupplier scorerSupplier = scorerSupplier(context);\n      if (scorerSupplier == null) {\n        return null;\n      }\n      return scorerSupplier.get(false);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"24f3e9c0fc20b3107388ec853a6fbad9f891b461":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b"],"aac61ee5b4492f174e60bd54939aba9539906edf":["631e24c389c59f74b6d125a2a4cb909d6fbfa356"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["aac61ee5b4492f174e60bd54939aba9539906edf","aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7d6ba405c7c8192661bdf7ce782181d12f3162a6":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","24f3e9c0fc20b3107388ec853a6fbad9f891b461"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"0bf09e549fa47b894ce44baafdf8031eba2445c6":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"d211216c83f01894810543d1c107160a9ae3650b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"631e24c389c59f74b6d125a2a4cb909d6fbfa356":["0bf09e549fa47b894ce44baafdf8031eba2445c6"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["0e98a4d8e18e7296a274ca283df84a76544bd753","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b":["d211216c83f01894810543d1c107160a9ae3650b"],"25f40dbcd244dc82447a23719db34376cdcc9cfe":["aac61ee5b4492f174e60bd54939aba9539906edf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa":["25f40dbcd244dc82447a23719db34376cdcc9cfe"],"0e98a4d8e18e7296a274ca283df84a76544bd753":["d211216c83f01894810543d1c107160a9ae3650b"]},"commit2Childs":{"24f3e9c0fc20b3107388ec853a6fbad9f891b461":["7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"aac61ee5b4492f174e60bd54939aba9539906edf":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","25f40dbcd244dc82447a23719db34376cdcc9cfe"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["d211216c83f01894810543d1c107160a9ae3650b"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0bf09e549fa47b894ce44baafdf8031eba2445c6"],"7d6ba405c7c8192661bdf7ce782181d12f3162a6":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"0bf09e549fa47b894ce44baafdf8031eba2445c6":["631e24c389c59f74b6d125a2a4cb909d6fbfa356"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"d211216c83f01894810543d1c107160a9ae3650b":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","0e98a4d8e18e7296a274ca283df84a76544bd753"],"631e24c389c59f74b6d125a2a4cb909d6fbfa356":["aac61ee5b4492f174e60bd54939aba9539906edf"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b":["24f3e9c0fc20b3107388ec853a6fbad9f891b461","7d6ba405c7c8192661bdf7ce782181d12f3162a6","58884af1f68e9d61c217c753fbd6266d86a63b14"],"25f40dbcd244dc82447a23719db34376cdcc9cfe":["aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa"],"aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"0e98a4d8e18e7296a274ca283df84a76544bd753":["93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}