{"path":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica],SolrClient).mjava","commits":[{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":1,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica],SolrClient).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders, SolrClient solrClient) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","sourceOld":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica],SolrClient).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLowerTerm(String,String,ZkController,Replica,List[Replica],SolrClient).mjava","sourceNew":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders, SolrClient solrClient) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Killing leader for shard1 of {} on node {}\", collectionName, leader.getNodeName());\n    }\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","sourceOld":"  private void putNonLeadersIntoLowerTerm(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders, SolrClient solrClient) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n    getProxyForReplica(leader).close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    sendDoc(2, null, leaderJetty);\n    \n    for (Replica replica : notLeaders) {\n      waitForState(collectionName, replica.getName(), State.DOWN, 60000);\n    }\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    leaderJetty.stop();\n\n    // Wait for a steady state, till the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (Replica replica : clusterState.getCollection(collectionName).getSlice(shard).getReplicas()) {\n        if (replica.getState() != State.DOWN) {\n          allDown = false;\n        }\n      }\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      Thread.sleep(1000);\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, shard, cloudClient.getZkStateReader().getZkClient())) {\n      for (Replica notLeader : notLeaders) {\n        assertTrue(zkShardTerms.getTerm(leader.getName()) > zkShardTerms.getTerm(notLeader.getName()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}