{"path":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","commits":[{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"/dev/null","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.min);\n      if (cur == null) {\n        endsMap.put(range.min, 1);\n      } else {\n        endsMap.put(range.min, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.max);\n      if (cur == null) {\n        endsMap.put(range.max, 2);\n      } else {\n        endsMap.put(range.max, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","bugFix":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.min);\n      if (cur == null) {\n        endsMap.put(range.min, 1);\n      } else {\n        endsMap.put(range.min, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.max);\n      if (cur == null) {\n        endsMap.put(range.max, 2);\n      } else {\n        endsMap.put(range.max, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.min);\n      if (cur == null) {\n        endsMap.put(range.min, 1);\n      } else {\n        endsMap.put(range.min, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.max);\n      if (cur == null) {\n        endsMap.put(range.max, 2);\n      } else {\n        endsMap.put(range.max, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4edc984f0f4ac77c37e48ace2932f780f888453c"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c422e924212367b334b4938f1fd3e44438e88c40"],"c422e924212367b334b4938f1fd3e44438e88c40":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4edc984f0f4ac77c37e48ace2932f780f888453c","3cc728b07df73b197e6d940d27f9b08b63918f13"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c422e924212367b334b4938f1fd3e44438e88c40":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}