{"path":"backwards/src/java/org/apache/lucene/index/IndexWriter#resolveExternalSegments().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/index/IndexWriter#resolveExternalSegments().mjava","pathOld":"/dev/null","sourceNew":"  /* If any of our segments are using a directory != ours\n   * then we have to either copy them over one by one, merge\n   * them (if merge policy has chosen to) or wait until\n   * currently running merges (in the background) complete.\n   * We don't return until the SegmentInfos has no more\n   * external segments.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void resolveExternalSegments() throws CorruptIndexException, IOException {\n\n    boolean any = false;\n\n    boolean done = false;\n\n    while(!done) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n\n        if (stopMerges)\n          throw new MergePolicy.MergeAbortedException(\"rollback() was called or addIndexes* hit an unhandled exception\");\n\n        final int numSegments = segmentInfos.size();\n\n        done = true;\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            done = false;\n            final MergePolicy.OneMerge newMerge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), mergePolicy instanceof LogMergePolicy && getUseCompoundFile());\n\n            // Returns true if no running merge conflicts\n            // with this one (and, records this merge as\n            // pending), ie, this segment is not currently\n            // being merged:\n            if (registerMerge(newMerge)) {\n              merge = newMerge;\n\n              // If this segment is not currently being\n              // merged, then advance it to running & run\n              // the merge ourself (below):\n              pendingMerges.remove(merge);\n              runningMerges.add(merge);\n              break;\n            }\n          }\n        }\n\n        if (!done && merge == null)\n          // We are not yet done (external segments still\n          // exist in segmentInfos), yet, all such segments\n          // are currently \"covered\" by a pending or running\n          // merge.  We now try to grab any pending merge\n          // that involves external segments:\n          merge = getNextExternalMerge();\n\n        if (!done && merge == null)\n          // We are not yet done, and, all external segments\n          // fall under merges that the merge scheduler is\n          // currently running.  So, we now wait and check\n          // back to see if the merge has completed.\n          doWait();\n      }\n\n      if (merge != null) {\n        any = true;\n        merge(merge);\n      }\n    }\n\n    if (any)\n      // Sometimes, on copying an external segment over,\n      // more merges may become necessary:\n      mergeScheduler.merge(this);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/index/IndexWriter#resolveExternalSegments().mjava","pathOld":"backwards/src/java/org/apache/lucene/index/IndexWriter#resolveExternalSegments().mjava","sourceNew":"  /* If any of our segments are using a directory != ours\n   * then we have to either copy them over one by one, merge\n   * them (if merge policy has chosen to) or wait until\n   * currently running merges (in the background) complete.\n   * We don't return until the SegmentInfos has no more\n   * external segments.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void resolveExternalSegments() throws CorruptIndexException, IOException {\n\n    boolean any = false;\n\n    boolean done = false;\n\n    while(!done) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n\n        if (stopMerges)\n          throw new MergePolicy.MergeAbortedException(\"rollback() was called or addIndexes* hit an unhandled exception\");\n\n        final int numSegments = segmentInfos.size();\n\n        done = true;\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            done = false;\n            final MergePolicy.OneMerge newMerge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), mergePolicy instanceof LogMergePolicy && getUseCompoundFile());\n\n            // Returns true if no running merge conflicts\n            // with this one (and, records this merge as\n            // pending), ie, this segment is not currently\n            // being merged:\n            if (registerMerge(newMerge)) {\n              merge = newMerge;\n\n              // If this segment is not currently being\n              // merged, then advance it to running & run\n              // the merge ourself (below):\n              pendingMerges.remove(merge);\n              runningMerges.add(merge);\n              break;\n            }\n          }\n        }\n\n        if (!done && merge == null)\n          // We are not yet done (external segments still\n          // exist in segmentInfos), yet, all such segments\n          // are currently \"covered\" by a pending or running\n          // merge.  We now try to grab any pending merge\n          // that involves external segments:\n          merge = getNextExternalMerge();\n\n        if (!done && merge == null)\n          // We are not yet done, and, all external segments\n          // fall under merges that the merge scheduler is\n          // currently running.  So, we now wait and check\n          // back to see if the merge has completed.\n          doWait();\n      }\n\n      if (merge != null) {\n        any = true;\n        merge(merge);\n      }\n    }\n\n    if (any)\n      // Sometimes, on copying an external segment over,\n      // more merges may become necessary:\n      mergeScheduler.merge(this);\n  }\n\n","sourceOld":"  /* If any of our segments are using a directory != ours\n   * then we have to either copy them over one by one, merge\n   * them (if merge policy has chosen to) or wait until\n   * currently running merges (in the background) complete.\n   * We don't return until the SegmentInfos has no more\n   * external segments.  Currently this is only used by\n   * addIndexesNoOptimize(). */\n  private void resolveExternalSegments() throws CorruptIndexException, IOException {\n\n    boolean any = false;\n\n    boolean done = false;\n\n    while(!done) {\n      SegmentInfo info = null;\n      MergePolicy.OneMerge merge = null;\n      synchronized(this) {\n\n        if (stopMerges)\n          throw new MergePolicy.MergeAbortedException(\"rollback() was called or addIndexes* hit an unhandled exception\");\n\n        final int numSegments = segmentInfos.size();\n\n        done = true;\n        for(int i=0;i<numSegments;i++) {\n          info = segmentInfos.info(i);\n          if (info.dir != directory) {\n            done = false;\n            final MergePolicy.OneMerge newMerge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), mergePolicy instanceof LogMergePolicy && getUseCompoundFile());\n\n            // Returns true if no running merge conflicts\n            // with this one (and, records this merge as\n            // pending), ie, this segment is not currently\n            // being merged:\n            if (registerMerge(newMerge)) {\n              merge = newMerge;\n\n              // If this segment is not currently being\n              // merged, then advance it to running & run\n              // the merge ourself (below):\n              pendingMerges.remove(merge);\n              runningMerges.add(merge);\n              break;\n            }\n          }\n        }\n\n        if (!done && merge == null)\n          // We are not yet done (external segments still\n          // exist in segmentInfos), yet, all such segments\n          // are currently \"covered\" by a pending or running\n          // merge.  We now try to grab any pending merge\n          // that involves external segments:\n          merge = getNextExternalMerge();\n\n        if (!done && merge == null)\n          // We are not yet done, and, all external segments\n          // fall under merges that the merge scheduler is\n          // currently running.  So, we now wait and check\n          // back to see if the merge has completed.\n          doWait();\n      }\n\n      if (merge != null) {\n        any = true;\n        merge(merge);\n      }\n    }\n\n    if (any)\n      // Sometimes, on copying an external segment over,\n      // more merges may become necessary:\n      mergeScheduler.merge(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}