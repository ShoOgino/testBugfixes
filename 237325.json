{"path":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","pathOld":"src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","sourceNew":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String randomLockName = \"lucene-\" + Long.toString(new Random().nextInt(), Character.MAX_RADIX) + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","sourceOld":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String randomLockName = \"lucene-\" + Long.toString(new Random().nextInt(), Character.MAX_RADIX) + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91425189981f3694858ce3b8637bc8aa0502e79a","date":1272950709,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","pathOld":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","sourceNew":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a..zA..Z0..9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","sourceOld":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String randomLockName = \"lucene-\" + Long.toString(new Random().nextInt(), Character.MAX_RADIX) + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"084efdaf16d05aee81404bb2e1c21418161009c6","date":1277303511,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","pathOld":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","sourceNew":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a-zA-Z0-9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","sourceOld":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a..zA..Z0..9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","pathOld":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","sourceNew":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a-zA-Z0-9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","sourceOld":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a..zA..Z0..9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c90a5bf3cd9fce48a2355ec610f611becf791c6","date":1286441172,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","sourceNew":null,"sourceOld":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a-zA-Z0-9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/store/NativeFSLockFactory#acquireTestLock().mjava","sourceNew":null,"sourceOld":"  // Simple test to verify locking system is \"working\".  On\n  // NFS, if it's misconfigured, you can hit long (35\n  // second) timeouts which cause Lock.obtain to take far\n  // too long (it assumes the obtain() call takes zero\n  // time). \n  private synchronized void acquireTestLock() {\n    if (tested) return;\n    tested = true;\n    \n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new RuntimeException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new RuntimeException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    // add the RuntimeMXBean's name to the lock file, to reduce the chance for\n    // name collisions when this code is invoked by multiple JVMs (such as in\n    // our tests). On most systems, the name includes the process Id.\n    // Also, remove any non-alphanumeric characters, so that the lock file will\n    // be created for sure on all systems.\n    String randomLockName = \"lucene-\"\n        + ManagementFactory.getRuntimeMXBean().getName().replaceAll(\"[^a-zA-Z0-9]+\",\"\") + \"-\"\n        + Long.toString(new Random().nextInt(), Character.MAX_RADIX)\n        + \"-test.lock\";\n    \n    Lock l = makeLock(randomLockName);\n    try {\n      l.obtain();\n      l.release();\n      // If the test lock failed to delete after all the attempts, attempt a\n      // delete when the JVM exits.\n      File lockFile = new File(lockDir, randomLockName);\n      if (lockFile.exists()) {\n        lockFile.deleteOnExit();\n      }\n    } catch (IOException e) {\n      RuntimeException e2 = new RuntimeException(\"Failed to acquire random test lock; please verify filesystem for lock directory '\" + lockDir + \"' supports locking\");\n      e2.initCause(e);\n      throw e2;\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5c90a5bf3cd9fce48a2355ec610f611becf791c6":["084efdaf16d05aee81404bb2e1c21418161009c6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91425189981f3694858ce3b8637bc8aa0502e79a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["91425189981f3694858ce3b8637bc8aa0502e79a","084efdaf16d05aee81404bb2e1c21418161009c6"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","5c90a5bf3cd9fce48a2355ec610f611becf791c6"],"084efdaf16d05aee81404bb2e1c21418161009c6":["91425189981f3694858ce3b8637bc8aa0502e79a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c90a5bf3cd9fce48a2355ec610f611becf791c6"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5c90a5bf3cd9fce48a2355ec610f611becf791c6":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"91425189981f3694858ce3b8637bc8aa0502e79a":["5f4e87790277826a2aea119328600dfb07761f32","084efdaf16d05aee81404bb2e1c21418161009c6"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"084efdaf16d05aee81404bb2e1c21418161009c6":["5c90a5bf3cd9fce48a2355ec610f611becf791c6","5f4e87790277826a2aea119328600dfb07761f32"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["91425189981f3694858ce3b8637bc8aa0502e79a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}