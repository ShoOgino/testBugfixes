{"path":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","commits":[{"id":"69227e655c7a72315c68e596f0a899f339b1ec2b","date":1340137626,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but also to record \n   * the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEquals\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n    qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd9ddb59e9d33950773d186a8b726b5610ae3aad","date":1341258232,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but also to record \n   * the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n    qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but also to record \n   * the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEquals\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n    qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but also to record \n   * the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n    qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but also to record \n   * the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEquals\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n    qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef","date":1363025664,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but also to record \n   * the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n    qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":["69227e655c7a72315c68e596f0a899f339b1ec2b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a91f19e3f7576973404e13b7ecfb8ae94f313921","date":1511358452,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = QParser.getParser(inputs[i], defType, true, req).getQuery();\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4aee4980038a10791618ea04e79233ce5cbf6607","date":1511366888,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = QParser.getParser(inputs[i], defType, true, req).getQuery();\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = (QParser.getParser(inputs[i], defType, req).getQuery());\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a18e3c53fdd9e2e8f2bdb3b21ca3964273a2b5b0","date":1576656084,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is\n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = QParser.getParser(inputs[i], defType, true, req).getQuery();\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query\n      // is equal to itself, and that the quality checks work regardless\n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = QParser.getParser(inputs[i], defType, true, req).getQuery();\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"246314af59d76a47fccc31e9494eefee01ec9c00","date":1576657955,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/QueryEqualityTest#assertQueryEquals(String,SolrQueryRequest,String...).mjava","sourceNew":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is\n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = QParser.getParser(inputs[i], defType, true, req).getQuery();\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query\n      // is equal to itself, and that the quality checks work regardless\n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * NOTE: defType is not only used to pick the parser, but, if non-null it is \n   * also to record the parser being tested for coverage sanity checking\n   *\n   * @see QueryUtils#check\n   * @see QueryUtils#checkEqual\n   * @see #testParserCoverage\n   */\n  protected void assertQueryEquals(final String defType,\n                                   final SolrQueryRequest req,\n                                   final String... inputs) throws Exception {\n\n    if (null != defType) qParsersTested.add(defType);\n\n    final Query[] queries = new Query[inputs.length];\n\n    try {\n      SolrQueryResponse rsp = new SolrQueryResponse();\n      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));\n      for (int i = 0; i < inputs.length; i++) {\n        queries[i] = QParser.getParser(inputs[i], defType, true, req).getQuery();\n      }\n    } finally {\n      SolrRequestInfo.clearRequestInfo();\n    }\n\n    for (int i = 0; i < queries.length; i++) {\n      QueryUtils.check(queries[i]);\n      // yes starting j=0 is redundent, we're making sure every query \n      // is equal to itself, and that the quality checks work regardless \n      // of which caller/callee is used.\n      for (int j = 0; j < queries.length; j++) {\n        QueryUtils.checkEqual(queries[i], queries[j]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"246314af59d76a47fccc31e9494eefee01ec9c00":["4aee4980038a10791618ea04e79233ce5cbf6607","a18e3c53fdd9e2e8f2bdb3b21ca3964273a2b5b0"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["69227e655c7a72315c68e596f0a899f339b1ec2b"],"69227e655c7a72315c68e596f0a899f339b1ec2b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["69227e655c7a72315c68e596f0a899f339b1ec2b","bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4aee4980038a10791618ea04e79233ce5cbf6607":["d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef","a91f19e3f7576973404e13b7ecfb8ae94f313921"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef"],"d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef":["bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"a18e3c53fdd9e2e8f2bdb3b21ca3964273a2b5b0":["4aee4980038a10791618ea04e79233ce5cbf6607"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a18e3c53fdd9e2e8f2bdb3b21ca3964273a2b5b0"]},"commit2Childs":{"246314af59d76a47fccc31e9494eefee01ec9c00":[],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef"],"69227e655c7a72315c68e596f0a899f339b1ec2b":["bd9ddb59e9d33950773d186a8b726b5610ae3aad","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["69227e655c7a72315c68e596f0a899f339b1ec2b"],"4aee4980038a10791618ea04e79233ce5cbf6607":["246314af59d76a47fccc31e9494eefee01ec9c00","a18e3c53fdd9e2e8f2bdb3b21ca3964273a2b5b0"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["4aee4980038a10791618ea04e79233ce5cbf6607"],"d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef":["4aee4980038a10791618ea04e79233ce5cbf6607","a91f19e3f7576973404e13b7ecfb8ae94f313921"],"a18e3c53fdd9e2e8f2bdb3b21ca3964273a2b5b0":["246314af59d76a47fccc31e9494eefee01ec9c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["246314af59d76a47fccc31e9494eefee01ec9c00","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}