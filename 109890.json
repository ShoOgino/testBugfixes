{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","commits":[{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters. If {@code collections} is null, then the {@code alias} is removed, otherwise it is added/updated.\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    Map<String,String> newCollectionMap = new HashMap<>(getCollectionAliasMap());\n    if (collections == null) {\n      newCollectionMap.remove(alias);\n    } else {\n      newCollectionMap.put(alias, collections);\n    }\n    if (newCollectionMap.isEmpty()) {\n      return EMPTY;\n    } else {\n      return new Aliases(Collections.singletonMap(\"collection\", newCollectionMap));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"215e40821821b2df2e69355e208532c05ef095a5","date":1510858642,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","sourceNew":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColMetadata;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColMetadata = new LinkedHashMap<>(this.collectionAliasMetadata);//clone to modify\n      newColMetadata.remove(alias);\n      newColAliases.remove(alias);\n    } else {\n      newColMetadata = this.collectionAliasMetadata;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColMetadata, zNodeVersion);\n  }\n\n","sourceOld":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters. If {@code collections} is null, then the {@code alias} is removed, otherwise it is added/updated.\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    Map<String,String> newCollectionMap = new HashMap<>(getCollectionAliasMap());\n    if (collections == null) {\n      newCollectionMap.remove(alias);\n    } else {\n      newCollectionMap.put(alias, collections);\n    }\n    if (newCollectionMap.isEmpty()) {\n      return EMPTY;\n    } else {\n      return new Aliases(Collections.singletonMap(\"collection\", newCollectionMap));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767","date":1520865397,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","sourceNew":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColProperties;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);//clone to modify\n      newColProperties.remove(alias);\n      newColAliases.remove(alias);\n    } else {\n      newColProperties = this.collectionAliasProperties;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","sourceOld":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColMetadata;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColMetadata = new LinkedHashMap<>(this.collectionAliasMetadata);//clone to modify\n      newColMetadata.remove(alias);\n      newColAliases.remove(alias);\n    } else {\n      newColMetadata = this.collectionAliasMetadata;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColMetadata, zNodeVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","sourceNew":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColProperties;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);//clone to modify\n      newColProperties.remove(alias);\n      newColAliases.remove(alias);\n      // remove second-level alias from compound aliases\n      for (Map.Entry<String, List<String>> entry : newColAliases.entrySet()) {\n        List<String> list = entry.getValue();\n        if (list.contains(alias)) {\n          list = new ArrayList<>(list);\n          list.remove(alias);\n          entry.setValue(Collections.unmodifiableList(list));\n        }\n      }\n    } else {\n      newColProperties = this.collectionAliasProperties;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","sourceOld":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColProperties;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);//clone to modify\n      newColProperties.remove(alias);\n      newColAliases.remove(alias);\n    } else {\n      newColProperties = this.collectionAliasProperties;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6e5eb1137994855cee975febe08850fcb7726d3","date":1558358375,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithCollectionAlias(String,String).mjava","sourceNew":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColProperties;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);//clone to modify\n      newColProperties.remove(alias);\n      newColAliases.remove(alias);\n      // remove second-level alias from compound aliases\n      for (Map.Entry<String, List<String>> entry : newColAliases.entrySet()) {\n        List<String> list = entry.getValue();\n        if (list.contains(alias)) {\n          list = new ArrayList<>(list);\n          list.remove(alias);\n          entry.setValue(Collections.unmodifiableList(list));\n        }\n      }\n      newColAliases.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n    } else {\n      newColProperties = this.collectionAliasProperties;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","sourceOld":"  /**\n   * Creates a new Aliases instance with the same data as the current one but with a modification based on the\n   * parameters.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param alias       the alias to update, must not be null\n   * @param collections the comma separated list of collections for the alias, null to remove the alias\n   */\n  public Aliases cloneWithCollectionAlias(String alias, String collections) {\n    if (alias == null) {\n      throw new NullPointerException(\"Alias name cannot be null\");\n    }\n    Map<String, Map<String, String>> newColProperties;\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    if (collections == null) { // REMOVE:\n      newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);//clone to modify\n      newColProperties.remove(alias);\n      newColAliases.remove(alias);\n      // remove second-level alias from compound aliases\n      for (Map.Entry<String, List<String>> entry : newColAliases.entrySet()) {\n        List<String> list = entry.getValue();\n        if (list.contains(alias)) {\n          list = new ArrayList<>(list);\n          list.remove(alias);\n          entry.setValue(Collections.unmodifiableList(list));\n        }\n      }\n    } else {\n      newColProperties = this.collectionAliasProperties;// no changes\n      // java representation is a list, so split before adding to maintain consistency\n      newColAliases.put(alias, splitCollections(collections)); // note: unmodifiableList\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["215e40821821b2df2e69355e208532c05ef095a5"],"215e40821821b2df2e69355e208532c05ef095a5":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"b6e5eb1137994855cee975febe08850fcb7726d3":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6e5eb1137994855cee975febe08850fcb7726d3"]},"commit2Childs":{"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"215e40821821b2df2e69355e208532c05ef095a5":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["215e40821821b2df2e69355e208532c05ef095a5"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["b6e5eb1137994855cee975febe08850fcb7726d3"],"b6e5eb1137994855cee975febe08850fcb7726d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}