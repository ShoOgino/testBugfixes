{"path":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever#highlightDocument(LeafReaderContext,int,FieldValueProvider,Predicate[String],Map[String,List[OffsetRange]]).mjava","commits":[{"id":"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c","date":1597407672,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever#highlightDocument(LeafReaderContext,int,FieldValueProvider,Predicate[String],Map[String,List[OffsetRange]]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Low-level method for retrieving hit ranges for a single document. This method can be used with\n   * custom document {@link FieldValueProvider}.\n   */\n  public void highlightDocument(\n      LeafReaderContext leafReaderContext,\n      int contextDocId,\n      FieldValueProvider doc,\n      Predicate<String> acceptField,\n      Map<String, List<OffsetRange>> outputHighlights)\n      throws IOException {\n    Matches matches = weight.matches(leafReaderContext, contextDocId);\n    if (matches == null) {\n      return;\n    }\n\n    for (String field : affectedFields) {\n      if (acceptField.test(field)) {\n        MatchesIterator matchesIterator = matches.getMatches(field);\n        if (matchesIterator == null) {\n          // No matches on this field, even though the field was part of the query. This may be possible\n          // with complex queries that source non-text fields (have no \"hit regions\" in any textual\n          // representation). Skip.\n        } else {\n          OffsetsRetrievalStrategy offsetStrategy = offsetStrategies.get(field);\n          if (offsetStrategy == null) {\n            throw new IOException(\n                \"Non-empty matches but no offset retrieval strategy for field: \" + field);\n          }\n          List<OffsetRange> ranges = offsetStrategy.get(matchesIterator, doc);\n          if (!ranges.isEmpty()) {\n            outputHighlights.put(field, ranges);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"]},"commit2Childs":{"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}