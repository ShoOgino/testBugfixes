{"path":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","commits":[{"id":"8e664487f12f836ec07e7c44c5ddc682388a15cf","date":1521303713,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"/dev/null","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it and hopefully the same\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n//    //See javadocs of LatLonDocValuesField\n//    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n//    double deltaCentimetersMax\n//        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n//    //  equals 1.0420371840922256   which is a bit lower than what we're able to do\n\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.33);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"/dev/null","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it and hopefully the same\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n//    //See javadocs of LatLonDocValuesField\n//    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n//    double deltaCentimetersMax\n//        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n//    //  equals 1.0420371840922256   which is a bit lower than what we're able to do\n\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.33);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4275db69613869d3fdbc26e04ea8b8c3c7be628","date":1523653551,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters <= deltaCentimetersMax);\n  }\n\n","sourceOld":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it and hopefully the same\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n//    //See javadocs of LatLonDocValuesField\n//    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n//    double deltaCentimetersMax\n//        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n//    //  equals 1.0420371840922256   which is a bit lower than what we're able to do\n\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.33);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30624fc97c03dcee86ae05dc59c16f5febcf0b0a","date":1523717511,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters <= 1.37);\n  }\n\n","sourceOld":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters <= deltaCentimetersMax);\n  }\n\n","bugFix":null,"bugIntro":["8a713a3d02622aed29179ff89d088eca0dc0bdca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a713a3d02622aed29179ff89d088eca0dc0bdca","date":1529587767,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.40);\n    // Pt(x=105.29894270124083,y=-0.4371673760042398) to  Pt(x=105.2989428,y=-0.4371673) is 1.38568\n  }\n\n","sourceOld":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters <= 1.37);\n  }\n\n","bugFix":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.40);\n    // Pt(x=105.29894270124083,y=-0.4371673760042398) to  Pt(x=105.2989428,y=-0.4371673) is 1.38568\n  }\n\n","sourceOld":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters <= 1.37);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.40);\n    // Pt(x=105.29894270124083,y=-0.4371673760042398) to  Pt(x=105.2989428,y=-0.4371673) is 1.38568\n  }\n\n","sourceOld":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters <= 1.37);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSolr4Spatial2#testLLPDecodeIsStableAndPrecise().mjava","sourceNew":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.41);\n    // Pt(x=105.29894270124083,y=-0.4371673760042398) to  Pt(x=105.2989428,y=-0.4371673) is 1.38568\n  }\n\n","sourceOld":"  @Test @Repeat(iterations = 10)\n  public void testLLPDecodeIsStableAndPrecise() throws Exception {\n    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value\n    @SuppressWarnings({\"resource\", \"IOResourceOpenedButNotSafelyClosed\"})\n    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr\n\n    final String fld = \"llp_1_dv_dvasst\";\n    String ptOrig = GeoTestUtil.nextLatitude() + \",\" + GeoTestUtil.nextLongitude();\n    assertU(adoc(\"id\", \"0\", fld, ptOrig));\n    assertU(commit());\n    // retrieve it (probably less precision)\n    String ptDecoded1 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    // now write it back\n    assertU(adoc(\"id\", \"0\", fld, ptDecoded1));\n    assertU(commit());\n    // retrieve it; assert that it's the same as written\n    String ptDecoded2 = (String) client.query(params(\"q\", \"id:0\")).getResults().get(0).get(fld);\n    assertEquals(\"orig:\" + ptOrig, ptDecoded1, ptDecoded2);\n\n    // test that the representation is pretty accurate\n    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);\n    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);\n    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    //See javadocs of LatLonDocValuesField for these constants\n    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);\n    double deltaCentimetersMax\n        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;\n    assertEquals(1.0420371840922256, deltaCentimetersMax, 0.0);// just so that we see it in black & white in the test\n\n    //max found by trial & error.  If we used 8 decimal places then we could get down to 1.04cm accuracy but then we\n    // lose the ability to round-trip -- 40 would become 39.99999997  (ugh).\n    assertTrue(\"deltaCm too high: \" + deltaCentimeters, deltaCentimeters < 1.40);\n    // Pt(x=105.29894270124083,y=-0.4371673760042398) to  Pt(x=105.2989428,y=-0.4371673) is 1.38568\n  }\n\n","bugFix":["8a713a3d02622aed29179ff89d088eca0dc0bdca"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a","8a713a3d02622aed29179ff89d088eca0dc0bdca"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8a713a3d02622aed29179ff89d088eca0dc0bdca"],"c4275db69613869d3fdbc26e04ea8b8c3c7be628":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"30624fc97c03dcee86ae05dc59c16f5febcf0b0a":["c4275db69613869d3fdbc26e04ea8b8c3c7be628"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"8a713a3d02622aed29179ff89d088eca0dc0bdca":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a","8a713a3d02622aed29179ff89d088eca0dc0bdca"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c4275db69613869d3fdbc26e04ea8b8c3c7be628":["30624fc97c03dcee86ae05dc59c16f5febcf0b0a"],"30624fc97c03dcee86ae05dc59c16f5febcf0b0a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","8a713a3d02622aed29179ff89d088eca0dc0bdca","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["203e3fcf513c02ee2c07015f2ce277e26dc60907","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["c4275db69613869d3fdbc26e04ea8b8c3c7be628"],"8a713a3d02622aed29179ff89d088eca0dc0bdca":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}