{"path":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","commits":[{"id":"813335f324f8bd40ae4d83d8391674b42b536cc0","date":1555591986,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = createColectionsAndAlias(aliasName);\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (IllegalArgumentException e) {\n      // expected\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e828e297e861bb0ff7bc13f23de5c193ea05606a","date":1557834120,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","sourceNew":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = createColectionsAndAlias(aliasName);\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    // make sure we have the latest version in cache\n    zkStateReader.aliasesManager.update();\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    zkStateReader.aliasesManager.update();\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (IllegalArgumentException e) {\n      // expected\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = createColectionsAndAlias(aliasName);\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (IllegalArgumentException e) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc21266829f9cffb210032f5808ce3a630780ab3","date":1560248034,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","sourceNew":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    int lastVersion = aliases.getZNodeVersion();\n\n    createColectionsAndAlias(aliasName);\n\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    // make sure we have the latest version in cache\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (IllegalArgumentException e) {\n      // expected\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = createColectionsAndAlias(aliasName);\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    // make sure we have the latest version in cache\n    zkStateReader.aliasesManager.update();\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    zkStateReader.aliasesManager.update();\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (IllegalArgumentException e) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce0b61a2648584b34304ab915de569c63bdb36b4","date":1562311172,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","sourceNew":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    int lastVersion = aliases.getZNodeVersion();\n\n    createColectionsAndAlias(aliasName);\n\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    // make sure we have the latest version in cache\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (SolrException e) {\n      // expected\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    int lastVersion = aliases.getZNodeVersion();\n\n    createColectionsAndAlias(aliasName);\n\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    // make sure we have the latest version in cache\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (IllegalArgumentException e) {\n      // expected\n    }\n  }\n\n","bugFix":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f93fd9cfb33387060fae71bf27ed17402277f910","date":1565843798,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testClusterStateProviderAPI().mjava","sourceNew":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    \n    // pick an arbitrary node, and use it's cloudManager to assert that (an instance of)\n    // the ClusterStateProvider API reflects alias changes made by remote clients\n    final SolrCloudManager cloudManager = cluster.getRandomJetty(random())\n      .getCoreContainer().getZkController().getSolrCloudManager();\n\n    // allthough the purpose of this test is to verify that the ClusterStateProvider API\n    // works as a \"black box\" for inspecting alias information, we'll be doing some \"grey box\"\n    // introspection of the underlying ZKNodeVersion to first verify that alias updates have\n    // propogated to our randomly selected node before making assertions against the\n    // ClusterStateProvider API...\n    //\n    // establish a baseline version for future waitForAliasesUpdate calls\n    int lastVersion = waitForAliasesUpdate(-1, cloudManager.getClusterStateProvider());\n\n    // create the alias and wait for it to propogate\n    createColectionsAndAlias(aliasName);\n    lastVersion = waitForAliasesUpdate(-1, cloudManager.getClusterStateProvider());\n\n    // assert ClusterStateProvider sees the alias\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n\n    // modify the alias to have some properties\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, cloudManager.getClusterStateProvider());\n\n    // assert ClusterStateProvider sees the new props (and still sees correct collections)\n    stateProvider = cloudManager.getClusterStateProvider();\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n    collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    \n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, cloudManager.getClusterStateProvider());\n    \n    // assert ClusterStateProvider sees it's routed...\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    expectThrows(SolrException.class, () -> {\n      String resolved = cloudManager.getClusterStateProvider().resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n      });\n  }\n\n","sourceOld":"  @Test\n  public void testClusterStateProviderAPI() throws Exception {\n    final String aliasName = getSaferTestName();\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    int lastVersion = aliases.getZNodeVersion();\n\n    createColectionsAndAlias(aliasName);\n\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    CollectionAdminRequest.SetAliasProperty setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(\"foo\",\"baz\");\n    setAliasProperty.addProperty(\"bar\",\"bam\");\n    setAliasProperty.process(cluster.getSolrClient());\n    checkFooAndBarMeta(aliasName, zkStateReader);\n    SolrCloudManager cloudManager = cluster.getJettySolrRunner(0).getCoreContainer().getZkController().getSolrCloudManager();\n    // make sure we have the latest version in cache\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    ClusterStateProvider stateProvider = cloudManager.getClusterStateProvider();\n    List<String> collections = stateProvider.resolveAlias(aliasName);\n    assertEquals(collections.toString(), 2, collections.size());\n    assertTrue(collections.toString(), collections.contains(\"collection1meta\"));\n    assertTrue(collections.toString(), collections.contains(\"collection2meta\"));\n    Map<String, String> props = stateProvider.getAliasProperties(aliasName);\n    assertEquals(props.toString(), 2, props.size());\n    assertEquals(props.toString(), \"baz\", props.get(\"foo\"));\n    assertEquals(props.toString(), \"bam\", props.get(\"bar\"));\n\n    assertFalse(\"should not be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n    // now make it a routed alias, according to the criteria in the API\n    setAliasProperty = CollectionAdminRequest.setAliasProperty(aliasName);\n    setAliasProperty.addProperty(CollectionAdminParams.ROUTER_PREFIX + \"foo\",\"baz\");\n    setAliasProperty.process(cluster.getSolrClient());\n    // refresh\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n    stateProvider = cloudManager.getClusterStateProvider();\n    assertTrue(\"should be a routed alias\", stateProvider.isRoutedAlias(aliasName));\n\n    try {\n      String resolved = stateProvider.resolveSimpleAlias(aliasName);\n      fail(\"this is not a simple alias but it resolved to \" + resolved);\n    } catch (SolrException e) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ce0b61a2648584b34304ab915de569c63bdb36b4":["fc21266829f9cffb210032f5808ce3a630780ab3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fc21266829f9cffb210032f5808ce3a630780ab3":["e828e297e861bb0ff7bc13f23de5c193ea05606a"],"e828e297e861bb0ff7bc13f23de5c193ea05606a":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"813335f324f8bd40ae4d83d8391674b42b536cc0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f93fd9cfb33387060fae71bf27ed17402277f910":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f93fd9cfb33387060fae71bf27ed17402277f910"]},"commit2Childs":{"ce0b61a2648584b34304ab915de569c63bdb36b4":["f93fd9cfb33387060fae71bf27ed17402277f910"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["813335f324f8bd40ae4d83d8391674b42b536cc0"],"fc21266829f9cffb210032f5808ce3a630780ab3":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"e828e297e861bb0ff7bc13f23de5c193ea05606a":["fc21266829f9cffb210032f5808ce3a630780ab3"],"813335f324f8bd40ae4d83d8391674b42b536cc0":["e828e297e861bb0ff7bc13f23de5c193ea05606a"],"f93fd9cfb33387060fae71bf27ed17402277f910":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}