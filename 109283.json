{"path":"lucene/core/src/test/org/apache/lucene/index/TestFilterLeafReader#checkOverrideMethods(Class[#]).mjava","commits":[{"id":"c9644a32526f2e2ae87543b00e8be543aa25f29c","date":1411548458,"type":1,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFilterLeafReader#checkOverrideMethods(Class[#]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFilterAtomicReader#checkOverrideMethods(Class[#]).mjava","sourceNew":"  private static void checkOverrideMethods(Class<?> clazz) throws NoSuchMethodException, SecurityException {\n    final Class<?> superClazz = clazz.getSuperclass();\n    for (Method m : superClazz.getMethods()) {\n      final int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isAbstract(mods) || Modifier.isFinal(mods) || m.isSynthetic()\n          || m.getName().equals(\"attributes\")) {\n        continue;\n      }\n      // The point of these checks is to ensure that methods that have a default\n      // impl through other methods are not overridden. This makes the number of\n      // methods to override to have a working impl minimal and prevents from some\n      // traps: for example, think about having getCoreCacheKey delegate to the\n      // filtered impl by default\n      final Method subM = clazz.getMethod(m.getName(), m.getParameterTypes());\n      if (subM.getDeclaringClass() == clazz\n          && m.getDeclaringClass() != Object.class\n          && m.getDeclaringClass() != subM.getDeclaringClass()) {\n        fail(clazz + \" overrides \" + m + \" although it has a default impl\");\n      }\n    }\n  }\n\n","sourceOld":"  private static void checkOverrideMethods(Class<?> clazz) throws NoSuchMethodException, SecurityException {\n    final Class<?> superClazz = clazz.getSuperclass();\n    for (Method m : superClazz.getMethods()) {\n      final int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isAbstract(mods) || Modifier.isFinal(mods) || m.isSynthetic()\n          || m.getName().equals(\"attributes\")) {\n        continue;\n      }\n      // The point of these checks is to ensure that methods that have a default\n      // impl through other methods are not overridden. This makes the number of\n      // methods to override to have a working impl minimal and prevents from some\n      // traps: for example, think about having getCoreCacheKey delegate to the\n      // filtered impl by default\n      final Method subM = clazz.getMethod(m.getName(), m.getParameterTypes());\n      if (subM.getDeclaringClass() == clazz\n          && m.getDeclaringClass() != Object.class\n          && m.getDeclaringClass() != subM.getDeclaringClass()) {\n        fail(clazz + \" overrides \" + m + \" although it has a default impl\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de0a9f776f230888561498119e8a3c2d903a7b4a","date":1413920964,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFilterLeafReader#checkOverrideMethods(Class[#]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFilterLeafReader#checkOverrideMethods(Class[#]).mjava","sourceNew":"  private static void checkOverrideMethods(Class<?> clazz) throws NoSuchMethodException, SecurityException {\n    final Class<?> superClazz = clazz.getSuperclass();\n    for (Method m : superClazz.getMethods()) {\n      final int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isAbstract(mods) || Modifier.isFinal(mods) || m.isSynthetic()\n          || m.getName().equals(\"attributes\") || m.getName().equals(\"getStats\")) {\n        continue;\n      }\n      // The point of these checks is to ensure that methods that have a default\n      // impl through other methods are not overridden. This makes the number of\n      // methods to override to have a working impl minimal and prevents from some\n      // traps: for example, think about having getCoreCacheKey delegate to the\n      // filtered impl by default\n      final Method subM = clazz.getMethod(m.getName(), m.getParameterTypes());\n      if (subM.getDeclaringClass() == clazz\n          && m.getDeclaringClass() != Object.class\n          && m.getDeclaringClass() != subM.getDeclaringClass()) {\n        fail(clazz + \" overrides \" + m + \" although it has a default impl\");\n      }\n    }\n  }\n\n","sourceOld":"  private static void checkOverrideMethods(Class<?> clazz) throws NoSuchMethodException, SecurityException {\n    final Class<?> superClazz = clazz.getSuperclass();\n    for (Method m : superClazz.getMethods()) {\n      final int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isAbstract(mods) || Modifier.isFinal(mods) || m.isSynthetic()\n          || m.getName().equals(\"attributes\")) {\n        continue;\n      }\n      // The point of these checks is to ensure that methods that have a default\n      // impl through other methods are not overridden. This makes the number of\n      // methods to override to have a working impl minimal and prevents from some\n      // traps: for example, think about having getCoreCacheKey delegate to the\n      // filtered impl by default\n      final Method subM = clazz.getMethod(m.getName(), m.getParameterTypes());\n      if (subM.getDeclaringClass() == clazz\n          && m.getDeclaringClass() != Object.class\n          && m.getDeclaringClass() != subM.getDeclaringClass()) {\n        fail(clazz + \" overrides \" + m + \" although it has a default impl\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestFilterLeafReader#checkOverrideMethods(Class[#]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestFilterLeafReader#checkOverrideMethods(Class[#]).mjava","sourceNew":"  private static void checkOverrideMethods(Class<?> clazz) throws NoSuchMethodException, SecurityException {\n    final Class<?> superClazz = clazz.getSuperclass();\n    for (Method m : superClazz.getMethods()) {\n      final int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isAbstract(mods) || Modifier.isFinal(mods) || m.isSynthetic()\n          || m.getName().equals(\"attributes\") || m.getName().equals(\"getStats\")) {\n        continue;\n      }\n      // The point of these checks is to ensure that methods that have a default\n      // impl through other methods are not overridden. This makes the number of\n      // methods to override to have a working impl minimal and prevents from some\n      // traps: for example, think about having getCoreCacheKey delegate to the\n      // filtered impl by default\n      final Method subM = clazz.getMethod(m.getName(), m.getParameterTypes());\n      if (subM.getDeclaringClass() == clazz\n          && m.getDeclaringClass() != Object.class\n          && m.getDeclaringClass() != subM.getDeclaringClass()) {\n        fail(clazz + \" overrides \" + m + \" although it has a default impl\");\n      }\n    }\n  }\n\n","sourceOld":"  private static void checkOverrideMethods(Class<?> clazz) throws NoSuchMethodException, SecurityException {\n    final Class<?> superClazz = clazz.getSuperclass();\n    for (Method m : superClazz.getMethods()) {\n      final int mods = m.getModifiers();\n      if (Modifier.isStatic(mods) || Modifier.isAbstract(mods) || Modifier.isFinal(mods) || m.isSynthetic()\n          || m.getName().equals(\"attributes\")) {\n        continue;\n      }\n      // The point of these checks is to ensure that methods that have a default\n      // impl through other methods are not overridden. This makes the number of\n      // methods to override to have a working impl minimal and prevents from some\n      // traps: for example, think about having getCoreCacheKey delegate to the\n      // filtered impl by default\n      final Method subM = clazz.getMethod(m.getName(), m.getParameterTypes());\n      if (subM.getDeclaringClass() == clazz\n          && m.getDeclaringClass() != Object.class\n          && m.getDeclaringClass() != subM.getDeclaringClass()) {\n        fail(clazz + \" overrides \" + m + \" although it has a default impl\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c9644a32526f2e2ae87543b00e8be543aa25f29c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["c9644a32526f2e2ae87543b00e8be543aa25f29c","de0a9f776f230888561498119e8a3c2d903a7b4a"],"de0a9f776f230888561498119e8a3c2d903a7b4a":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"]},"commit2Childs":{"c9644a32526f2e2ae87543b00e8be543aa25f29c":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","de0a9f776f230888561498119e8a3c2d903a7b4a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"de0a9f776f230888561498119e8a3c2d903a7b4a":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}