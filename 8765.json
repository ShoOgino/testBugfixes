{"path":"src/java/org/apache/lucene/search/spans/NearSpans#firstNonOrderedNextToPartialList().mjava","commits":[{"id":"3f695d24a4d153a33073fe72ac72a360526a9004","date":1084304183,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpans#firstNonOrderedNextToPartialList().mjava","pathOld":"/dev/null","sourceNew":"  private boolean firstNonOrderedNextToPartialList() throws IOException {\n    /* Creates a partial list consisting of first non ordered and earlier.\n     * Returns first non ordered .next().\n     */\n    last = first = null;\n    int orderedIndex = 0;\n    while (queue.top() != null) {\n      SpansCell cell = (SpansCell)queue.pop();\n      addToList(cell);\n      if (cell.index == orderedIndex) {\n        orderedIndex++;\n      } else {\n        return cell.next();\n        // FIXME: continue here, rename to eg. checkOrderedMatch():\n        // when checkSlop() and not ordered, repeat cell.next().\n        // when checkSlop() and ordered, add to list and repeat queue.pop()\n        // without checkSlop(): no match, rebuild the queue from the partial list.\n        // When queue is empty and checkSlop() and ordered there is a match.\n      }\n    }\n    throw new AssertionError(\"Unexpected: ordered\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86b9e627b89c3dc2568685ecb03a259e28dbba29","date":1084304321,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpans#firstNonOrderedNextToPartialList().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpans#firstNonOrderedNextToPartialList().mjava","sourceNew":"  private boolean firstNonOrderedNextToPartialList() throws IOException {\n    /* Creates a partial list consisting of first non ordered and earlier.\n     * Returns first non ordered .next().\n     */\n    last = first = null;\n    int orderedIndex = 0;\n    while (queue.top() != null) {\n      SpansCell cell = (SpansCell)queue.pop();\n      addToList(cell);\n      if (cell.index == orderedIndex) {\n        orderedIndex++;\n      } else {\n        return cell.next();\n        // FIXME: continue here, rename to eg. checkOrderedMatch():\n        // when checkSlop() and not ordered, repeat cell.next().\n        // when checkSlop() and ordered, add to list and repeat queue.pop()\n        // without checkSlop(): no match, rebuild the queue from the partial list.\n        // When queue is empty and checkSlop() and ordered there is a match.\n      }\n    }\n    throw new RuntimeException(\"Unexpected: ordered\");\n  }\n\n","sourceOld":"  private boolean firstNonOrderedNextToPartialList() throws IOException {\n    /* Creates a partial list consisting of first non ordered and earlier.\n     * Returns first non ordered .next().\n     */\n    last = first = null;\n    int orderedIndex = 0;\n    while (queue.top() != null) {\n      SpansCell cell = (SpansCell)queue.pop();\n      addToList(cell);\n      if (cell.index == orderedIndex) {\n        orderedIndex++;\n      } else {\n        return cell.next();\n        // FIXME: continue here, rename to eg. checkOrderedMatch():\n        // when checkSlop() and not ordered, repeat cell.next().\n        // when checkSlop() and ordered, add to list and repeat queue.pop()\n        // without checkSlop(): no match, rebuild the queue from the partial list.\n        // When queue is empty and checkSlop() and ordered there is a match.\n      }\n    }\n    throw new AssertionError(\"Unexpected: ordered\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98bc22650ab0fe51f9c00513397bfa42a64fc663","date":1161986633,"type":4,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/spans/NearSpans#firstNonOrderedNextToPartialList().mjava","sourceNew":null,"sourceOld":"  private boolean firstNonOrderedNextToPartialList() throws IOException {\n    /* Creates a partial list consisting of first non ordered and earlier.\n     * Returns first non ordered .next().\n     */\n    last = first = null;\n    int orderedIndex = 0;\n    while (queue.top() != null) {\n      SpansCell cell = (SpansCell)queue.pop();\n      addToList(cell);\n      if (cell.index == orderedIndex) {\n        orderedIndex++;\n      } else {\n        return cell.next();\n        // FIXME: continue here, rename to eg. checkOrderedMatch():\n        // when checkSlop() and not ordered, repeat cell.next().\n        // when checkSlop() and ordered, add to list and repeat queue.pop()\n        // without checkSlop(): no match, rebuild the queue from the partial list.\n        // When queue is empty and checkSlop() and ordered there is a match.\n      }\n    }\n    throw new RuntimeException(\"Unexpected: ordered\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f695d24a4d153a33073fe72ac72a360526a9004":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"86b9e627b89c3dc2568685ecb03a259e28dbba29":["3f695d24a4d153a33073fe72ac72a360526a9004"],"98bc22650ab0fe51f9c00513397bfa42a64fc663":["86b9e627b89c3dc2568685ecb03a259e28dbba29"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["98bc22650ab0fe51f9c00513397bfa42a64fc663"]},"commit2Childs":{"3f695d24a4d153a33073fe72ac72a360526a9004":["86b9e627b89c3dc2568685ecb03a259e28dbba29"],"86b9e627b89c3dc2568685ecb03a259e28dbba29":["98bc22650ab0fe51f9c00513397bfa42a64fc663"],"98bc22650ab0fe51f9c00513397bfa42a64fc663":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3f695d24a4d153a33073fe72ac72a360526a9004"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}