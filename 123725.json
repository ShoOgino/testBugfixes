{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"create shard invoked\");\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(MAX_SHARDS_PER_NODE, 1));\n//    int minReplicas = message.getInt(\"minReplicas\",repFactor);\n    String createNodeSetStr =message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we don't see the collection\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) !=null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["62588e300dd0b29f3e8f5d25aa08dc59edd9c354"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"create shard invoked\");\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(MAX_SHARDS_PER_NODE, 1));\n//    int minReplicas = message.getInt(\"minReplicas\",repFactor);\n    String createNodeSetStr =message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we don't see the collection\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) !=null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62588e300dd0b29f3e8f5d25aa08dc59edd9c354","date":1380712275,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"create shard invoked\");\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(MAX_SHARDS_PER_NODE, 1));\n//    int minReplicas = message.getInt(\"minReplicas\",repFactor);\n    String createNodeSetStr =message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we don't see the collection\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) !=null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b711ca2887ae3fda68611cbb78c1b389fa9833be","date":1384985717,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getZkClient()\n          .getBaseUrlForNodeName(nodeName);\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.currentTimeMillis() + 30000;\n    boolean created = false;\n    while (System.currentTimeMillis() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    if(collectionName == null || shard ==null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\" );\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    String sliceName = shard;\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbf528c0e702c5cbd1339b2da1cdc823fd44a925","date":1427230904,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    log.info(\"Create shard invoked: {}\", message);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n    int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n    ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \"\n          + sliceName + \" of collection \" + collectionName + \" on \"\n          + nodeName);\n\n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[]{replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n\n      shardHandler.submit(sreq, replica, sreq.params);\n\n    }\n\n    processResponses(results, shardHandler);\n\n    log.info(\"Finished create command on all shards for collection: \"\n        + collectionName);\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(\"name\"));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","date":1431966199,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(ZkStateReader.MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(ZkStateReader.REPLICATION_FACTOR, collection.getInt(ZkStateReader.REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec4fc24ecd353171e03bd016c1681cd97476015f","date":1432214672,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n      List<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, sliceName, repFactor,\n          createNodeSetStr, overseer.getZkController().getCoreContainer());\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int maxShardsPerNode = collection.getInt(MAX_SHARDS_PER_NODE, 1);\n      int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n\n      ArrayList<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, numSlices, maxShardsPerNode, repFactor, createNodeSetStr);\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true; \n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n\n    MDCUtils.setMDC(collectionName, sliceName, null, null);\n    try {\n      log.info(\"Create shard invoked: {}\", message);\n      if (collectionName == null || sliceName == null)\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n      int numSlices = 1;\n\n      ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n      String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n      List<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, sliceName, repFactor,\n          createNodeSetStr, overseer.getZkController().getCoreContainer());\n\n      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n      // wait for a while until we see the shard\n      long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n      boolean created = false;\n      while (System.nanoTime() < waitUntil) {\n        Thread.sleep(100);\n        created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n        if (created) break;\n      }\n      if (!created)\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n\n\n      String configName = message.getStr(COLL_CONF);\n      for (int j = 1; j <= repFactor; j++) {\n        String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n        String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n        log.info(\"Creating shard \" + shardName + \" as part of slice \"\n            + sliceName + \" of collection \" + collectionName + \" on \"\n            + nodeName);\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, shardName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, sliceName);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n        addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        params.set(\"qt\", adminPath);\n        sreq.purpose = 1;\n        String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n        sreq.shards = new String[]{replica};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        shardHandler.submit(sreq, replica, sreq.params);\n\n      }\n\n      processResponses(results, shardHandler);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n      return true;\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n  }\n\n","bugFix":null,"bugIntro":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca","date":1436588269,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<ReplicaCount> sortedNodeList = getNodesForNewReplicas(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true; \n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<Node> sortedNodeList = getNodesForNewShard(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true; \n  }\n\n","bugFix":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<ReplicaCount> sortedNodeList = getNodesForNewReplicas(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true; \n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<ReplicaCount> sortedNodeList = getNodesForNewReplicas(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#createShard(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createShard(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<ReplicaCount> sortedNodeList = getNodesForNewReplicas(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true;\n  }\n\n","sourceOld":"  private boolean createShard(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String sliceName = message.getStr(SHARD_ID_PROP);\n    \n    log.info(\"Create shard invoked: {}\", message);\n    if (collectionName == null || sliceName == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"'collection' and 'shard' are required parameters\");\n    int numSlices = 1;\n    \n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    DocCollection collection = clusterState.getCollection(collectionName);\n    int repFactor = message.getInt(REPLICATION_FACTOR, collection.getInt(REPLICATION_FACTOR, 1));\n    String createNodeSetStr = message.getStr(CREATE_NODE_SET);\n    List<ReplicaCount> sortedNodeList = getNodesForNewReplicas(clusterState, collectionName, sliceName, repFactor,\n        createNodeSetStr, overseer.getZkController().getCoreContainer());\n        \n    Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));\n    // wait for a while until we see the shard\n    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);\n    boolean created = false;\n    while (System.nanoTime() < waitUntil) {\n      Thread.sleep(100);\n      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;\n      if (created) break;\n    }\n    if (!created)\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not fully create shard: \" + message.getStr(NAME));\n      \n    String configName = message.getStr(COLL_CONF);\n    for (int j = 1; j <= repFactor; j++) {\n      String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;\n      String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n      log.info(\"Creating shard \" + shardName + \" as part of slice \" + sliceName + \" of collection \" + collectionName\n          + \" on \" + nodeName);\n          \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      params.set(CoreAdminParams.NAME, shardName);\n      params.set(COLL_CONF, configName);\n      params.set(CoreAdminParams.COLLECTION, collectionName);\n      params.set(CoreAdminParams.SHARD, sliceName);\n      params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n      addPropertyParams(message, params);\n      \n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      String replica = zkStateReader.getBaseUrlForNodeName(nodeName);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n      \n    }\n    \n    processResponses(results, shardHandler);\n    \n    log.info(\"Finished create command on all shards for collection: \" + collectionName);\n    \n    return true; \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1eeda7e62e149f90eee8895af874c74efa7d4852"],"ec4fc24ecd353171e03bd016c1681cd97476015f":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"b7605579001505896d48b07160075a5c8b8e128e":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","6f26f74e4969851a019d28f10315cb1c77786f22"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"b711ca2887ae3fda68611cbb78c1b389fa9833be":["62588e300dd0b29f3e8f5d25aa08dc59edd9c354"],"62588e300dd0b29f3e8f5d25aa08dc59edd9c354":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["30c688f7052130cef7bd419c85e3c5be214f7b9e","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["b711ca2887ae3fda68611cbb78c1b389fa9833be"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["6f26f74e4969851a019d28f10315cb1c77786f22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["62588e300dd0b29f3e8f5d25aa08dc59edd9c354","b711ca2887ae3fda68611cbb78c1b389fa9833be"],"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"6f26f74e4969851a019d28f10315cb1c77786f22":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["30c688f7052130cef7bd419c85e3c5be214f7b9e"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"ec4fc24ecd353171e03bd016c1681cd97476015f":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22"],"b7605579001505896d48b07160075a5c8b8e128e":[],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"b711ca2887ae3fda68611cbb78c1b389fa9833be":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"62588e300dd0b29f3e8f5d25aa08dc59edd9c354":["b711ca2887ae3fda68611cbb78c1b389fa9833be","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","62588e300dd0b29f3e8f5d25aa08dc59edd9c354"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8":["ec4fc24ecd353171e03bd016c1681cd97476015f"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["07dbf37ea1062f6f3f4fc7deb3ae385ab837ebc8","d2638f781be724518ff6c2263d14a48cf6e68017"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","1eeda7e62e149f90eee8895af874c74efa7d4852"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"6f26f74e4969851a019d28f10315cb1c77786f22":["b7605579001505896d48b07160075a5c8b8e128e","0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","b7605579001505896d48b07160075a5c8b8e128e","d2638f781be724518ff6c2263d14a48cf6e68017","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}