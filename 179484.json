{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","commits":[{"id":"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6","date":1337196931,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"/dev/null","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        latches[0].await(5, TimeUnit.SECONDS);\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(3, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    if (checkPoint.get()) {\n      latches[1].countDown();\n    }\n    \n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["94b7283983822a9583bad884111a4b8486827692","7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"/dev/null","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        latches[0].await(5, TimeUnit.SECONDS);\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(3, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    if (checkPoint.get()) {\n      latches[1].countDown();\n    }\n    \n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","date":1337674113,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", latches[0].await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(10, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    latches[1].countDown();\n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        latches[0].await(5, TimeUnit.SECONDS);\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(3, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    if (checkPoint.get()) {\n      latches[1].countDown();\n    }\n    \n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"bugIntro":["a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", latches[0].await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(10, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    latches[1].countDown();\n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        latches[0].await(5, TimeUnit.SECONDS);\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(3, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    ctrl.updateStalled(memCtrl);\n    if (checkPoint.get()) {\n      latches[1].countDown();\n    }\n    \n    for (int i = 0; i < threads.length; i++) {\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3","date":1339345566,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchonizer sync = new Synchonizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (random().nextInt(2) == 0) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    \n    final CountDownLatch[] latches = new CountDownLatch[] {\n        new CountDownLatch(numStallers + numReleasers), new CountDownLatch(1),\n        new CountDownLatch(numWaiters)};\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, latches, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, latches, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", latches[0].await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (!ctrl.anyStalledThreads()) {\n          assertTrue(\n              \"control claims no stalled threads but waiter seems to be blocked\",\n              latches[2].await(10, TimeUnit.SECONDS));\n        }\n        checkPoint.set(false);\n        \n        latches[1].countDown();\n      }\n      assertFalse(checkPoint.get());\n      if (random().nextInt(2) == 0) {\n        latches[0] = new CountDownLatch(numStallers + numReleasers);\n        latches[1] = new CountDownLatch(1);\n        latches[2] = new CountDownLatch(numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    \n    stop.set(true);\n    latches[1].countDown();\n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a49b96fc91ebda52f94fc883b1e59a36bf0e07f","date":1339398297,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (random().nextInt(2) == 0) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchonizer sync = new Synchonizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (random().nextInt(2) == 0) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecbdf3d46a747e1af6d7d07249a95c58c0141874","date":1339454869,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  @Nightly\n  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (random().nextInt(2) == 0) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (random().nextInt(2) == 0) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["94b7283983822a9583bad884111a4b8486827692"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94b7283983822a9583bad884111a4b8486827692","date":1339532320,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Nightly\n  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(20000);\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (random().nextInt(2) == 0) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":["ecbdf3d46a747e1af6d7d07249a95c58c0141874","f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e38f40562eb7c165ae08ab2367a031883138354","date":1340287338,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    SimpleMemCtrl memCtrl = new SimpleMemCtrl();\n    memCtrl.limit = 1000;\n    memCtrl.netBytes = 1;\n    memCtrl.flushBytes = 0;\n    ctrl.updateStalled(memCtrl);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      memCtrl.limit = 1000;\n      memCtrl.netBytes = 1;\n      memCtrl.flushBytes = 0;\n      ctrl.updateStalled(memCtrl);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbd7967e39613fd5cfff97ca0eee81b1028a85d1","date":1422628745,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be382406ee6e8449e49c082b50c31367e7add702","date":1469488703,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl(newIndexWriterConfig());\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAcquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAcquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = TEST_NIGHTLY ? atLeast(10000) : atLeast(1000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5e38f40562eb7c165ae08ab2367a031883138354":["94b7283983822a9583bad884111a4b8486827692"],"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"5a49b96fc91ebda52f94fc883b1e59a36bf0e07f":["a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["bbd7967e39613fd5cfff97ca0eee81b1028a85d1","d08973aa47f2cf98a588293a53af4e948952ccfb"],"ecbdf3d46a747e1af6d7d07249a95c58c0141874":["5a49b96fc91ebda52f94fc883b1e59a36bf0e07f"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["94b7283983822a9583bad884111a4b8486827692","5e38f40562eb7c165ae08ab2367a031883138354"],"94b7283983822a9583bad884111a4b8486827692":["ecbdf3d46a747e1af6d7d07249a95c58c0141874"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be382406ee6e8449e49c082b50c31367e7add702":["bbd7967e39613fd5cfff97ca0eee81b1028a85d1"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["ef0d8a69209261514c5739c770bba706c2308450","7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["bbd7967e39613fd5cfff97ca0eee81b1028a85d1","be382406ee6e8449e49c082b50c31367e7add702"],"ef0d8a69209261514c5739c770bba706c2308450":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"bbd7967e39613fd5cfff97ca0eee81b1028a85d1":["5e38f40562eb7c165ae08ab2367a031883138354"]},"commit2Childs":{"5e38f40562eb7c165ae08ab2367a031883138354":["fe33227f6805edab2036cbb80645cc4e2d1fa424","bbd7967e39613fd5cfff97ca0eee81b1028a85d1"],"f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6":["7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2","ef0d8a69209261514c5739c770bba706c2308450"],"7a0bb7b6eeee9103dc4c7cb2dfd62a9a41894fc2":["3599646b4d4c346cf74d334813488b8b337b5bf5","a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3"],"5a49b96fc91ebda52f94fc883b1e59a36bf0e07f":["ecbdf3d46a747e1af6d7d07249a95c58c0141874"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"ecbdf3d46a747e1af6d7d07249a95c58c0141874":["94b7283983822a9583bad884111a4b8486827692"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"94b7283983822a9583bad884111a4b8486827692":["5e38f40562eb7c165ae08ab2367a031883138354","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f31d1f3a9bc5a99a8d7f3110bab36210e7d967c6","ef0d8a69209261514c5739c770bba706c2308450"],"be382406ee6e8449e49c082b50c31367e7add702":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a00cd5b99c9e9cc6f7e2aaa157b998ea599796a3":["5a49b96fc91ebda52f94fc883b1e59a36bf0e07f"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"ef0d8a69209261514c5739c770bba706c2308450":["3599646b4d4c346cf74d334813488b8b337b5bf5"],"bbd7967e39613fd5cfff97ca0eee81b1028a85d1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","be382406ee6e8449e49c082b50c31367e7add702","d08973aa47f2cf98a588293a53af4e948952ccfb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","3599646b4d4c346cf74d334813488b8b337b5bf5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}