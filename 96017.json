{"path":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","commits":[{"id":"771d61401d0dabe7201a7366bf75f7ea739894fd","date":1574693827,"type":0,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","pathOld":"/dev/null","sourceNew":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"), \"=={\\\"doc\\\":{'id':\\\"1\\\"\" +\n        \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"), \"=={\\\"doc\\\":{'id':\\\"1\\\"\" +\n        \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", empty ? new ArrayList<>() : null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"),\n        \"=={'doc':{'id':'1', cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36fd7272f81d669dd63b197001dc7e80642a9c4e","date":1575949878,"type":3,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","sourceNew":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    // latlon field is included to ensure reading from LatLonDocValuesField is working due to atomic update.\n    // See SOLR-13966 for further details.\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"latlon\", \"0,0\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/latlon=='0,0'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","sourceOld":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"), \"=={\\\"doc\\\":{'id':\\\"1\\\"\" +\n        \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"), \"=={\\\"doc\\\":{'id':\\\"1\\\"\" +\n        \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", empty ? new ArrayList<>() : null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"),\n        \"=={'doc':{'id':'1', cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","bugFix":null,"bugIntro":["e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"993b0c7dda6341b437fe5685d35c6cc35eaac420","date":1575985950,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","sourceNew":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    // latlon field is included to ensure reading from LatLonDocValuesField is working due to atomic update.\n    // See SOLR-13966 for further details.\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"latlon\", \"0,0\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/latlon=='0,0'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","sourceOld":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    SolrInputDocument doc = sdoc(\"id\", \"1\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"), \"=={\\\"doc\\\":{'id':\\\"1\\\"\" +\n        \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"), \"=={\\\"doc\\\":{'id':\\\"1\\\"\" +\n        \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", empty ? new ArrayList<>() : null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, cat_ss, child1, [child]\"),\n        \"=={'doc':{'id':'1', cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103","date":1576013359,"type":3,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","sourceNew":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    // latlon field is included to ensure reading from LatLonDocValuesField is working due to atomic update.\n    // See SOLR-13966 for further details.\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"latlon\", \"0,0\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", empty ? new ArrayList<>() : null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/latlon=='0,0'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","sourceOld":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    // latlon field is included to ensure reading from LatLonDocValuesField is working due to atomic update.\n    // See SOLR-13966 for further details.\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"latlon\", \"0,0\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/latlon=='0,0'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","bugFix":["36fd7272f81d669dd63b197001dc7e80642a9c4e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/NestedAtomicUpdateTest#testBlockAtomicSetToNullOrEmpty(boolean).mjava","sourceNew":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    // latlon field is included to ensure reading from LatLonDocValuesField is working due to atomic update.\n    // See SOLR-13966 for further details.\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"latlon\", \"0,0\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", empty ? new ArrayList<>() : null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/latlon=='0,0'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","sourceOld":"  private void testBlockAtomicSetToNullOrEmpty(boolean empty) throws Exception {\n    // latlon field is included to ensure reading from LatLonDocValuesField is working due to atomic update.\n    // See SOLR-13966 for further details.\n    SolrInputDocument doc = sdoc(\"id\", \"1\", \"latlon\", \"0,0\",\n        \"cat_ss\", new String[] {\"aaa\", \"ccc\"},\n        \"child1\", sdocs(sdoc(\"id\", \"2\", \"cat_ss\", \"child\"), sdoc(\"id\", \"3\", \"cat_ss\", \"child\")));\n    assertU(adoc(doc));\n\n    BytesRef rootDocId = new BytesRef(\"1\");\n    SolrCore core = h.getCore();\n    SolrInputDocument block = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    // assert block doc has child docs\n    assertTrue(block.containsKey(\"child1\"));\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==0\");\n\n    // commit the changes\n    assertU(commit());\n\n    SolrInputDocument committedBlock = RealTimeGetComponent.getInputDocument(core, rootDocId,\n        RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n    BytesRef childDocId = new BytesRef(\"2\");\n    // ensure the whole block is returned when resolveBlock is true and id of a child doc is provided\n    assertEquals(committedBlock.toString(), RealTimeGetComponent\n        .getInputDocument(core, childDocId, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN).toString());\n\n    assertJQ(req(\"q\", \"id:1\"), \"/response/numFound==1\");\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    assertU(commit());\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\"\" +\n            \", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"], child1:[{\\\"id\\\":\\\"2\\\",\\\"cat_ss\\\":[\\\"child\\\"]}, {\\\"id\\\":\\\"3\\\",\\\"cat_ss\\\":[\\\"child\\\"]}]}}\");\n\n    doc = sdoc(\"id\", \"1\", \"child1\", Collections.singletonMap(\"set\", null));\n    addAndGetVersion(doc, params(\"wt\", \"json\"));\n\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    assertU(commit());\n\n    // a cut-n-paste of the first big query, but this time it will be retrieved from the index rather than the\n    // transaction log\n    // this requires ChildDocTransformer to get the whole block, since the document is retrieved using an index lookup\n    assertJQ(req(\"qt\", \"/get\", \"id\", \"1\", \"fl\", \"id, latlon, cat_ss, child1, [child]\"),\n        \"=={\\\"doc\\\":{'id':\\\"1\\\", \\\"latlon\\\":\\\"0,0\\\", cat_ss:[\\\"aaa\\\",\\\"ccc\\\"]}}\");\n\n    // ensure the whole block has been committed correctly to the index.\n    assertJQ(req(\"q\", \"id:1\", \"fl\", \"*, [child]\"),\n        \"/response/numFound==1\",\n        \"/response/docs/[0]/id=='1'\",\n        \"/response/docs/[0]/latlon=='0,0'\",\n        \"/response/docs/[0]/cat_ss/[0]==\\\"aaa\\\"\",\n        \"/response/docs/[0]/cat_ss/[1]==\\\"ccc\\\"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"36fd7272f81d669dd63b197001dc7e80642a9c4e":["771d61401d0dabe7201a7366bf75f7ea739894fd"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":["771d61401d0dabe7201a7366bf75f7ea739894fd","36fd7272f81d669dd63b197001dc7e80642a9c4e"],"a229cb50768e988c50a2106bdae3a92154f428bf":["993b0c7dda6341b437fe5685d35c6cc35eaac420","e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103":["36fd7272f81d669dd63b197001dc7e80642a9c4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103"],"771d61401d0dabe7201a7366bf75f7ea739894fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"36fd7272f81d669dd63b197001dc7e80642a9c4e":["993b0c7dda6341b437fe5685d35c6cc35eaac420","e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103"],"993b0c7dda6341b437fe5685d35c6cc35eaac420":["a229cb50768e988c50a2106bdae3a92154f428bf"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["771d61401d0dabe7201a7366bf75f7ea739894fd"],"e31c1e5ed09a53ccf0c98279a80d32a7a3e4e103":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"771d61401d0dabe7201a7366bf75f7ea739894fd":["36fd7272f81d669dd63b197001dc7e80642a9c4e","993b0c7dda6341b437fe5685d35c6cc35eaac420"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}