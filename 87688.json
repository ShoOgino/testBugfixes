{"path":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(InvertedFields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both InvertedFields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(InvertedFields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(InvertedFields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both InvertedFields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(InvertedFields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bdb5e42b0cecd8dfb27767a02ada71899bf17917","date":1334100099,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a238fc456663f685a9db1ed8d680e348bb45171","date":1334173266,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        boolean hasOffsets = false;\n        boolean hasPositions = false;\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              hasOffsets = startOffset != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            if (hasOffsets) {\n              assert startOffset != -1;\n              assert endOffset != -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        boolean hasOffsets = false;\n        boolean hasPositions = false;\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              hasOffsets = startOffset != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            if (hasOffsets) {\n              assert startOffset != -1;\n              assert endOffset != -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        boolean hasOffsets = false;\n        boolean hasPositions = false;\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              hasOffsets = startOffset != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            if (hasOffsets) {\n              assert startOffset != -1;\n              assert endOffset != -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","date":1344608180,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n    \n    TermsEnum termsEnum = null;\n    DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      \n      final boolean hasPositions = terms.hasPositions();\n      final boolean hasOffsets = terms.hasOffsets();\n      \n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      \n      startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n      termsEnum = terms.iterator(termsEnum);\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n        \n        startTerm(termsEnum.term(), freq);\n\n        if (hasPositions || hasOffsets) {\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          assert docsAndPositionsEnum != null;\n          \n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        boolean hasOffsets = false;\n        boolean hasPositions = false;\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              hasOffsets = startOffset != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            if (hasOffsets) {\n              assert startOffset != -1;\n              assert endOffset != -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":["322360ac5185a8446d3e0b530b2068bef67cd3d5","3cc749c053615f5871f3b95715fe292f34e70a53","31f025ae60076ae95274433f3fe8e6ace2857a87"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0935c850ea562932997b72c69d93e345f21d7f45","date":1344711506,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, MergeState mergeState) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n    \n    TermsEnum termsEnum = null;\n    DocsAndPositionsEnum docsAndPositionsEnum = null;\n    \n    final ReaderPayloadProcessor readerPayloadProcessor = mergeState.currentReaderPayloadProcessor;\n    PayloadProcessor payloadProcessor = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = mergeState.fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      \n      final boolean hasPositions = terms.hasPositions();\n      final boolean hasOffsets = terms.hasOffsets();\n      final boolean hasPayloads = terms.hasPayloads();\n      assert !hasPayloads || hasPositions;\n      \n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      \n      startField(fieldInfo, numTerms, hasPositions, hasOffsets, hasPayloads);\n      termsEnum = terms.iterator(termsEnum);\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n        \n        startTerm(termsEnum.term(), freq);\n        \n        if (hasPayloads && readerPayloadProcessor != null) {\n          payloadProcessor = readerPayloadProcessor.getProcessor(fieldName, termsEnum.term());\n        }\n\n        if (hasPositions || hasOffsets) {\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          assert docsAndPositionsEnum != null;\n          \n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            \n            BytesRef payload = docsAndPositionsEnum.hasPayload() ? \n                docsAndPositionsEnum.getPayload() : null;\n                \n            if (payloadProcessor != null && payload != null) {\n              // to not violate the D&P api, we must give the processor a private copy\n              payload = BytesRef.deepCopyOf(payload);\n              payloadProcessor.processPayload(payload);\n              if (payload.length == 0) {\n                // don't let PayloadProcessors corrumpt the index\n                payload = null;\n              }\n            }\n\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset, payload);\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n    \n    TermsEnum termsEnum = null;\n    DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      \n      final boolean hasPositions = terms.hasPositions();\n      final boolean hasOffsets = terms.hasOffsets();\n      \n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      \n      startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n      termsEnum = terms.iterator(termsEnum);\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n        \n        startTerm(termsEnum.term(), freq);\n\n        if (hasPositions || hasOffsets) {\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          assert docsAndPositionsEnum != null;\n          \n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, MergeState mergeState) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    String lastFieldName = null;\n    \n    TermsEnum termsEnum = null;\n    DocsAndPositionsEnum docsAndPositionsEnum = null;\n    \n    final ReaderPayloadProcessor readerPayloadProcessor = mergeState.currentReaderPayloadProcessor;\n    PayloadProcessor payloadProcessor = null;\n\n    for(String fieldName : vectors) {\n      final FieldInfo fieldInfo = mergeState.fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = vectors.terms(fieldName);\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      \n      final boolean hasPositions = terms.hasPositions();\n      final boolean hasOffsets = terms.hasOffsets();\n      final boolean hasPayloads = terms.hasPayloads();\n      assert !hasPayloads || hasPositions;\n      \n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      \n      startField(fieldInfo, numTerms, hasPositions, hasOffsets, hasPayloads);\n      termsEnum = terms.iterator(termsEnum);\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n        \n        startTerm(termsEnum.term(), freq);\n        \n        if (hasPayloads && readerPayloadProcessor != null) {\n          payloadProcessor = readerPayloadProcessor.getProcessor(fieldName, termsEnum.term());\n        }\n\n        if (hasPositions || hasOffsets) {\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          assert docsAndPositionsEnum != null;\n          \n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            \n            BytesRef payload = docsAndPositionsEnum.getPayload();\n                \n            if (payloadProcessor != null && payload != null) {\n              // to not violate the D&P api, we must give the processor a private copy\n              payload = BytesRef.deepCopyOf(payload);\n              payloadProcessor.processPayload(payload);\n              if (payload.length == 0) {\n                // don't let PayloadProcessors corrumpt the index\n                payload = null;\n              }\n            }\n\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset, payload);\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        boolean hasOffsets = false;\n        boolean hasPositions = false;\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              hasOffsets = startOffset != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            if (hasOffsets) {\n              assert startOffset != -1;\n              assert endOffset != -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":5,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, MergeState mergeState) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    String lastFieldName = null;\n    \n    TermsEnum termsEnum = null;\n    DocsAndPositionsEnum docsAndPositionsEnum = null;\n    \n    final ReaderPayloadProcessor readerPayloadProcessor = mergeState.currentReaderPayloadProcessor;\n    PayloadProcessor payloadProcessor = null;\n\n    for(String fieldName : vectors) {\n      final FieldInfo fieldInfo = mergeState.fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = vectors.terms(fieldName);\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      \n      final boolean hasPositions = terms.hasPositions();\n      final boolean hasOffsets = terms.hasOffsets();\n      final boolean hasPayloads = terms.hasPayloads();\n      assert !hasPayloads || hasPositions;\n      \n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      \n      startField(fieldInfo, numTerms, hasPositions, hasOffsets, hasPayloads);\n      termsEnum = terms.iterator(termsEnum);\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n        \n        startTerm(termsEnum.term(), freq);\n        \n        if (hasPayloads && readerPayloadProcessor != null) {\n          payloadProcessor = readerPayloadProcessor.getProcessor(fieldName, termsEnum.term());\n        }\n\n        if (hasPositions || hasOffsets) {\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          assert docsAndPositionsEnum != null;\n          \n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            \n            BytesRef payload = docsAndPositionsEnum.getPayload();\n                \n            if (payloadProcessor != null && payload != null) {\n              // to not violate the D&P api, we must give the processor a private copy\n              payload = BytesRef.deepCopyOf(payload);\n              payloadProcessor.processPayload(payload);\n              if (payload.length == 0) {\n                // don't let PayloadProcessors corrumpt the index\n                payload = null;\n              }\n            }\n\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset, payload);\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.size and\n   *  Terms.size. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.size();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.size() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.size();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"terms.size() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        boolean hasOffsets = false;\n        boolean hasPositions = false;\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = docsAndPositionsEnum.startOffset();\n            final int endOffset = docsAndPositionsEnum.endOffset();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              hasOffsets = startOffset != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            if (hasOffsets) {\n              assert startOffset != -1;\n              assert endOffset != -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bdb5e42b0cecd8dfb27767a02ada71899bf17917":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"5a238fc456663f685a9db1ed8d680e348bb45171":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","bdb5e42b0cecd8dfb27767a02ada71899bf17917"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc":["322360ac5185a8446d3e0b530b2068bef67cd3d5"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","0935c850ea562932997b72c69d93e345f21d7f45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["bdb5e42b0cecd8dfb27767a02ada71899bf17917","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["bdb5e42b0cecd8dfb27767a02ada71899bf17917","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"0935c850ea562932997b72c69d93e345f21d7f45":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["bdb5e42b0cecd8dfb27767a02ada71899bf17917"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["d6f074e73200c07d54f242d3880a8da5a35ff97b","0935c850ea562932997b72c69d93e345f21d7f45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0935c850ea562932997b72c69d93e345f21d7f45"]},"commit2Childs":{"bdb5e42b0cecd8dfb27767a02ada71899bf17917":["5a238fc456663f685a9db1ed8d680e348bb45171","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"5a238fc456663f685a9db1ed8d680e348bb45171":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc":["0935c850ea562932997b72c69d93e345f21d7f45"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["bdb5e42b0cecd8dfb27767a02ada71899bf17917","5a238fc456663f685a9db1ed8d680e348bb45171"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"0935c850ea562932997b72c69d93e345f21d7f45":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5a238fc456663f685a9db1ed8d680e348bb45171","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}