{"path":"lucene/core/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","commits":[{"id":"09c1e6d465800c73af60624bf9d4459a19f7940c","date":1579293280,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c568a1e2a5125c2245150eebb030a81baa158b31","date":1587403489,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    // encode triangle\n    int[] original = new int[]{encodeX(ax), encodeY(ay), encodeX(bx), encodeY(by), encodeX(cx), encodeY(cy)};\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[1], original[0], true, original[3], original[2], true, original[5], original[4], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    // quantize decoded triangle\n    double[] encodedQuantize = new double[] {decodeX(encoded.aX), decodeY(encoded.aY), decodeX(encoded.bX), decodeY(encoded.bY), decodeX(encoded.cX), decodeY(encoded.cY)};\n    // quantize original and order it to reflect encoding\n    double[] originalQuantize  = orderTriangle(original[0], original[1], original[2], original[3], original[4], original[5]);\n    // check spatial property\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      boolean originalIntersects = false;\n      boolean encodedIntersects = false;\n      boolean originalContains = false;\n      boolean encodedContains = false;\n      switch (encoded.type) {\n        case POINT:\n          originalIntersects = polygon2D.contains(originalQuantize[0], originalQuantize[1]);\n          encodedIntersects = polygon2D.contains(encodedQuantize[0], encodedQuantize[1]);\n          originalContains = polygon2D.contains(originalQuantize[0], originalQuantize[1]);\n          encodedContains = polygon2D.contains(encodedQuantize[0], encodedQuantize[1]);\n          break;\n        case LINE:\n          originalIntersects = polygon2D.intersectsLine(originalQuantize[0], originalQuantize[1], originalQuantize[2], originalQuantize[3]);\n          encodedIntersects = polygon2D.intersectsLine(encodedQuantize[0], encodedQuantize[1], encodedQuantize[2], encodedQuantize[3]);\n          originalContains = polygon2D.containsLine(originalQuantize[0], originalQuantize[1], originalQuantize[2], originalQuantize[3]);\n          encodedContains = polygon2D.containsLine(encodedQuantize[0], encodedQuantize[1], encodedQuantize[2], encodedQuantize[3]);\n          break;\n        case TRIANGLE:\n          originalIntersects = polygon2D.intersectsTriangle(originalQuantize[0], originalQuantize[1], originalQuantize[2], originalQuantize[3], originalQuantize[4], originalQuantize[5]);\n          encodedIntersects = polygon2D.intersectsTriangle(originalQuantize[0], originalQuantize[1], originalQuantize[2], originalQuantize[3], originalQuantize[4], originalQuantize[5]);\n          originalContains = polygon2D.containsTriangle(originalQuantize[0], originalQuantize[1], originalQuantize[2], originalQuantize[3], originalQuantize[4], originalQuantize[5]);\n          encodedContains = polygon2D.containsTriangle(originalQuantize[0], originalQuantize[1], originalQuantize[2], originalQuantize[3], originalQuantize[4], originalQuantize[5]);\n          break;\n      }\n      assertTrue(originalIntersects == encodedIntersects);\n      assertTrue(originalContains == encodedContains);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c568a1e2a5125c2245150eebb030a81baa158b31":["09c1e6d465800c73af60624bf9d4459a19f7940c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09c1e6d465800c73af60624bf9d4459a19f7940c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c568a1e2a5125c2245150eebb030a81baa158b31"]},"commit2Childs":{"c568a1e2a5125c2245150eebb030a81baa158b31":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09c1e6d465800c73af60624bf9d4459a19f7940c"],"09c1e6d465800c73af60624bf9d4459a19f7940c":["c568a1e2a5125c2245150eebb030a81baa158b31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}