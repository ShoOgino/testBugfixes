{"path":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","commits":[{"id":"4d3fc88a06a44fc3112186e9be4562b36713955d","date":1497587751,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }.unmarshal(in);\n    return operations;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }.unmarshal(in);\n    return operations;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }.unmarshal(in);\n    return operations;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"432ae20f31957196983566265f0dae4a9eb8960f","date":1500294156,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","sourceNew":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    try (final JavaBinCodec jbc = new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }) {\n      jbc.unmarshal(in);\n    }\n    return operations;\n  }\n\n","sourceOld":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }.unmarshal(in);\n    return operations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","sourceNew":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    try (final JavaBinCodec jbc = new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }) {\n      jbc.unmarshal(in);\n    }\n    return operations;\n  }\n\n","sourceOld":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }.unmarshal(in);\n    return operations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/CommandOperation#parse(InputStream,Set[String]).mjava","sourceNew":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    try (final JavaBinCodec jbc = new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }) {\n      jbc.unmarshal(in);\n    }\n    return operations;\n  }\n\n","sourceOld":"  /**\n   * Parse the command operations into command objects from javabin payload\n   * * @param singletonCommands commands that cannot be repeated\n   */\n  public static List<CommandOperation> parse(InputStream in, Set<String> singletonCommands) throws IOException {\n    List<CommandOperation> operations = new ArrayList<>();\n\n    final HashMap map = new HashMap(0) {\n      @Override\n      public Object put(Object key, Object value) {\n        List vals = null;\n        if (value instanceof List && !singletonCommands.contains(key)) {\n          vals = (List) value;\n        } else {\n          vals = Collections.singletonList(value);\n        }\n        for (Object val : vals) {\n          operations.add(new CommandOperation(String.valueOf(key), val));\n        }\n        return null;\n      }\n    };\n\n    try (final JavaBinCodec jbc = new JavaBinCodec() {\n      int level = 0;\n      @Override\n      protected Map<Object, Object> newMap(int size) {\n        level++;\n        return level == 1 ? map : super.newMap(size);\n      }\n    }) {\n      jbc.unmarshal(in);\n    }\n    return operations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d3fc88a06a44fc3112186e9be4562b36713955d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","432ae20f31957196983566265f0dae4a9eb8960f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["432ae20f31957196983566265f0dae4a9eb8960f"],"432ae20f31957196983566265f0dae4a9eb8960f":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4d3fc88a06a44fc3112186e9be4562b36713955d"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4d3fc88a06a44fc3112186e9be4562b36713955d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"]},"commit2Childs":{"4d3fc88a06a44fc3112186e9be4562b36713955d":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d3fc88a06a44fc3112186e9be4562b36713955d","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"432ae20f31957196983566265f0dae4a9eb8960f":["aaf90fc29510e72665ac7934f34c3d1c25efad64","a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"28288370235ed02234a64753cdbf0c6ec096304a":["432ae20f31957196983566265f0dae4a9eb8960f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}