{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","commits":[{"id":"9e13d0d4d8b6dc352cb304974502b9a36c153f78","date":1436492687,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor[FacetRequest]#handleBlockJoin().mjava","sourceNew":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, null, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, null, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","date":1470751445,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, null, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bca25eefa1f2205e2b0ef713701dc3a0fecd702","date":1470810578,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, null, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, null, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, null, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a76ad9d8f2ff7e5969bcbf5962d4a4cc574f5c5","date":1477788234,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters have already been applied.\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"320888923ec13b91f53082558f01f4c9960dd226","date":1477926871,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters have already been applied.\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  private void handleBlockJoin() throws IOException {\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      DocSet filt = fcontext.searcher.getDocSetBits( new MatchAllDocsQuery() );\n      result = BlockJoin.toChildren(input, parents, filt, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d12e7f5233d4a77959b66fda90df286dace8a9a0","date":1478016064,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  // returns \"true\" if filters have already been applied.\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9720b151fde2073f4e401450f4574e5f31c2d0ff","date":1478184029,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  // returns \"true\" if filters have already been applied.\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b22e5a20e6ecc2a2a411a4344a34d99a51f0362","date":1479850208,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parser.setIsFilter(true);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parser.setIsFilter(true);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf29cc8a76949bbcbc15b386a9e46a533f5b3332","date":1527778512,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#handleBlockJoin().mjava","sourceNew":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parser.setIsFilter(true);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocSet();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","sourceOld":"  // returns \"true\" if filters were applied to fcontext.base already\n  private boolean handleBlockJoin() throws IOException {\n    boolean appliedFilters = false;\n    if (!(freq.domain.toChildren || freq.domain.toParent)) return appliedFilters;\n\n    // TODO: avoid query parsing per-bucket somehow...\n    String parentStr = freq.domain.parents;\n    Query parentQuery;\n    try {\n      QParser parser = QParser.getParser(parentStr, fcontext.req);\n      parser.setIsFilter(true);\n      parentQuery = parser.getQuery();\n    } catch (SyntaxError err) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing block join parent specification: \" + parentStr);\n    }\n\n    BitDocSet parents = fcontext.searcher.getDocSetBits(parentQuery);\n    DocSet input = fcontext.base;\n    DocSet result;\n\n    if (freq.domain.toChildren) {\n      // If there are filters on this facet, then use them as acceptDocs when executing toChildren.\n      // We need to remember to not redundantly re-apply these filters after.\n      DocSet acceptDocs = this.filter;\n      if (acceptDocs == null) {\n        acceptDocs = fcontext.searcher.getLiveDocs();\n      } else {\n        appliedFilters = true;\n      }\n      result = BlockJoin.toChildren(input, parents, acceptDocs, fcontext.qcontext);\n    } else {\n      result = BlockJoin.toParents(input, parents, fcontext.qcontext);\n    }\n\n    fcontext.base = result;\n    return appliedFilters;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9720b151fde2073f4e401450f4574e5f31c2d0ff":["320888923ec13b91f53082558f01f4c9960dd226","d12e7f5233d4a77959b66fda90df286dace8a9a0"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"d12e7f5233d4a77959b66fda90df286dace8a9a0":["0a76ad9d8f2ff7e5969bcbf5962d4a4cc574f5c5"],"320888923ec13b91f53082558f01f4c9960dd226":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0a76ad9d8f2ff7e5969bcbf5962d4a4cc574f5c5"],"6b22e5a20e6ecc2a2a411a4344a34d99a51f0362":["d12e7f5233d4a77959b66fda90df286dace8a9a0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","cc5ee54a993d26579e3fe1f8f2a696b46b61c48f"],"727bb765ff2542275f6d31f67be18d7104bae148":["9720b151fde2073f4e401450f4574e5f31c2d0ff","6b22e5a20e6ecc2a2a411a4344a34d99a51f0362"],"bf29cc8a76949bbcbc15b386a9e46a533f5b3332":["6b22e5a20e6ecc2a2a411a4344a34d99a51f0362"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a76ad9d8f2ff7e5969bcbf5962d4a4cc574f5c5":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bf29cc8a76949bbcbc15b386a9e46a533f5b3332"]},"commit2Childs":{"9720b151fde2073f4e401450f4574e5f31c2d0ff":["727bb765ff2542275f6d31f67be18d7104bae148"],"cc5ee54a993d26579e3fe1f8f2a696b46b61c48f":["8bca25eefa1f2205e2b0ef713701dc3a0fecd702"],"320888923ec13b91f53082558f01f4c9960dd226":["9720b151fde2073f4e401450f4574e5f31c2d0ff"],"d12e7f5233d4a77959b66fda90df286dace8a9a0":["9720b151fde2073f4e401450f4574e5f31c2d0ff","6b22e5a20e6ecc2a2a411a4344a34d99a51f0362"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["320888923ec13b91f53082558f01f4c9960dd226"],"6b22e5a20e6ecc2a2a411a4344a34d99a51f0362":["727bb765ff2542275f6d31f67be18d7104bae148","bf29cc8a76949bbcbc15b386a9e46a533f5b3332"],"8bca25eefa1f2205e2b0ef713701dc3a0fecd702":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0a76ad9d8f2ff7e5969bcbf5962d4a4cc574f5c5","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["cc5ee54a993d26579e3fe1f8f2a696b46b61c48f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8bca25eefa1f2205e2b0ef713701dc3a0fecd702","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"bf29cc8a76949bbcbc15b386a9e46a533f5b3332":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"0a76ad9d8f2ff7e5969bcbf5962d4a4cc574f5c5":["d12e7f5233d4a77959b66fda90df286dace8a9a0","320888923ec13b91f53082558f01f4c9960dd226"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}