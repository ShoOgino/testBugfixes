{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"/dev/null","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, bytesPerDim, 32, 1f, numDocs, true);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"/dev/null","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, bytesPerDim, 32, 1f, numDocs, true);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs, true);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, bytesPerDim, 32, 1f, numDocs, true);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs, true);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"617d6d4150e0fb2acef8980ce51e3b8e628fb200","date":1580326292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random(), 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random(), 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = 100000;\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random().nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long fp = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, in, in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    long fp = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b1fd50f847900ca47783ea832846d60e81f990","date":1591769592,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long fp = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, in, in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long fp = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, in, in, randomBoolean());\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testWastedLeadingBytes().mjava","sourceNew":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", new BKDConfig(numDims, numIndexDims, bytesPerDim, 32), 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long fp = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, in, in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Claims 16 bytes per dim, but only use the bottom N 1-3 bytes; this would happen e.g. if a user indexes what are actually just short\n  // values as a LongPoint:\n  public void testWastedLeadingBytes() throws Exception {\n    Random random = random();\n    int numDims = TestUtil.nextInt(random, 1, PointValues.MAX_INDEX_DIMENSIONS);\n    int numIndexDims = TestUtil.nextInt(random, 1, numDims);\n    int bytesPerDim = PointValues.MAX_NUM_BYTES;\n    int bytesUsed = TestUtil.nextInt(random, 1, 3);\n\n    Directory dir = newFSDirectory(createTempDir());\n    int numDocs = atLeast(10000);\n    BKDWriter w = new BKDWriter(numDocs+1, dir, \"tmp\", numDims, numIndexDims, bytesPerDim, 32, 1f, numDocs);\n    byte[] tmp = new byte[bytesUsed];\n    byte[] buffer = new byte[numDims * bytesPerDim];\n    for(int i=0;i<numDocs;i++) {\n      for(int dim=0;dim<numDims;dim++) {\n        random.nextBytes(tmp);\n        System.arraycopy(tmp, 0, buffer, dim*bytesPerDim+(bytesPerDim-bytesUsed), tmp.length);\n      }\n      w.add(buffer, i);\n    }\n    \n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long fp = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n    in.seek(fp);\n    BKDReader r = new BKDReader(in, in, in);\n    int[] count = new int[1];\n    r.intersect(new IntersectVisitor() {\n\n        @Override\n        public void visit(int docID) {\n          count[0]++;\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) {\n          assert packedValue.length == numDims * bytesPerDim;\n          visit(docID);\n        }\n\n        @Override\n        public Relation compare(byte[] minPacked, byte[] maxPacked) {\n          assert minPacked.length == numIndexDims * bytesPerDim;\n          assert maxPacked.length == numIndexDims * bytesPerDim;\n          if (random().nextInt(7) == 1) {\n            return Relation.CELL_CROSSES_QUERY;\n          } else {\n            return Relation.CELL_INSIDE_QUERY;\n          }\n        }\n      });\n    assertEquals(numDocs, count[0]);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d6b1fd50f847900ca47783ea832846d60e81f990"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"f6652c943595e92c187ee904c382863013eae28f":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"d6b1fd50f847900ca47783ea832846d60e81f990":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["f6652c943595e92c187ee904c382863013eae28f","9856095f7afb5a607bf5e65077615ed91273508c"],"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"d6b1fd50f847900ca47783ea832846d60e81f990":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d6b1fd50f847900ca47783ea832846d60e81f990"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}