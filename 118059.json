{"path":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#makeReplicaFirstWatcher(Slice,Replica).mjava","commits":[{"id":"73fd358e8ec697393d56617f4d9cedaca74dca14","date":1547954439,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#makeReplicaFirstWatcher(Slice,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#makeReplicaFirstWatcher(String,Slice,Replica).mjava","sourceNew":"  void makeReplicaFirstWatcher(Slice slice, Replica replica)\n      throws KeeperException, InterruptedException {\n\n    ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    // First, queue up the preferred leader watching the leader if it isn't already\n    int secondSeq = Integer.MAX_VALUE;\n\n    int candidateSeq = -1;\n    for (int idx = 1; idx < electionNodes.size(); ++idx) {\n      String candidate = electionNodes.get(idx);\n      secondSeq = Math.min(secondSeq, LeaderElector.getSeq(candidate));\n      if (LeaderElector.getNodeName(candidate).equals(replica.getName())) {\n        candidateSeq = LeaderElector.getSeq(candidate);\n      }\n    }\n    int newSeq = -1;\n    if (candidateSeq == secondSeq) {\n      // the preferredLeader is already watching the leader, no need to move it around.\n      newSeq = secondSeq;\n    } else {\n      for (String electionNode : electionNodes) {\n        if (LeaderElector.getNodeName(electionNode).equals(replica.getName())) {\n          // Make the preferred leader watch the leader.\n          String coreName = slice.getReplica(LeaderElector.getNodeName(electionNode)).getStr(CORE_NAME_PROP);\n          rejoinElectionQueue(slice, electionNode, coreName, true);\n          newSeq = waitForNodeChange(slice, electionNode);\n          break;\n        }\n      }\n    }\n    if (newSeq == -1) {\n      return; // let's not continue if we didn't get what we expect. Possibly we're offline etc..\n    }\n\n    // Now find other nodes that have the same sequence number as this node and re-queue them at the end of the queue.\n    electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    for (String thisNode : electionNodes) {\n      if (LeaderElector.getSeq(thisNode) > newSeq) {\n        break;\n      }\n      if (LeaderElector.getNodeName(thisNode).equals(replica.getName())) {\n        continue;\n      }\n      // We won't get here for the preferredLeader node\n      if (LeaderElector.getSeq(thisNode) == newSeq) {\n        String coreName = slice.getReplica(LeaderElector.getNodeName(thisNode)).getStr(CORE_NAME_PROP);\n        rejoinElectionQueue(slice, thisNode, coreName, false);\n        waitForNodeChange(slice, thisNode);\n      }\n    }\n  }\n\n","sourceOld":"  // Put the replica in at the head of the queue and send all nodes with the same sequence number to the back of the list\n  void makeReplicaFirstWatcher(String collectionName, Slice slice, Replica replica)\n      throws KeeperException, InterruptedException {\n\n    ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    // First, queue up the preferred leader at the head of the queue.\n    int newSeq = -1;\n    for (String electionNode : electionNodes) {\n      if (LeaderElector.getNodeName(electionNode).equals(replica.getName())) {\n        String coreName = slice.getReplica(LeaderElector.getNodeName(electionNode)).getStr(CORE_NAME_PROP);\n        rejoinElection(collectionName, slice, electionNode, coreName, true);\n        newSeq = waitForNodeChange(collectionName, slice, electionNode);\n        break;\n      }\n    }\n    if (newSeq == -1) {\n      return; // let's not continue if we didn't get what we expect. Possibly we're offline etc..\n    }\n\n    // Now find other nodes that have the same sequence number as this node and re-queue them at the end of the queue.\n    electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    for (String thisNode : electionNodes) {\n      if (LeaderElector.getSeq(thisNode) > newSeq) {\n        break;\n      }\n      if (LeaderElector.getNodeName(thisNode).equals(replica.getName())) {\n        continue;\n      }\n      if (LeaderElector.getSeq(thisNode) == newSeq) {\n        String coreName = slice.getReplica(LeaderElector.getNodeName(thisNode)).getStr(CORE_NAME_PROP);\n        rejoinElection(collectionName, slice, thisNode, coreName, false);\n        waitForNodeChange(collectionName, slice, thisNode);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c89f1ef80a9432f4eabaeda9a1e135cd72e60836","date":1547972642,"type":1,"author":"Tommaso Teofili","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#makeReplicaFirstWatcher(Slice,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#makeReplicaFirstWatcher(String,Slice,Replica).mjava","sourceNew":"  void makeReplicaFirstWatcher(Slice slice, Replica replica)\n      throws KeeperException, InterruptedException {\n\n    ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    // First, queue up the preferred leader watching the leader if it isn't already\n    int secondSeq = Integer.MAX_VALUE;\n\n    int candidateSeq = -1;\n    for (int idx = 1; idx < electionNodes.size(); ++idx) {\n      String candidate = electionNodes.get(idx);\n      secondSeq = Math.min(secondSeq, LeaderElector.getSeq(candidate));\n      if (LeaderElector.getNodeName(candidate).equals(replica.getName())) {\n        candidateSeq = LeaderElector.getSeq(candidate);\n      }\n    }\n    int newSeq = -1;\n    if (candidateSeq == secondSeq) {\n      // the preferredLeader is already watching the leader, no need to move it around.\n      newSeq = secondSeq;\n    } else {\n      for (String electionNode : electionNodes) {\n        if (LeaderElector.getNodeName(electionNode).equals(replica.getName())) {\n          // Make the preferred leader watch the leader.\n          String coreName = slice.getReplica(LeaderElector.getNodeName(electionNode)).getStr(CORE_NAME_PROP);\n          rejoinElectionQueue(slice, electionNode, coreName, true);\n          newSeq = waitForNodeChange(slice, electionNode);\n          break;\n        }\n      }\n    }\n    if (newSeq == -1) {\n      return; // let's not continue if we didn't get what we expect. Possibly we're offline etc..\n    }\n\n    // Now find other nodes that have the same sequence number as this node and re-queue them at the end of the queue.\n    electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    for (String thisNode : electionNodes) {\n      if (LeaderElector.getSeq(thisNode) > newSeq) {\n        break;\n      }\n      if (LeaderElector.getNodeName(thisNode).equals(replica.getName())) {\n        continue;\n      }\n      // We won't get here for the preferredLeader node\n      if (LeaderElector.getSeq(thisNode) == newSeq) {\n        String coreName = slice.getReplica(LeaderElector.getNodeName(thisNode)).getStr(CORE_NAME_PROP);\n        rejoinElectionQueue(slice, thisNode, coreName, false);\n        waitForNodeChange(slice, thisNode);\n      }\n    }\n  }\n\n","sourceOld":"  // Put the replica in at the head of the queue and send all nodes with the same sequence number to the back of the list\n  void makeReplicaFirstWatcher(String collectionName, Slice slice, Replica replica)\n      throws KeeperException, InterruptedException {\n\n    ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n    List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    // First, queue up the preferred leader at the head of the queue.\n    int newSeq = -1;\n    for (String electionNode : electionNodes) {\n      if (LeaderElector.getNodeName(electionNode).equals(replica.getName())) {\n        String coreName = slice.getReplica(LeaderElector.getNodeName(electionNode)).getStr(CORE_NAME_PROP);\n        rejoinElection(collectionName, slice, electionNode, coreName, true);\n        newSeq = waitForNodeChange(collectionName, slice, electionNode);\n        break;\n      }\n    }\n    if (newSeq == -1) {\n      return; // let's not continue if we didn't get what we expect. Possibly we're offline etc..\n    }\n\n    // Now find other nodes that have the same sequence number as this node and re-queue them at the end of the queue.\n    electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n        ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n    for (String thisNode : electionNodes) {\n      if (LeaderElector.getSeq(thisNode) > newSeq) {\n        break;\n      }\n      if (LeaderElector.getNodeName(thisNode).equals(replica.getName())) {\n        continue;\n      }\n      if (LeaderElector.getSeq(thisNode) == newSeq) {\n        String coreName = slice.getReplica(LeaderElector.getNodeName(thisNode)).getStr(CORE_NAME_PROP);\n        rejoinElection(collectionName, slice, thisNode, coreName, false);\n        waitForNodeChange(collectionName, slice, thisNode);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","73fd358e8ec697393d56617f4d9cedaca74dca14"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"73fd358e8ec697393d56617f4d9cedaca74dca14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73fd358e8ec697393d56617f4d9cedaca74dca14"]},"commit2Childs":{"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","73fd358e8ec697393d56617f4d9cedaca74dca14"],"73fd358e8ec697393d56617f4d9cedaca74dca14":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}