{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      reader = openReader();\n    }\n\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(reader);\n    DocsEnum docs = MultiFields.getTermDocsEnum(reader, liveDocs, Consts.FULL, \n                                                new BytesRef(categoryPath.toString(delimiter)),\n                                                false);\n    if (docs == null || docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n      return -1; // category does not exist in taxonomy\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    addToCache(categoryPath, docs.docID());\n    return docs.docID();\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      reader = openReader();\n    }\n\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(reader);\n    DocsEnum docs = MultiFields.getTermDocsEnum(reader, liveDocs, Consts.FULL, \n                                                new BytesRef(categoryPath.toString(delimiter)),\n                                                false);\n    if (docs == null || docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n      return -1; // category does not exist in taxonomy\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    addToCache(categoryPath, docs.docID());\n    return docs.docID();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"533890d1266aa8169162ec556395d0c5d0377566","date":1337173867,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      reader = openReader();\n    }\n\n    int base = 0;\n    int doc = -1;\n    for (AtomicReader r : reader.getSequentialSubReaders()) {\n      DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n          new BytesRef(categoryPath.toString(delimiter)), false);\n      if (docs != null) {\n        doc = docs.nextDoc() + base;\n        break;\n      }\n      base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      reader = openReader();\n    }\n\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(reader);\n    DocsEnum docs = MultiFields.getTermDocsEnum(reader, liveDocs, Consts.FULL, \n                                                new BytesRef(categoryPath.toString(delimiter)),\n                                                false);\n    if (docs == null || docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n      return -1; // category does not exist in taxonomy\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    addToCache(categoryPath, docs.docID());\n    return docs.docID();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"119bc02554a192b2954b73d79389ec441257b624","date":1337232699,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      openInternalReader();\n    }\n\n    int base = 0;\n    int doc = -1;\n    for (AtomicReader r : reader.getSequentialSubReaders()) {\n      DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n          new BytesRef(categoryPath.toString(delimiter)), false);\n      if (docs != null) {\n        doc = docs.nextDoc() + base;\n        break;\n      }\n      base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      reader = openReader();\n    }\n\n    int base = 0;\n    int doc = -1;\n    for (AtomicReader r : reader.getSequentialSubReaders()) {\n      DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n          new BytesRef(categoryPath.toString(delimiter)), false);\n      if (docs != null) {\n        doc = docs.nextDoc() + base;\n        break;\n      }\n      base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      openInternalReader();\n    }\n\n    int base = 0;\n    int doc = -1;\n    for (AtomicReader r : reader.getSequentialSubReaders()) {\n      DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n          new BytesRef(categoryPath.toString(delimiter)), false);\n      if (docs != null) {\n        doc = docs.nextDoc() + base;\n        break;\n      }\n      base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      reader = openReader();\n    }\n\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(reader);\n    DocsEnum docs = MultiFields.getTermDocsEnum(reader, liveDocs, Consts.FULL, \n                                                new BytesRef(categoryPath.toString(delimiter)),\n                                                false);\n    if (docs == null || docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n      return -1; // category does not exist in taxonomy\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    addToCache(categoryPath, docs.docID());\n    return docs.docID();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b7a1bc6030c258e47d63eff3455a2b1bbf32683","date":1339494023,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n            new BytesRef(categoryPath.toString(delimiter)), false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in our cache, we can return the\n    // response directly from it:\n    int res = cache.get(categoryPath);\n    if (res >= 0) {\n      return res;\n    }\n    // If we know that the cache is complete, i.e., contains every category\n    // which exists, we can return -1 immediately. However, if the cache is\n    // not complete, we need to check the disk.\n    if (cacheIsComplete) {\n      return -1;\n    }\n    cacheMisses++;\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as a \"online\n    // algorithm\".\n    if (perhapsFillCache()) {\n      return cache.get(categoryPath);\n    }\n\n    // We need to get an answer from the on-disk index. If a reader\n    // is not yet open, do it now:\n    if (reader == null) {\n      openInternalReader();\n    }\n\n    int base = 0;\n    int doc = -1;\n    for (AtomicReader r : reader.getSequentialSubReaders()) {\n      DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n          new BytesRef(categoryPath.toString(delimiter)), false);\n      if (docs != null) {\n        doc = docs.nextDoc() + base;\n        break;\n      }\n      base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n    }\n    // Note: we do NOT add to the cache the fact that the category\n    // does not exist. The reason is that our only use for this\n    // method is just before we actually add this category. If\n    // in the future this usage changes, we should consider caching\n    // the fact that the category is not in the taxonomy.\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b52ea8b7f80d4a0600efc9765dc896387008ebd4","date":1340109038,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, \n            new BytesRef(categoryPath.toString(delimiter)), false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39eda8730bac8b5933ac7397fe06398b6b862d00","date":1343048684,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":["b52ea8b7f80d4a0600efc9765dc896387008ebd4"],"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, false);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        DocsEnum docs = ctx.reader().termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + ctx.docBase;\n          break;\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":["02331260bb246364779cb6f04919ca47900d01bb","8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        DocsEnum docs = ctx.reader().termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + ctx.docBase;\n          break;\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        DocsEnum docs = ctx.reader().termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + ctx.docBase;\n          break;\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      int base = 0;\n      for (AtomicReader r : reader.getSequentialSubReaders()) {\n        DocsEnum docs = r.termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + base;\n          break;\n        }\n        base += r.maxDoc(); // we don't have deletions, so it's ok to call maxDoc\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0e3c1c21aac8ecf75706605133012833585c7","date":1347535263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // TODO: is it really ok that null is passed here as liveDocs?\n            DocsEnum docs = termsEnum.docs(null, null, 0);\n            doc = docs.nextDoc() + ctx.docBase;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        DocsEnum docs = ctx.reader().termDocsEnum(null, Consts.FULL, catTerm, 0);\n        if (docs != null) {\n          doc = docs.nextDoc() + ctx.docBase;\n          break;\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":["209b03e6aa9098ac043cc757e46f758400427b15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"209b03e6aa9098ac043cc757e46f758400427b15","date":1355045906,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // TODO: is it really ok that null is passed here as liveDocs?\n            DocsEnum docs = termsEnum.docs(null, null, 0);\n            doc = docs.nextDoc() + ctx.docBase;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":["b6a0e3c1c21aac8ecf75706605133012833585c7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          TermsEnum termsEnum = terms.iterator(null);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // TODO: is it really ok that null is passed here as liveDocs?\n            DocsEnum docs = termsEnum.docs(null, null, 0);\n            doc = docs.nextDoc() + ctx.docBase;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm, true)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(FacetLabel categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#findCategory(CategoryPath).mjava","sourceNew":null,"sourceOld":"  /**\n   * Look up the given category in the cache and/or the on-disk storage,\n   * returning the category's ordinal, or a negative number in case the\n   * category does not yet exist in the taxonomy.\n   */\n  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {\n    // If we can find the category in the cache, or we know the cache is\n    // complete, we can return the response directly from it\n    int res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      return res;\n    }\n\n    cacheMisses.incrementAndGet();\n    // After a few cache misses, it makes sense to read all the categories\n    // from disk and into the cache. The reason not to do this on the first\n    // cache miss (or even when opening the writer) is that it will\n    // significantly slow down the case when a taxonomy is opened just to\n    // add one category. The idea only spending a long time on reading\n    // after enough time was spent on cache misses is known as an \"online\n    // algorithm\".\n    perhapsFillCache();\n    res = cache.get(categoryPath);\n    if (res >= 0 || cacheIsComplete) {\n      // if after filling the cache from the info on disk, the category is in it\n      // or the cache is complete, return whatever cache.get returned.\n      return res;\n    }\n\n    // if we get here, it means the category is not in the cache, and it is not\n    // complete, and therefore we must look for the category on disk.\n    \n    // We need to get an answer from the on-disk index.\n    initReaderManager();\n\n    int doc = -1;\n    DirectoryReader reader = readerManager.acquire();\n    try {\n      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter));\n      TermsEnum termsEnum = null; // reuse\n      DocsEnum docs = null; // reuse\n      for (AtomicReaderContext ctx : reader.leaves()) {\n        Terms terms = ctx.reader().terms(Consts.FULL);\n        if (terms != null) {\n          termsEnum = terms.iterator(termsEnum);\n          if (termsEnum.seekExact(catTerm)) {\n            // liveDocs=null because the taxonomy has no deletes\n            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);\n            // if the term was found, we know it has exactly one document.\n            doc = docs.nextDoc() + ctx.docBase;\n            break;\n          }\n        }\n      }\n    } finally {\n      readerManager.release(reader);\n    }\n    if (doc > 0) {\n      addToCache(categoryPath, doc);\n    }\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"119bc02554a192b2954b73d79389ec441257b624":["533890d1266aa8169162ec556395d0c5d0377566"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b6a0e3c1c21aac8ecf75706605133012833585c7","209b03e6aa9098ac043cc757e46f758400427b15"],"39eda8730bac8b5933ac7397fe06398b6b862d00":["b52ea8b7f80d4a0600efc9765dc896387008ebd4"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"209b03e6aa9098ac043cc757e46f758400427b15":["b6a0e3c1c21aac8ecf75706605133012833585c7"],"aba371508186796cc6151d8223a5b4e16d02e26e":["b52ea8b7f80d4a0600efc9765dc896387008ebd4","39eda8730bac8b5933ac7397fe06398b6b862d00"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","02331260bb246364779cb6f04919ca47900d01bb"],"b6a0e3c1c21aac8ecf75706605133012833585c7":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"b52ea8b7f80d4a0600efc9765dc896387008ebd4":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["209b03e6aa9098ac043cc757e46f758400427b15"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","02331260bb246364779cb6f04919ca47900d01bb"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["119bc02554a192b2954b73d79389ec441257b624"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b52ea8b7f80d4a0600efc9765dc896387008ebd4","39eda8730bac8b5933ac7397fe06398b6b862d00"],"533890d1266aa8169162ec556395d0c5d0377566":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["209b03e6aa9098ac043cc757e46f758400427b15"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["02331260bb246364779cb6f04919ca47900d01bb"],"ef0d8a69209261514c5739c770bba706c2308450":["b89678825b68eccaf09e6ab71675fc0b0af1e099","119bc02554a192b2954b73d79389ec441257b624"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"02331260bb246364779cb6f04919ca47900d01bb":["39eda8730bac8b5933ac7397fe06398b6b862d00"]},"commit2Childs":{"119bc02554a192b2954b73d79389ec441257b624":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683","ef0d8a69209261514c5739c770bba706c2308450"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"39eda8730bac8b5933ac7397fe06398b6b862d00":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","02331260bb246364779cb6f04919ca47900d01bb"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["533890d1266aa8169162ec556395d0c5d0377566","ef0d8a69209261514c5739c770bba706c2308450"],"209b03e6aa9098ac043cc757e46f758400427b15":["407687e67faf6e1f02a211ca078d8e3eed631027","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b6a0e3c1c21aac8ecf75706605133012833585c7":["407687e67faf6e1f02a211ca078d8e3eed631027","209b03e6aa9098ac043cc757e46f758400427b15"],"b52ea8b7f80d4a0600efc9765dc896387008ebd4":["39eda8730bac8b5933ac7397fe06398b6b862d00","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["b52ea8b7f80d4a0600efc9765dc896387008ebd4"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"533890d1266aa8169162ec556395d0c5d0377566":["119bc02554a192b2954b73d79389ec441257b624"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","b6a0e3c1c21aac8ecf75706605133012833585c7"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"ef0d8a69209261514c5739c770bba706c2308450":[],"02331260bb246364779cb6f04919ca47900d01bb":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","407687e67faf6e1f02a211ca078d8e3eed631027","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","ef0d8a69209261514c5739c770bba706c2308450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}