{"path":"lucene/core/src/java/org/apache/lucene/util/IndexableBinaryStringTools#decode(char[],int,int,byte[],int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/IndexableBinaryStringTools#decode(char[],int,int,byte[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/IndexableBinaryStringTools#decode(char[],int,int,byte[],int,int).mjava","sourceNew":"  /**\n   * Decodes the input char sequence into the output byte sequence. Before\n   * calling this method, ensure that the output array has sufficient capacity\n   * by calling {@link #getDecodedLength(char[], int, int)}.\n   * \n   * @param inputArray char sequence to be decoded\n   * @param inputOffset initial offset into inputArray\n   * @param inputLength number of chars in inputArray\n   * @param outputArray byte sequence to store encoded result\n   * @param outputOffset initial offset into outputArray\n   * @param outputLength length of output, must be\n   *        getDecodedLength(inputArray, inputOffset, inputLength)\n   */\n  public static void decode(char[] inputArray, int inputOffset,\n      int inputLength, byte[] outputArray, int outputOffset, int outputLength) {\n    assert (outputLength == getDecodedLength(inputArray, inputOffset,\n        inputLength));\n    final int numInputChars = inputLength - 1;\n    final int numOutputBytes = outputLength;\n\n    if (numOutputBytes > 0) {\n      int caseNum = 0;\n      int outputByteNum = outputOffset;\n      int inputCharNum = inputOffset;\n      short inputChar;\n      CodingCase codingCase;\n      for (; inputCharNum < numInputChars - 1; ++inputCharNum) {\n        codingCase = CODING_CASES[caseNum];\n        inputChar = (short) inputArray[inputCharNum];\n        if (2 == codingCase.numBytes) {\n          if (0 == caseNum) {\n            outputArray[outputByteNum] = (byte) (inputChar >>> codingCase.initialShift);\n          } else {\n            outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n          }\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n        } else { // numBytes is 3\n          outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.middleMask) >>> codingCase.middleShift);\n          outputArray[outputByteNum + 2] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n        }\n        outputByteNum += codingCase.advanceBytes;\n        if (++caseNum == CODING_CASES.length) {\n          caseNum = 0;\n        }\n      }\n      // Handle final char\n      inputChar = (short) inputArray[inputCharNum];\n      codingCase = CODING_CASES[caseNum];\n      if (0 == caseNum) {\n        outputArray[outputByteNum] = 0;\n      }\n      outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n      final int bytesLeft = numOutputBytes - outputByteNum;\n      if (bytesLeft > 1) {\n        if (2 == codingCase.numBytes) {\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.finalMask) >>> codingCase.finalShift);\n        } else { // numBytes is 3\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.middleMask) >>> codingCase.middleShift);\n          if (bytesLeft > 2) {\n            outputArray[outputByteNum + 2] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Decodes the input char sequence into the output byte sequence. Before\n   * calling this method, ensure that the output array has sufficient capacity\n   * by calling {@link #getDecodedLength(char[], int, int)}.\n   * \n   * @param inputArray char sequence to be decoded\n   * @param inputOffset initial offset into inputArray\n   * @param inputLength number of chars in inputArray\n   * @param outputArray byte sequence to store encoded result\n   * @param outputOffset initial offset into outputArray\n   * @param outputLength length of output, must be\n   *        getDecodedLength(inputArray, inputOffset, inputLength)\n   */\n  public static void decode(char[] inputArray, int inputOffset,\n      int inputLength, byte[] outputArray, int outputOffset, int outputLength) {\n    assert (outputLength == getDecodedLength(inputArray, inputOffset,\n        inputLength));\n    final int numInputChars = inputLength - 1;\n    final int numOutputBytes = outputLength;\n\n    if (numOutputBytes > 0) {\n      int caseNum = 0;\n      int outputByteNum = outputOffset;\n      int inputCharNum = inputOffset;\n      short inputChar;\n      CodingCase codingCase;\n      for (; inputCharNum < numInputChars - 1; ++inputCharNum) {\n        codingCase = CODING_CASES[caseNum];\n        inputChar = (short) inputArray[inputCharNum];\n        if (2 == codingCase.numBytes) {\n          if (0 == caseNum) {\n            outputArray[outputByteNum] = (byte) (inputChar >>> codingCase.initialShift);\n          } else {\n            outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n          }\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n        } else { // numBytes is 3\n          outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.middleMask) >>> codingCase.middleShift);\n          outputArray[outputByteNum + 2] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n        }\n        outputByteNum += codingCase.advanceBytes;\n        if (++caseNum == CODING_CASES.length) {\n          caseNum = 0;\n        }\n      }\n      // Handle final char\n      inputChar = (short) inputArray[inputCharNum];\n      codingCase = CODING_CASES[caseNum];\n      if (0 == caseNum) {\n        outputArray[outputByteNum] = 0;\n      }\n      outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n      final int bytesLeft = numOutputBytes - outputByteNum;\n      if (bytesLeft > 1) {\n        if (2 == codingCase.numBytes) {\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.finalMask) >>> codingCase.finalShift);\n        } else { // numBytes is 3\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.middleMask) >>> codingCase.middleShift);\n          if (bytesLeft > 2) {\n            outputArray[outputByteNum + 2] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/IndexableBinaryStringTools#decode(char[],int,int,byte[],int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Decodes the input char sequence into the output byte sequence. Before\n   * calling this method, ensure that the output array has sufficient capacity\n   * by calling {@link #getDecodedLength(char[], int, int)}.\n   * \n   * @param inputArray char sequence to be decoded\n   * @param inputOffset initial offset into inputArray\n   * @param inputLength number of chars in inputArray\n   * @param outputArray byte sequence to store encoded result\n   * @param outputOffset initial offset into outputArray\n   * @param outputLength length of output, must be\n   *        getDecodedLength(inputArray, inputOffset, inputLength)\n   */\n  public static void decode(char[] inputArray, int inputOffset,\n      int inputLength, byte[] outputArray, int outputOffset, int outputLength) {\n    assert (outputLength == getDecodedLength(inputArray, inputOffset,\n        inputLength));\n    final int numInputChars = inputLength - 1;\n    final int numOutputBytes = outputLength;\n\n    if (numOutputBytes > 0) {\n      int caseNum = 0;\n      int outputByteNum = outputOffset;\n      int inputCharNum = inputOffset;\n      short inputChar;\n      CodingCase codingCase;\n      for (; inputCharNum < numInputChars - 1; ++inputCharNum) {\n        codingCase = CODING_CASES[caseNum];\n        inputChar = (short) inputArray[inputCharNum];\n        if (2 == codingCase.numBytes) {\n          if (0 == caseNum) {\n            outputArray[outputByteNum] = (byte) (inputChar >>> codingCase.initialShift);\n          } else {\n            outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n          }\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n        } else { // numBytes is 3\n          outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.middleMask) >>> codingCase.middleShift);\n          outputArray[outputByteNum + 2] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n        }\n        outputByteNum += codingCase.advanceBytes;\n        if (++caseNum == CODING_CASES.length) {\n          caseNum = 0;\n        }\n      }\n      // Handle final char\n      inputChar = (short) inputArray[inputCharNum];\n      codingCase = CODING_CASES[caseNum];\n      if (0 == caseNum) {\n        outputArray[outputByteNum] = 0;\n      }\n      outputArray[outputByteNum] += (byte) (inputChar >>> codingCase.initialShift);\n      final int bytesLeft = numOutputBytes - outputByteNum;\n      if (bytesLeft > 1) {\n        if (2 == codingCase.numBytes) {\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.finalMask) >>> codingCase.finalShift);\n        } else { // numBytes is 3\n          outputArray[outputByteNum + 1] = (byte) ((inputChar & codingCase.middleMask) >>> codingCase.middleShift);\n          if (bytesLeft > 2) {\n            outputArray[outputByteNum + 2] = (byte) ((inputChar & codingCase.finalMask) << codingCase.finalShift);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"]},"commit2Childs":{"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}