{"path":"solr/core/src/test/org/apache/solr/update/processor/CategoryRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","commits":[{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/CategoryRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createCategoryRoutedAlias(getAlias(), categoryField, 20,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"1\",categoryField, SHIPS[0])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"2\",categoryField, SHIPS[1])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"3\",categoryField, SHIPS[2])));\n    assertUpdateResponse(solrClient.commit(getAlias()));\n\n    // wait for all the collections to exist...\n\n    waitColAndAlias(getAlias(), \"__CRA__\", SHIPS[0], numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[1]), numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[2]), numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      List<SolrInputDocument> list = Arrays.asList(\n          sdoc(\"id\", \"4\", categoryField, SHIPS[0]),\n          sdoc(\"id\", \"5\", categoryField, SHIPS[1]),\n          sdoc(\"id\", \"6\", categoryField, SHIPS[2]));\n      Collections.shuffle(list, random()); // order should not matter here\n      assertUpdateResponse(add(getAlias(), list,\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n    assertRouting(numShards, updateCommands);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bf78a55e1864fa3f0c50ca04de0a010a800e533","date":1554818536,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/CategoryRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/CategoryRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createCategoryRoutedAlias(getAlias(), categoryField, 20,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas*numShards))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"1\",categoryField, SHIPS[0])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"2\",categoryField, SHIPS[1])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"3\",categoryField, SHIPS[2])));\n    assertUpdateResponse(solrClient.commit(getAlias()));\n\n    // wait for all the collections to exist...\n\n    waitColAndAlias(getAlias(), \"__CRA__\", SHIPS[0], numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[1]), numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[2]), numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      List<SolrInputDocument> list = Arrays.asList(\n          sdoc(\"id\", \"4\", categoryField, SHIPS[0]),\n          sdoc(\"id\", \"5\", categoryField, SHIPS[1]),\n          sdoc(\"id\", \"6\", categoryField, SHIPS[2]));\n      Collections.shuffle(list, random()); // order should not matter here\n      assertUpdateResponse(add(getAlias(), list,\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n    assertRouting(numShards, updateCommands);\n  }\n\n","sourceOld":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createCategoryRoutedAlias(getAlias(), categoryField, 20,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"1\",categoryField, SHIPS[0])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"2\",categoryField, SHIPS[1])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"3\",categoryField, SHIPS[2])));\n    assertUpdateResponse(solrClient.commit(getAlias()));\n\n    // wait for all the collections to exist...\n\n    waitColAndAlias(getAlias(), \"__CRA__\", SHIPS[0], numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[1]), numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[2]), numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      List<SolrInputDocument> list = Arrays.asList(\n          sdoc(\"id\", \"4\", categoryField, SHIPS[0]),\n          sdoc(\"id\", \"5\", categoryField, SHIPS[1]),\n          sdoc(\"id\", \"6\", categoryField, SHIPS[2]));\n      Collections.shuffle(list, random()); // order should not matter here\n      assertUpdateResponse(add(getAlias(), list,\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n    assertRouting(numShards, updateCommands);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/CategoryRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/CategoryRoutedAliasUpdateProcessorTest#testSliceRouting().mjava","sourceNew":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createCategoryRoutedAlias(getAlias(), categoryField, 20,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"1\",categoryField, SHIPS[0])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"2\",categoryField, SHIPS[1])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"3\",categoryField, SHIPS[2])));\n    assertUpdateResponse(solrClient.commit(getAlias()));\n\n    // wait for all the collections to exist...\n\n    waitColAndAlias(getAlias(), \"__CRA__\", SHIPS[0], numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[1]), numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[2]), numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      List<SolrInputDocument> list = Arrays.asList(\n          sdoc(\"id\", \"4\", categoryField, SHIPS[0]),\n          sdoc(\"id\", \"5\", categoryField, SHIPS[1]),\n          sdoc(\"id\", \"6\", categoryField, SHIPS[2]));\n      Collections.shuffle(list, random()); // order should not matter here\n      assertUpdateResponse(add(getAlias(), list,\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n    assertRouting(numShards, updateCommands);\n  }\n\n","sourceOld":"  /**\n   * Test that the Update Processor Factory routes documents to leader shards and thus\n   * avoids the possibility of introducing an extra hop to find the leader.\n   *\n   * @throws Exception when it blows up unexpectedly :)\n   */\n  @Slow\n  @Test\n  @LogLevel(\"org.apache.solr.update.processor.TrackingUpdateProcessorFactory=DEBUG\")\n  public void testSliceRouting() throws Exception {\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    // each collection has 4 shards with 3 replicas for 12 possible destinations\n    // 4 of which are leaders, and 8 of which should fail this test.\n    final int numShards = 1 + random().nextInt(4);\n    final int numReplicas = 1 + random().nextInt(3);\n    CollectionAdminRequest.createCategoryRoutedAlias(getAlias(), categoryField, 20,\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas*numShards))\n        .process(solrClient);\n\n    // cause some collections to be created\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"1\",categoryField, SHIPS[0])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"2\",categoryField, SHIPS[1])));\n    assertUpdateResponse(solrClient.add(getAlias(), new SolrInputDocument(\"id\",\"3\",categoryField, SHIPS[2])));\n    assertUpdateResponse(solrClient.commit(getAlias()));\n\n    // wait for all the collections to exist...\n\n    waitColAndAlias(getAlias(), \"__CRA__\", SHIPS[0], numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[1]), numShards);\n    waitColAndAlias(getAlias(), \"__CRA__\", noSpaces(SHIPS[2]), numShards);\n\n    // at this point we now have 3 collections with 4 shards each, and 3 replicas per shard for a total of\n    // 36 total replicas, 1/3 of which are leaders. We will add 3 docs and each has a 33% chance of hitting a\n    // leader randomly and not causing a failure if the code is broken, but as a whole this test will therefore only have\n    // about a 3.6% false positive rate (0.33^3). If that's not good enough, add more docs or more replicas per shard :).\n\n    final String trackGroupName = getTrackUpdatesGroupName();\n    final List<UpdateCommand> updateCommands;\n    try {\n      TrackingUpdateProcessorFactory.startRecording(trackGroupName);\n\n      ModifiableSolrParams params = params(\"post-processor\", \"tracking-\" + trackGroupName);\n      List<SolrInputDocument> list = Arrays.asList(\n          sdoc(\"id\", \"4\", categoryField, SHIPS[0]),\n          sdoc(\"id\", \"5\", categoryField, SHIPS[1]),\n          sdoc(\"id\", \"6\", categoryField, SHIPS[2]));\n      Collections.shuffle(list, random()); // order should not matter here\n      assertUpdateResponse(add(getAlias(), list,\n          params));\n    } finally {\n      updateCommands = TrackingUpdateProcessorFactory.stopRecording(trackGroupName);\n    }\n    assertRouting(numShards, updateCommands);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7bf78a55e1864fa3f0c50ca04de0a010a800e533":["b627755385655c7cd3fb296f17593658805cf4d5"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["7bf78a55e1864fa3f0c50ca04de0a010a800e533"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b627755385655c7cd3fb296f17593658805cf4d5"],"b627755385655c7cd3fb296f17593658805cf4d5":["7bf78a55e1864fa3f0c50ca04de0a010a800e533"],"7bf78a55e1864fa3f0c50ca04de0a010a800e533":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}