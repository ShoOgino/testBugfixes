{"path":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#moveToNextCandidate(int).mjava","commits":[{"id":"523cc6563c99a55527ef7993efc5413c6648852d","date":1518704038,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#moveToNextCandidate(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#setDocAndFreq().mjava","sourceNew":"  /** Set 'doc' to the next potential match, and move all disis of 'head' that\n   *  are on this doc into 'lead'. */\n  private void moveToNextCandidate(int target) throws IOException {\n    // Update score bounds if necessary so\n    updateMaxScoresIfNecessary(target);\n    assert upTo >= target;\n\n    // If the head is empty, it means that the sum of all max scores is not\n    // enough to produce a competitive score. So we jump to the next block.\n    while (head.size() == 0) {\n      if (upTo == DocIdSetIterator.NO_MORE_DOCS) {\n        doc = DocIdSetIterator.NO_MORE_DOCS;\n        return;\n      }\n      updateMaxScores(upTo + 1);\n    }\n\n    // The top of `head` defines the next potential match\n    // pop all documents which are on this doc\n    lead = head.pop();\n    lead.next = null;\n    leadMaxScore = lead.maxScore;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }\n\n","sourceOld":"  /** Reinitializes head, freq and doc from 'head' */\n  private void setDocAndFreq() {\n    assert head.size() > 0;\n\n    // The top of `head` defines the next potential match\n    // pop all documents which are on this doc\n    lead = head.pop();\n    lead.next = null;\n    leadMaxScore = lead.maxScore;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f25eddf3c27255ac101c0ce6044684cfe24c785","date":1576772095,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#moveToNextCandidate(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#moveToNextCandidate(int).mjava","sourceNew":"  /** Set 'doc' to the next potential match, and move all disis of 'head' that\n   *  are on this doc into 'lead'. */\n  private void moveToNextCandidate(int target) throws IOException {\n    // Update score bounds if necessary so\n    updateMaxScoresIfNecessary(target);\n    assert upTo >= target;\n\n    // updateMaxScores tries to move forward until a block with matches is found\n    // so if the head is empty it means there are no matches at all anymore\n    if (head.size() == 0) {\n      assert upTo == DocIdSetIterator.NO_MORE_DOCS;\n      doc = DocIdSetIterator.NO_MORE_DOCS;\n      return;\n    }\n\n    // The top of `head` defines the next potential match\n    // pop all documents which are on this doc\n    lead = head.pop();\n    lead.next = null;\n    leadMaxScore = lead.maxScore;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }\n\n","sourceOld":"  /** Set 'doc' to the next potential match, and move all disis of 'head' that\n   *  are on this doc into 'lead'. */\n  private void moveToNextCandidate(int target) throws IOException {\n    // Update score bounds if necessary so\n    updateMaxScoresIfNecessary(target);\n    assert upTo >= target;\n\n    // If the head is empty, it means that the sum of all max scores is not\n    // enough to produce a competitive score. So we jump to the next block.\n    while (head.size() == 0) {\n      if (upTo == DocIdSetIterator.NO_MORE_DOCS) {\n        doc = DocIdSetIterator.NO_MORE_DOCS;\n        return;\n      }\n      updateMaxScores(upTo + 1);\n    }\n\n    // The top of `head` defines the next potential match\n    // pop all documents which are on this doc\n    lead = head.pop();\n    lead.next = null;\n    leadMaxScore = lead.maxScore;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }\n\n","bugFix":["523cc6563c99a55527ef7993efc5413c6648852d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c66470e527299cc148ad0b3441d08dfb7cb9e03","date":1576859740,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#moveToNextCandidate(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#moveToNextCandidate(int).mjava","sourceNew":"  /** Set 'doc' to the next potential match, and move all disis of 'head' that\n   *  are on this doc into 'lead'. */\n  private void moveToNextCandidate(int target) throws IOException {\n    // Update score bounds if necessary so\n    updateMaxScoresIfNecessary(target);\n    assert upTo >= target;\n\n    // updateMaxScores tries to move forward until a block with matches is found\n    // so if the head is empty it means there are no matches at all anymore\n    if (head.size() == 0) {\n      assert upTo == DocIdSetIterator.NO_MORE_DOCS;\n      doc = DocIdSetIterator.NO_MORE_DOCS;\n      return;\n    }\n\n    // The top of `head` defines the next potential match\n    // pop all documents which are on this doc\n    lead = head.pop();\n    lead.next = null;\n    leadMaxScore = lead.maxScore;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }\n\n","sourceOld":"  /** Set 'doc' to the next potential match, and move all disis of 'head' that\n   *  are on this doc into 'lead'. */\n  private void moveToNextCandidate(int target) throws IOException {\n    // Update score bounds if necessary so\n    updateMaxScoresIfNecessary(target);\n    assert upTo >= target;\n\n    // If the head is empty, it means that the sum of all max scores is not\n    // enough to produce a competitive score. So we jump to the next block.\n    while (head.size() == 0) {\n      if (upTo == DocIdSetIterator.NO_MORE_DOCS) {\n        doc = DocIdSetIterator.NO_MORE_DOCS;\n        return;\n      }\n      updateMaxScores(upTo + 1);\n    }\n\n    // The top of `head` defines the next potential match\n    // pop all documents which are on this doc\n    lead = head.pop();\n    lead.next = null;\n    leadMaxScore = lead.maxScore;\n    doc = lead.doc;\n    while (head.size() > 0 && head.top().doc == doc) {\n      addLead(head.pop());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f25eddf3c27255ac101c0ce6044684cfe24c785":["523cc6563c99a55527ef7993efc5413c6648852d"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":["523cc6563c99a55527ef7993efc5413c6648852d","0f25eddf3c27255ac101c0ce6044684cfe24c785"],"523cc6563c99a55527ef7993efc5413c6648852d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f25eddf3c27255ac101c0ce6044684cfe24c785"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["523cc6563c99a55527ef7993efc5413c6648852d"],"0f25eddf3c27255ac101c0ce6044684cfe24c785":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":[],"523cc6563c99a55527ef7993efc5413c6648852d":["0f25eddf3c27255ac101c0ce6044684cfe24c785","4c66470e527299cc148ad0b3441d08dfb7cb9e03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}