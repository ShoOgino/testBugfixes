{"path":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","commits":[{"id":"3ce36a160d1241ae9c70e109dc3fdfdfb009674a","date":1307033216,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"/dev/null","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.NOT_ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d62f5453a200cec2cbb60148de159dbf55591e9d","date":1307049300,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"/dev/null","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.NOT_ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c715a0f99152be7566591f323c6c5a25725a1bcb","date":1307118449,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"/dev/null","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.NOT_ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b861c0fdfa4d005c70848c9121655e9dc704f96","date":1307129511,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.NOT_ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03daa6ddcb4768a702115ec63799cab5fff3d92","date":1307140842,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.NOT_ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e7c99bd45fa88a3d93a03fdd773053bef72268e","date":1307218088,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.NOT_ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2afd23a6f1242190c3409d8d81d5c5912d607fc9","date":1310477482,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setIndexOptions(IndexOptions.DOCS_ONLY);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setOmitTermFreqAndPositions(true);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      FieldType ft = new FieldType(StringField.TYPE_UNSTORED);\n      ft.setIndexOptions(IndexOptions.DOCS_ONLY);\n      ft.setOmitNorms(true);\n      final Field groupEnd = newField(\"groupend\", \"x\", ft);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), Field.Index.NOT_ANALYZED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), Field.Index.NOT_ANALYZED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, Field.Index.ANALYZED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", Field.Index.NOT_ANALYZED);\n      groupEnd.setIndexOptions(IndexOptions.DOCS_ONLY);\n      groupEnd.setOmitNorms(true);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7cb194976386e349893169fee3c2aa6de3a83fd1","date":1317819143,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      FieldType ft = new FieldType(StringField.TYPE_UNSTORED);\n      ft.setIndexOptions(IndexOptions.DOCS_ONLY);\n      ft.setOmitNorms(true);\n      final Field groupEnd = newField(\"groupend\", \"x\", ft);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4739c84c362b9673ab5ed3e038ff760c718c30c8","date":1322161679,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n    \n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")),\n                        docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa0f44f887719e97183771e977cfc4bfb485b766","date":1326668713,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\").setIntValue(groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7528ec8c6e88061e2e6af98c4ae1f72a30f180b2","date":1327854270,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private IndexReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new IntField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new NumericField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random());\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random(),\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random())));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new IntField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random().nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random);\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random,\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random)));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new IntField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random.nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping#getDocBlockReader(Directory,GroupDoc[]).mjava","sourceNew":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random());\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random(),\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random())));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new IntField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random().nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","sourceOld":"  private DirectoryReader getDocBlockReader(Directory dir, GroupDoc[] groupDocs) throws IOException {\n    // Coalesce by group, but in random order:\n    Collections.shuffle(Arrays.asList(groupDocs), random());\n    final Map<BytesRef,List<GroupDoc>> groupMap = new HashMap<BytesRef,List<GroupDoc>>();\n    final List<BytesRef> groupValues = new ArrayList<BytesRef>();\n\n    for(GroupDoc groupDoc : groupDocs) {\n      if (!groupMap.containsKey(groupDoc.group)) {\n        groupValues.add(groupDoc.group);\n        groupMap.put(groupDoc.group, new ArrayList<GroupDoc>());\n      }\n      groupMap.get(groupDoc.group).add(groupDoc);\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(\n                                                random(),\n                                                dir,\n                                                newIndexWriterConfig(TEST_VERSION_CURRENT,\n                                                                     new MockAnalyzer(random())));\n\n    final List<List<Document>> updateDocs = new ArrayList<List<Document>>();\n\n    FieldType groupEndType = new FieldType(StringField.TYPE_UNSTORED);\n    groupEndType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    groupEndType.setOmitNorms(true);\n\n    //System.out.println(\"TEST: index groups\");\n    for(BytesRef group : groupValues) {\n      final List<Document> docs = new ArrayList<Document>();\n      //System.out.println(\"TEST:   group=\" + (group == null ? \"null\" : group.utf8ToString()));\n      for(GroupDoc groupValue : groupMap.get(group)) {\n        Document doc = new Document();\n        docs.add(doc);\n        if (groupValue.group != null) {\n          doc.add(newField(\"group\", groupValue.group.utf8ToString(), StringField.TYPE_UNSTORED));\n        }\n        doc.add(newField(\"sort1\", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(newField(\"sort2\", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));\n        doc.add(new IntField(\"id\", groupValue.id));\n        doc.add(newField(\"content\", groupValue.content, TextField.TYPE_UNSTORED));\n        //System.out.println(\"TEST:     doc content=\" + groupValue.content + \" group=\" + (groupValue.group == null ? \"null\" : groupValue.group.utf8ToString()) + \" sort1=\" + groupValue.sort1.utf8ToString() + \" id=\" + groupValue.id);\n      }\n      // So we can pull filter marking last doc in block:\n      final Field groupEnd = newField(\"groupend\", \"x\", groupEndType);\n      docs.get(docs.size()-1).add(groupEnd);\n      // Add as a doc block:\n      w.addDocuments(docs);\n      if (group != null && random().nextInt(7) == 4) {\n        updateDocs.add(docs);\n      }\n    }\n\n    for(List<Document> docs : updateDocs) {\n      // Just replaces docs w/ same docs:\n      w.updateDocuments(new Term(\"group\", docs.get(0).get(\"group\")), docs);\n    }\n\n    final DirectoryReader r = w.getReader();\n    w.close();\n\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"2afd23a6f1242190c3409d8d81d5c5912d607fc9":["6b861c0fdfa4d005c70848c9121655e9dc704f96"],"6b861c0fdfa4d005c70848c9121655e9dc704f96":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4739c84c362b9673ab5ed3e038ff760c718c30c8":["7cb194976386e349893169fee3c2aa6de3a83fd1"],"c715a0f99152be7566591f323c6c5a25725a1bcb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"d62f5453a200cec2cbb60148de159dbf55591e9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["fa0f44f887719e97183771e977cfc4bfb485b766","7528ec8c6e88061e2e6af98c4ae1f72a30f180b2"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["d62f5453a200cec2cbb60148de159dbf55591e9d","6b861c0fdfa4d005c70848c9121655e9dc704f96"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"7cb194976386e349893169fee3c2aa6de3a83fd1":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"7528ec8c6e88061e2e6af98c4ae1f72a30f180b2":["fa0f44f887719e97183771e977cfc4bfb485b766"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fa0f44f887719e97183771e977cfc4bfb485b766":["4739c84c362b9673ab5ed3e038ff760c718c30c8"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["2afd23a6f1242190c3409d8d81d5c5912d607fc9"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":["c715a0f99152be7566591f323c6c5a25725a1bcb","6b861c0fdfa4d005c70848c9121655e9dc704f96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"2afd23a6f1242190c3409d8d81d5c5912d607fc9":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"6b861c0fdfa4d005c70848c9121655e9dc704f96":["2afd23a6f1242190c3409d8d81d5c5912d607fc9","1e7c99bd45fa88a3d93a03fdd773053bef72268e","c03daa6ddcb4768a702115ec63799cab5fff3d92"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["6b861c0fdfa4d005c70848c9121655e9dc704f96","c715a0f99152be7566591f323c6c5a25725a1bcb","d62f5453a200cec2cbb60148de159dbf55591e9d"],"4739c84c362b9673ab5ed3e038ff760c718c30c8":["fa0f44f887719e97183771e977cfc4bfb485b766"],"c715a0f99152be7566591f323c6c5a25725a1bcb":["c03daa6ddcb4768a702115ec63799cab5fff3d92"],"d62f5453a200cec2cbb60148de159dbf55591e9d":["1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":[],"7cb194976386e349893169fee3c2aa6de3a83fd1":["4739c84c362b9673ab5ed3e038ff760c718c30c8"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7528ec8c6e88061e2e6af98c4ae1f72a30f180b2":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a","c715a0f99152be7566591f323c6c5a25725a1bcb","d62f5453a200cec2cbb60148de159dbf55591e9d"],"fa0f44f887719e97183771e977cfc4bfb485b766":["5cab9a86bd67202d20b6adc463008c8e982b070a","7528ec8c6e88061e2e6af98c4ae1f72a30f180b2"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["7cb194976386e349893169fee3c2aa6de3a83fd1"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e7c99bd45fa88a3d93a03fdd773053bef72268e","c03daa6ddcb4768a702115ec63799cab5fff3d92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}