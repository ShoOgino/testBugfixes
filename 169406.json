{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","commits":[{"id":"56cb0d38c89b154ab1227808ccd8cac04e4e09d9","date":1343074742,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"/dev/null","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));//200km (since km == ctx.getDistanceUnits\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,//doesn't matter\n          ctx.makePoint(60, -50));\n      ValueSource valueSource = strategy.makeValueSource(args);//the distance\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=200))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57635ff388fa1bee703f3b892a86a3e48975576a","date":1343077051,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"/dev/null","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));//200km (since km == ctx.getDistanceUnits\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,//doesn't matter\n          ctx.makePoint(60, -50));\n      ValueSource valueSource = strategy.makeValueSource(args);//the distance\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=200))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"/dev/null","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));//200km (since km == ctx.getDistanceUnits\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,//doesn't matter\n          ctx.makePoint(60, -50));\n      ValueSource valueSource = strategy.makeValueSource(args);//the distance\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=200))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da956410d7a790f567af4e7e94584fb0930212f2","date":1346859431,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,//doesn't matter\n          ctx.makePoint(60, -50));\n      ValueSource valueSource = strategy.makeValueSource(args);//the distance (in degrees)\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));//200km (since km == ctx.getDistanceUnits\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,//doesn't matter\n          ctx.makePoint(60, -50));\n      ValueSource valueSource = strategy.makeValueSource(args);//the distance\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 200));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=200))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28bce66b0b769a7827b1f4df30b3f50a2ed6c355","date":1347720564,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,//doesn't matter\n          ctx.makePoint(60, -50));\n      ValueSource valueSource = strategy.makeValueSource(args);//the distance (in degrees)\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"400d04533c3afc7d3982c21c14debd6a99853c3a","date":1353963333,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n    }\n    //--Match all, order by distance\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort reverseDistSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//true=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, reverseDistSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db81fe5f1911f062c87abbb053871c166d57d849","date":1374686410,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      double degToKm = DistanceUtils.degrees2Dist(1, DistanceUtils.EARTH_MEAN_RADIUS_KM);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, degToKm);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      double degToKm = DistanceUtils.degrees2Dist(1, DistanceUtils.EARTH_MEAN_RADIUS_KM);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, degToKm);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt);//the distance (in degrees)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003","date":1390592414,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws IOException {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      Point doc1Point = (Point) ctx.readShape(doc1Str);\n      double doc1DistDEG = ctx.getDistCalc().distance(args.getShape().getCenter(), doc1Point);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      double degToKm = DistanceUtils.degrees2Dist(1, DistanceUtils.EARTH_MEAN_RADIUS_KM);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, degToKm);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(Circle(33,-80 d=1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new FilteredQuery(new MatchAllDocsQuery(), filter), 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(new FilteredQuery(new MatchAllDocsQuery(), filter), 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Filter filter = strategy.makeFilter(args);\n      TopDocs docs = indexSearcher.search(filter, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      StoredDocument doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","112d77ac8d3e10a362516ad834c9a11d35c94234"],"400d04533c3afc7d3982c21c14debd6a99853c3a":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"da956410d7a790f567af4e7e94584fb0930212f2":["56cb0d38c89b154ab1227808ccd8cac04e4e09d9"],"56cb0d38c89b154ab1227808ccd8cac04e4e09d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"407687e67faf6e1f02a211ca078d8e3eed631027":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355","400d04533c3afc7d3982c21c14debd6a99853c3a"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"57635ff388fa1bee703f3b892a86a3e48975576a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","56cb0d38c89b154ab1227808ccd8cac04e4e09d9"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","56cb0d38c89b154ab1227808ccd8cac04e4e09d9"],"672b198fc3dce868916c727917cae58c2906763d":["1db68e96dd908fcd79ef809095822736aa601d08"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["db81fe5f1911f062c87abbb053871c166d57d849"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["400d04533c3afc7d3982c21c14debd6a99853c3a"],"28bce66b0b769a7827b1f4df30b3f50a2ed6c355":["da956410d7a790f567af4e7e94584fb0930212f2"],"db81fe5f1911f062c87abbb053871c166d57d849":["400d04533c3afc7d3982c21c14debd6a99853c3a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["672b198fc3dce868916c727917cae58c2906763d"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"400d04533c3afc7d3982c21c14debd6a99853c3a":["407687e67faf6e1f02a211ca078d8e3eed631027","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","db81fe5f1911f062c87abbb053871c166d57d849"],"da956410d7a790f567af4e7e94584fb0930212f2":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"56cb0d38c89b154ab1227808ccd8cac04e4e09d9":["da956410d7a790f567af4e7e94584fb0930212f2","57635ff388fa1bee703f3b892a86a3e48975576a","aba371508186796cc6151d8223a5b4e16d02e26e"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"57635ff388fa1bee703f3b892a86a3e48975576a":[],"1db68e96dd908fcd79ef809095822736aa601d08":["672b198fc3dce868916c727917cae58c2906763d"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"672b198fc3dce868916c727917cae58c2906763d":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["56cb0d38c89b154ab1227808ccd8cac04e4e09d9","57635ff388fa1bee703f3b892a86a3e48975576a","aba371508186796cc6151d8223a5b4e16d02e26e"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"28bce66b0b769a7827b1f4df30b3f50a2ed6c355":["400d04533c3afc7d3982c21c14debd6a99853c3a","407687e67faf6e1f02a211ca078d8e3eed631027"],"db81fe5f1911f062c87abbb053871c166d57d849":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","57635ff388fa1bee703f3b892a86a3e48975576a","aba371508186796cc6151d8223a5b4e16d02e26e","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}