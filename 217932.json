{"path":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","commits":[{"id":"c4ff8864209d2e972cb4393600c26082f9a6533d","date":1239297466,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader suppports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    if (infoStream != null) {\n      message(\"flush at getReader\");\n    }\n\n    // Do this up front before flushing so that the readers\n    // obtained during this flush are pooled, the first time\n    // this method is called:\n    poolReaders = true;\n\n    flush(true, true, true);\n    \n    // Prevent segmentInfos from changing while opening the\n    // reader; in theory we could do similar retry logic,\n    // just like we do when loading segments_N\n    synchronized(this) {\n      return new ReadOnlyMultiSegmentReader(this, segmentInfos);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader suppports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    if (infoStream != null) {\n      message(\"flush at getReader\");\n    }\n\n    // Do this up front before flushing so that the readers\n    // obtained during this flush are pooled, the first time\n    // this method is called:\n    poolReaders = true;\n\n    flush(true, true, true);\n    \n    // Prevent segmentInfos from changing while opening the\n    // reader; in theory we could do similar retry logic,\n    // just like we do when loading segments_N\n    synchronized(this) {\n      return new ReadOnlyDirectoryReader(this, segmentInfos);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader suppports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    if (infoStream != null) {\n      message(\"flush at getReader\");\n    }\n\n    // Do this up front before flushing so that the readers\n    // obtained during this flush are pooled, the first time\n    // this method is called:\n    poolReaders = true;\n\n    flush(true, true, true);\n    \n    // Prevent segmentInfos from changing while opening the\n    // reader; in theory we could do similar retry logic,\n    // just like we do when loading segments_N\n    synchronized(this) {\n      return new ReadOnlyMultiSegmentReader(this, segmentInfos);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"961159f13aece73fbb30aea720e77a2237e8bafd","date":1247258916,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader suppports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader suppports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    if (infoStream != null) {\n      message(\"flush at getReader\");\n    }\n\n    // Do this up front before flushing so that the readers\n    // obtained during this flush are pooled, the first time\n    // this method is called:\n    poolReaders = true;\n\n    flush(true, true, true);\n    \n    // Prevent segmentInfos from changing while opening the\n    // reader; in theory we could do similar retry logic,\n    // just like we do when loading segments_N\n    synchronized(this) {\n      return new ReadOnlyDirectoryReader(this, segmentInfos);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader suppports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2aac324b8999df9e3b47ff2302de23bbea51e012","date":1253659324,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * faster enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you may\n   * want to call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.</p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"635e75831e88abd374563ca4384006c435bdf1a0","date":1255381581,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Returns a readonly reader, covering all committed as\n   * well as un-committed changes to the index.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be quickly made\n   * available for searching without closing the writer nor\n   * calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.<p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Returns a readonly reader containing all\n   * current updates.  Flush is called automatically.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be made\n   * available for searching without closing the writer.\n   *\n   * <p>It's near real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4b10f815c32f7ea4f8a1f9462016c56b2a02da2","date":1255524882,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.<p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Returns a readonly reader, covering all committed as\n   * well as un-committed changes to the index.  This\n   * provides \"near real-time\" searching, in that changes\n   * made during an IndexWriter session can be quickly made\n   * available for searching without closing the writer nor\n   * calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.<p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b884d522e1edd8523e8886eed9fca0b5664aaf4b","date":1259056433,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.</p>\n   *\n   * <p>You must close the {@link IndexReader} returned by\n   * this method once you are done using it.</p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.<p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e0ca16f14d94e05bda40e00ecb2a2c0225343c6","date":1264951226,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.</p>\n   *\n   * <p>You must close the {@link IndexReader} returned by\n   * this method once you are done using it.</p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * @lucene.experimental\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.</p>\n   *\n   * <p>You must close the {@link IndexReader} returned by\n   * this method once you are done using it.</p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * <p><b>NOTE:</b> This API is experimental and might\n   * change in incompatible ways in the next release.</p>\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#getReader().mjava","sourceNew":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.</p>\n   *\n   * <p>You must close the {@link IndexReader} returned by\n   * this method once you are done using it.</p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * @lucene.experimental\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /**\n   * Expert: returns a readonly reader, covering all\n   * committed as well as un-committed changes to the index.\n   * This provides \"near real-time\" searching, in that\n   * changes made during an IndexWriter session can be\n   * quickly made available for searching without closing\n   * the writer nor calling {@link #commit}.\n   *\n   * <p>Note that this is functionally equivalent to calling\n   * {#commit} and then using {@link IndexReader#open} to\n   * open a new reader.  But the turarnound time of this\n   * method should be faster since it avoids the potentially\n   * costly {@link #commit}.</p>\n   *\n   * <p>You must close the {@link IndexReader} returned by\n   * this method once you are done using it.</p>\n   *\n   * <p>It's <i>near</i> real-time because there is no hard\n   * guarantee on how quickly you can get a new reader after\n   * making changes with IndexWriter.  You'll have to\n   * experiment in your situation to determine if it's\n   * fast enough.  As this is a new and experimental\n   * feature, please report back on your findings so we can\n   * learn, improve and iterate.</p>\n   *\n   * <p>The resulting reader supports {@link\n   * IndexReader#reopen}, but that call will simply forward\n   * back to this method (though this may change in the\n   * future).</p>\n   *\n   * <p>The very first time this method is called, this\n   * writer instance will make every effort to pool the\n   * readers that it opens for doing merges, applying\n   * deletes, etc.  This means additional resources (RAM,\n   * file descriptors, CPU time) will be consumed.</p>\n   *\n   * <p>For lower latency on reopening a reader, you should\n   * call {@link #setMergedSegmentWarmer} to\n   * pre-warm a newly merged segment before it's committed\n   * to the index.  This is important for minimizing\n   * index-to-search delay after a large merge.  </p>\n   *\n   * <p>If an addIndexes* call is running in another thread,\n   * then this reader will only search those segments from\n   * the foreign index that have been successfully copied\n   * over, so far</p>.\n   *\n   * <p><b>NOTE</b>: Once the writer is closed, any\n   * outstanding readers may continue to be used.  However,\n   * if you attempt to reopen any of those readers, you'll\n   * hit an {@link AlreadyClosedException}.</p>\n   *\n   * @lucene.experimental\n   *\n   * @return IndexReader that covers entire index plus all\n   * changes made so far by this IndexWriter instance\n   *\n   * @throws IOException\n   */\n  public IndexReader getReader() throws IOException {\n    return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["c4ff8864209d2e972cb4393600c26082f9a6533d"],"635e75831e88abd374563ca4384006c435bdf1a0":["2aac324b8999df9e3b47ff2302de23bbea51e012"],"2aac324b8999df9e3b47ff2302de23bbea51e012":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"1e0ca16f14d94e05bda40e00ecb2a2c0225343c6":["b884d522e1edd8523e8886eed9fca0b5664aaf4b"],"b884d522e1edd8523e8886eed9fca0b5664aaf4b":["a4b10f815c32f7ea4f8a1f9462016c56b2a02da2"],"961159f13aece73fbb30aea720e77a2237e8bafd":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["961159f13aece73fbb30aea720e77a2237e8bafd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c4ff8864209d2e972cb4393600c26082f9a6533d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a4b10f815c32f7ea4f8a1f9462016c56b2a02da2":["635e75831e88abd374563ca4384006c435bdf1a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["1e0ca16f14d94e05bda40e00ecb2a2c0225343c6"]},"commit2Childs":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["961159f13aece73fbb30aea720e77a2237e8bafd"],"635e75831e88abd374563ca4384006c435bdf1a0":["a4b10f815c32f7ea4f8a1f9462016c56b2a02da2"],"2aac324b8999df9e3b47ff2302de23bbea51e012":["635e75831e88abd374563ca4384006c435bdf1a0"],"1e0ca16f14d94e05bda40e00ecb2a2c0225343c6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"b884d522e1edd8523e8886eed9fca0b5664aaf4b":["1e0ca16f14d94e05bda40e00ecb2a2c0225343c6"],"961159f13aece73fbb30aea720e77a2237e8bafd":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["2aac324b8999df9e3b47ff2302de23bbea51e012"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c4ff8864209d2e972cb4393600c26082f9a6533d"],"c4ff8864209d2e972cb4393600c26082f9a6533d":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"a4b10f815c32f7ea4f8a1f9462016c56b2a02da2":["b884d522e1edd8523e8886eed9fca0b5664aaf4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}