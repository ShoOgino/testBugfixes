{"path":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","commits":[{"id":"a194d3ac4639a7909ea614667b9a7632a6aa14d1","date":1355475351,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"/dev/null","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["caa296dfe1eb42df2bff22b952e189a68100fc2b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b752e241723380b5fdabe8364f28fd5639ebf08c","date":1355481283,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      \n      if (termContext == null) {\n        System.out.println(\"term: \" + queryTerms[i] + \" context: \" + -1 + \" maxTermFrequency: \" + maxTermFrequency + \" LOW\");\n\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          System.out.println(\"term: \" + queryTerms[i] + \" context: \" + termContext.docFreq() + \" maxTermFrequency: \" + maxTermFrequency + \" HIGH\");\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          System.out.println(\"term: \" + queryTerms[i] + \" context: \" + termContext.docFreq() + \" maxTermFrequency: \" + maxTermFrequency + \" LOW\");\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88428cf23f55c2838f471aaeaa18fa26805315c9","date":1355481774,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      \n      if (termContext == null) {\n        System.out.println(\"term: \" + queryTerms[i] + \" context: \" + -1 + \" maxTermFrequency: \" + maxTermFrequency + \" LOW\");\n\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          System.out.println(\"term: \" + queryTerms[i] + \" context: \" + termContext.docFreq() + \" maxTermFrequency: \" + maxTermFrequency + \" HIGH\");\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          System.out.println(\"term: \" + queryTerms[i] + \" context: \" + termContext.docFreq() + \" maxTermFrequency: \" + maxTermFrequency + \" LOW\");\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"/dev/null","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aa8b576db3a2ef44791da3c24b9d0b61c236c11","date":1359387145,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size(); \n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":3,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size(); \n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    if (lowFreqOccur == Occur.SHOULD) {\n      lowFreq.setMinimumNumberShouldMatch(minNrShouldMatch);\n    }\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"620f2c9cd3df8f77948c19b3165b5dc20700a5d5","date":1375193294,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size(); \n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size(); \n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"caa296dfe1eb42df2bff22b952e189a68100fc2b","date":1381330075,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreq.getMinimumNumberShouldMatch() == 0 && highFreqOccur != Occur.MUST) {\n        for (BooleanClause booleanClause : highFreq) {\n            booleanClause.setOccur(Occur.MUST);\n        }\n      }\n      highFreq.setBoost(getBoost());\n      return highFreq;\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqOccur == Occur.MUST) {\n        highFreq.setBoost(getBoost());\n        return highFreq;\n      } else {\n        BooleanQuery highFreqConjunction = new BooleanQuery();\n        for (BooleanClause booleanClause : highFreq) {\n          highFreqConjunction.add(booleanClause.getQuery(), Occur.MUST);\n        }\n        highFreqConjunction.setBoost(getBoost());\n        return highFreqConjunction;\n        \n      }\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":["a194d3ac4639a7909ea614667b9a7632a6aa14d1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58b6341c01680bddb99b9aa4697c800f1b1f3c02","date":1393514086,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(newTermQuery(queryTerms[i], null), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(newTermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(newTermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreq.getMinimumNumberShouldMatch() == 0 && highFreqOccur != Occur.MUST) {\n        for (BooleanClause booleanClause : highFreq) {\n            booleanClause.setOccur(Occur.MUST);\n        }\n      }\n      highFreq.setBoost(getBoost());\n      return highFreq;\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreq.getMinimumNumberShouldMatch() == 0 && highFreqOccur != Occur.MUST) {\n        for (BooleanClause booleanClause : highFreq) {\n            booleanClause.setOccur(Occur.MUST);\n        }\n      }\n      highFreq.setBoost(getBoost());\n      return highFreq;\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","date":1393532551,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(newTermQuery(queryTerms[i], null), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(newTermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(newTermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreq.getMinimumNumberShouldMatch() == 0 && highFreqOccur != Occur.MUST) {\n        for (BooleanClause booleanClause : highFreq) {\n            booleanClause.setOccur(Occur.MUST);\n        }\n      }\n      highFreq.setBoost(getBoost());\n      return highFreq;\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(new TermQuery(queryTerms[i]), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(new TermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(new TermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreq.getMinimumNumberShouldMatch() == 0 && highFreqOccur != Occur.MUST) {\n        for (BooleanClause booleanClause : highFreq) {\n            booleanClause.setOccur(Occur.MUST);\n        }\n      }\n      highFreq.setBoost(getBoost());\n      return highFreq;\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(true);\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      lowFreq.setDisableCoord(disableCoord);\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      lowFreqQuery.setBoost(lowFreqBoost);\n      builder.add(lowFreqQuery, Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      highFreq.setDisableCoord(disableCoord);\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      highFreqQuery.setBoost(highFreqBoost);\n      builder.add(highFreqQuery, Occur.SHOULD);\n    }\n    Query rewritten = builder.build();\n    rewritten.setBoost(getBoost());\n    return rewritten;\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    BooleanQuery lowFreq = new BooleanQuery(disableCoord);\n    BooleanQuery highFreq = new BooleanQuery(disableCoord);\n    highFreq.setBoost(highFreqBoost);\n    lowFreq.setBoost(lowFreqBoost);\n    BooleanQuery query = new BooleanQuery(true);\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreq.add(newTermQuery(queryTerms[i], null), lowFreqOccur);\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreq\n              .add(newTermQuery(queryTerms[i], termContext), highFreqOccur);\n        } else {\n          lowFreq.add(newTermQuery(queryTerms[i], termContext), lowFreqOccur);\n        }\n      }\n      \n    }\n    final int numLowFreqClauses = lowFreq.clauses().size();\n    final int numHighFreqClauses = highFreq.clauses().size();\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      int minMustMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n      lowFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      int minMustMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n      highFreq.setMinimumNumberShouldMatch(minMustMatch);\n    }\n    if (lowFreq.clauses().isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreq.getMinimumNumberShouldMatch() == 0 && highFreqOccur != Occur.MUST) {\n        for (BooleanClause booleanClause : highFreq) {\n            booleanClause.setOccur(Occur.MUST);\n        }\n      }\n      highFreq.setBoost(getBoost());\n      return highFreq;\n    } else if (highFreq.clauses().isEmpty()) {\n      // only do low freq terms - we don't have high freq terms\n      lowFreq.setBoost(getBoost());\n      return lowFreq;\n    } else {\n      query.add(highFreq, Occur.SHOULD);\n      query.add(lowFreq, Occur.MUST);\n      query.setBoost(getBoost());\n      return query;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(true);\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      lowFreq.setDisableCoord(disableCoord);\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      highFreq.setDisableCoord(disableCoord);\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(true);\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      lowFreq.setDisableCoord(disableCoord);\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      lowFreqQuery.setBoost(lowFreqBoost);\n      builder.add(lowFreqQuery, Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      highFreq.setDisableCoord(disableCoord);\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      highFreqQuery.setBoost(highFreqBoost);\n      builder.add(highFreqQuery, Occur.SHOULD);\n    }\n    Query rewritten = builder.build();\n    rewritten.setBoost(getBoost());\n    return rewritten;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(true);\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      lowFreq.setDisableCoord(disableCoord);\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      highFreq.setDisableCoord(disableCoord);\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(true);\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      lowFreq.setDisableCoord(disableCoord);\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      highFreq.setDisableCoord(disableCoord);\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermStates[],Term[]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":"  protected Query buildQuery(final int maxDoc,\n                             final TermStates[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermStates termStates = contextArray[i];\n      if (termStates == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termStates.docFreq() > maxTermFrequency)\n            || (termStates.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termStates));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termStates));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery#buildQuery(int,TermContext[],Term[]).mjava","sourceNew":null,"sourceOld":"  protected Query buildQuery(final int maxDoc,\n      final TermContext[] contextArray, final Term[] queryTerms) {\n    List<Query> lowFreqQueries = new ArrayList<>();\n    List<Query> highFreqQueries = new ArrayList<>();\n    for (int i = 0; i < queryTerms.length; i++) {\n      TermContext termContext = contextArray[i];\n      if (termContext == null) {\n        lowFreqQueries.add(newTermQuery(queryTerms[i], null));\n      } else {\n        if ((maxTermFrequency >= 1f && termContext.docFreq() > maxTermFrequency)\n            || (termContext.docFreq() > (int) Math.ceil(maxTermFrequency\n                * (float) maxDoc))) {\n          highFreqQueries\n              .add(newTermQuery(queryTerms[i], termContext));\n        } else {\n          lowFreqQueries.add(newTermQuery(queryTerms[i], termContext));\n        }\n      }\n    }\n    final int numLowFreqClauses = lowFreqQueries.size();\n    final int numHighFreqClauses = highFreqQueries.size();\n    Occur lowFreqOccur = this.lowFreqOccur;\n    Occur highFreqOccur = this.highFreqOccur;\n    int lowFreqMinShouldMatch = 0;\n    int highFreqMinShouldMatch = 0;\n    if (lowFreqOccur == Occur.SHOULD && numLowFreqClauses > 0) {\n      lowFreqMinShouldMatch = calcLowFreqMinimumNumberShouldMatch(numLowFreqClauses);\n    }\n    if (highFreqOccur == Occur.SHOULD && numHighFreqClauses > 0) {\n      highFreqMinShouldMatch = calcHighFreqMinimumNumberShouldMatch(numHighFreqClauses);\n    }\n    if (lowFreqQueries.isEmpty()) {\n      /*\n       * if lowFreq is empty we rewrite the high freq terms in a conjunction to\n       * prevent slow queries.\n       */\n      if (highFreqMinShouldMatch == 0 && highFreqOccur != Occur.MUST) {\n        highFreqOccur = Occur.MUST;\n      }\n    }\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n\n    if (lowFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder lowFreq = new BooleanQuery.Builder();\n      for (Query query : lowFreqQueries) {\n        lowFreq.add(query, lowFreqOccur);\n      }\n      lowFreq.setMinimumNumberShouldMatch(lowFreqMinShouldMatch);\n      Query lowFreqQuery = lowFreq.build();\n      builder.add(new BoostQuery(lowFreqQuery, lowFreqBoost), Occur.MUST);\n    }\n    if (highFreqQueries.isEmpty() == false) {\n      BooleanQuery.Builder highFreq = new BooleanQuery.Builder();\n      for (Query query : highFreqQueries) {\n        highFreq.add(query, highFreqOccur);\n      }\n      highFreq.setMinimumNumberShouldMatch(highFreqMinShouldMatch);\n      Query highFreqQuery = highFreq.build();\n      builder.add(new BoostQuery(highFreqQuery, highFreqBoost), Occur.SHOULD);\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","88428cf23f55c2838f471aaeaa18fa26805315c9"],"b94236357aaa22b76c10629851fe4e376e0cea82":["c8a0e442f7b61f811680273b25da95994a724466","a6e9f769521480a623f897c0d59089b919fa4239"],"58b6341c01680bddb99b9aa4697c800f1b1f3c02":["caa296dfe1eb42df2bff22b952e189a68100fc2b"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a194d3ac4639a7909ea614667b9a7632a6aa14d1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"de522d9303bd67c8473a269a1319125d1f3700e0":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9aa8b576db3a2ef44791da3c24b9d0b61c236c11"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["2dfdf766e55e943d942055d7de53c7ad6bc45283","c8a0e442f7b61f811680273b25da95994a724466"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":["caa296dfe1eb42df2bff22b952e189a68100fc2b","58b6341c01680bddb99b9aa4697c800f1b1f3c02"],"b752e241723380b5fdabe8364f28fd5639ebf08c":["a194d3ac4639a7909ea614667b9a7632a6aa14d1"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["58b6341c01680bddb99b9aa4697c800f1b1f3c02"],"a6e9f769521480a623f897c0d59089b919fa4239":["c8a0e442f7b61f811680273b25da95994a724466"],"9aa8b576db3a2ef44791da3c24b9d0b61c236c11":["88428cf23f55c2838f471aaeaa18fa26805315c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"caa296dfe1eb42df2bff22b952e189a68100fc2b":["620f2c9cd3df8f77948c19b3165b5dc20700a5d5"],"620f2c9cd3df8f77948c19b3165b5dc20700a5d5":["9aa8b576db3a2ef44791da3c24b9d0b61c236c11"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9aa8b576db3a2ef44791da3c24b9d0b61c236c11"],"c8a0e442f7b61f811680273b25da95994a724466":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"88428cf23f55c2838f471aaeaa18fa26805315c9":["b752e241723380b5fdabe8364f28fd5639ebf08c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["de522d9303bd67c8473a269a1319125d1f3700e0"],"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58b6341c01680bddb99b9aa4697c800f1b1f3c02":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"a194d3ac4639a7909ea614667b9a7632a6aa14d1":["b752e241723380b5fdabe8364f28fd5639ebf08c"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":[],"b752e241723380b5fdabe8364f28fd5639ebf08c":["88428cf23f55c2838f471aaeaa18fa26805315c9"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"9aa8b576db3a2ef44791da3c24b9d0b61c236c11":["de522d9303bd67c8473a269a1319125d1f3700e0","620f2c9cd3df8f77948c19b3165b5dc20700a5d5","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a194d3ac4639a7909ea614667b9a7632a6aa14d1"],"caa296dfe1eb42df2bff22b952e189a68100fc2b":["58b6341c01680bddb99b9aa4697c800f1b1f3c02","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8"],"620f2c9cd3df8f77948c19b3165b5dc20700a5d5":["caa296dfe1eb42df2bff22b952e189a68100fc2b"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"c8a0e442f7b61f811680273b25da95994a724466":["b94236357aaa22b76c10629851fe4e376e0cea82","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a6e9f769521480a623f897c0d59089b919fa4239"],"88428cf23f55c2838f471aaeaa18fa26805315c9":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9aa8b576db3a2ef44791da3c24b9d0b61c236c11"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["de522d9303bd67c8473a269a1319125d1f3700e0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}