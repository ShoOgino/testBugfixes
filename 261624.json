{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","commits":[{"id":"f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e","date":1487462440,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9b4296bd51ca61b482138791478afdd0f7d3a3d","date":1498058739,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n    log.info(\"Datcmzz \" + shardRequestCaptor.getAllValues().size());\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"651c3ddf5bc1266d9de0a972ec05e59d77099a4c","date":1500969855,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = coreNames.get((i-1) * numberOfReplica + (j-1));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = coreNames.get((i-1) * numberOfReplica + (j-1));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionConfigSetProcessorTest#verifySubmitCaptures(Integer,Integer,Collection[String],boolean).mjava","sourceNew":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = coreNames.get((i-1) * numberOfReplica + (j-1));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n\n    ArgumentCaptor<ShardRequest> shardRequestCaptor = ArgumentCaptor.forClass(ShardRequest.class);\n    ArgumentCaptor<String> nodeUrlsWithoutProtocolPartCaptor = ArgumentCaptor.forClass(String.class);\n    ArgumentCaptor<ModifiableSolrParams> paramsCaptor = ArgumentCaptor.forClass(ModifiableSolrParams.class);\n    verify(shardHandlerMock, times(numberOfReplica * numberOfSlices))\n        .submit(shardRequestCaptor.capture(), nodeUrlsWithoutProtocolPartCaptor.capture(), paramsCaptor.capture());\n\n    for (int i = 0; i < shardRequestCaptor.getAllValues().size(); i++) {\n      ShardRequest shardRequest = shardRequestCaptor.getAllValues().get(i);\n      String nodeUrlsWithoutProtocolPartCapture = nodeUrlsWithoutProtocolPartCaptor.getAllValues().get(i);\n      ModifiableSolrParams params = paramsCaptor.getAllValues().get(i);\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(nodeUrlsWithoutProtocolPartCapture,\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = Assign.buildCoreName(COLLECTION_NAME, \"shard\" + i, Replica.Type.NRT, j);\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["28288370235ed02234a64753cdbf0c6ec096304a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e","61c45e99cf6676da48f19d7511c73712ad39402b"],"a52341299179de5479672f7cf518bf4b173f34b3":["28288370235ed02234a64753cdbf0c6ec096304a","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"61c45e99cf6676da48f19d7511c73712ad39402b":["f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"936cdd5882761db3b844afd6f84ab81cbb011a75":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["e9017cf144952056066919f1ebc7897ff9bd71b1","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"28288370235ed02234a64753cdbf0c6ec096304a":["61c45e99cf6676da48f19d7511c73712ad39402b","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a52341299179de5479672f7cf518bf4b173f34b3"]},"commit2Childs":{"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["a52341299179de5479672f7cf518bf4b173f34b3","936cdd5882761db3b844afd6f84ab81cbb011a75"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"a52341299179de5479672f7cf518bf4b173f34b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","a9b4296bd51ca61b482138791478afdd0f7d3a3d","28288370235ed02234a64753cdbf0c6ec096304a"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"f7a0f6f6b8a4cc8b82386e74e45ab3c097f2453e":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["936cdd5882761db3b844afd6f84ab81cbb011a75"],"28288370235ed02234a64753cdbf0c6ec096304a":["651c3ddf5bc1266d9de0a972ec05e59d77099a4c","a52341299179de5479672f7cf518bf4b173f34b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}