{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryUpdateDocValue(IndexReader,int,Field...).mjava","commits":[{"id":"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd","date":1525696559,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryUpdateDocValue(IndexReader,int,Field...).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: attempts to update doc values by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the update succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  either retry the update and resolve the document again.\n   *\n   *  <b>NOTE</b>: this method can only updates documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to update documents indexed after opening the NRT\n   *  reader you must use {@link #updateDocValues(Term, Field...)}. */\n  public synchronized long tryUpdateDocValue(IndexReader readerIn, int docID, Field... fields) throws IOException {\n    // NOTE: DON'T use docID inside the closure\n    final DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(null, fields);\n    return tryModifyDocument(readerIn, docID, (leafDocId, rld) -> {\n      long nextGen = bufferedUpdatesStream.getNextGen();\n      try {\n        Map<String, DocValuesFieldUpdates> fieldUpdatesMap = new HashMap<>();\n        for (DocValuesUpdate update : dvUpdates) {\n          DocValuesFieldUpdates docValuesFieldUpdates = fieldUpdatesMap.computeIfAbsent(update.field, k -> {\n            switch (update.type) {\n              case NUMERIC:\n                return new NumericDocValuesFieldUpdates(nextGen, k, rld.info.info.maxDoc());\n              case BINARY:\n                return new BinaryDocValuesFieldUpdates(nextGen, k, rld.info.info.maxDoc());\n              default:\n                throw new AssertionError(\"type: \" + update.type + \" is not supported\");\n            }\n          });\n          switch (update.type) {\n            case NUMERIC:\n              docValuesFieldUpdates.add(leafDocId, ((NumericDocValuesUpdate) update).value);\n              break;\n            case BINARY:\n              docValuesFieldUpdates.add(leafDocId, ((BinaryDocValuesUpdate) update).value);\n              break;\n            default:\n              throw new AssertionError(\"type: \" + update.type + \" is not supported\");\n          }\n        }\n        for (DocValuesFieldUpdates updates : fieldUpdatesMap.values()) {\n          updates.finish();\n          rld.addDVUpdate(updates);\n        }\n      } finally {\n        bufferedUpdatesStream.finishedSegment(nextGen);\n      }\n      // Must bump changeCount so if no other changes\n      // happened, we still commit this change:\n      changed();\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33adea025f43af3243278587a46b8d9fd2e8ccf9","date":1525885077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryUpdateDocValue(IndexReader,int,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryUpdateDocValue(IndexReader,int,Field...).mjava","sourceNew":"  /** Expert: attempts to update doc values by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the update succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  either retry the update and resolve the document again.\n   *  If a doc values fields data is <code>null</code> the existing\n   *  value is removed from all documents matching the term. This can be used\n   *  to un-delete a soft-deleted document since this method will apply the\n   *  field update even if the document is marked as deleted.\n   *\n   *  <b>NOTE</b>: this method can only updates documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to update documents indexed after opening the NRT\n   *  reader you must use {@link #updateDocValues(Term, Field...)}. */\n  public synchronized long tryUpdateDocValue(IndexReader readerIn, int docID, Field... fields) throws IOException {\n    // NOTE: DON'T use docID inside the closure\n    final DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(null, fields);\n    return tryModifyDocument(readerIn, docID, (leafDocId, rld) -> {\n      long nextGen = bufferedUpdatesStream.getNextGen();\n      try {\n        Map<String, DocValuesFieldUpdates> fieldUpdatesMap = new HashMap<>();\n        for (DocValuesUpdate update : dvUpdates) {\n          DocValuesFieldUpdates docValuesFieldUpdates = fieldUpdatesMap.computeIfAbsent(update.field, k -> {\n            switch (update.type) {\n              case NUMERIC:\n                return new NumericDocValuesFieldUpdates(nextGen, k, rld.info.info.maxDoc());\n              case BINARY:\n                return new BinaryDocValuesFieldUpdates(nextGen, k, rld.info.info.maxDoc());\n              default:\n                throw new AssertionError(\"type: \" + update.type + \" is not supported\");\n            }\n          });\n          if (update.hasValue()) {\n            switch (update.type) {\n              case NUMERIC:\n                docValuesFieldUpdates.add(leafDocId, ((NumericDocValuesUpdate) update).getValue());\n                break;\n              case BINARY:\n                docValuesFieldUpdates.add(leafDocId, ((BinaryDocValuesUpdate) update).getValue());\n                break;\n              default:\n                throw new AssertionError(\"type: \" + update.type + \" is not supported\");\n            }\n          } else {\n            docValuesFieldUpdates.reset(leafDocId);\n          }\n        }\n        for (DocValuesFieldUpdates updates : fieldUpdatesMap.values()) {\n          updates.finish();\n          rld.addDVUpdate(updates);\n        }\n      } finally {\n        bufferedUpdatesStream.finishedSegment(nextGen);\n      }\n      // Must bump changeCount so if no other changes\n      // happened, we still commit this change:\n      changed();\n    });\n  }\n\n","sourceOld":"  /** Expert: attempts to update doc values by document ID, as long as\n   *  the provided reader is a near-real-time reader (from {@link\n   *  DirectoryReader#open(IndexWriter)}).  If the\n   *  provided reader is an NRT reader obtained from this\n   *  writer, and its segment has not been merged away, then\n   *  the update succeeds and this method returns a valid (&gt; 0) sequence\n   *  number; else, it returns -1 and the caller must then\n   *  either retry the update and resolve the document again.\n   *\n   *  <b>NOTE</b>: this method can only updates documents\n   *  visible to the currently open NRT reader.  If you need\n   *  to update documents indexed after opening the NRT\n   *  reader you must use {@link #updateDocValues(Term, Field...)}. */\n  public synchronized long tryUpdateDocValue(IndexReader readerIn, int docID, Field... fields) throws IOException {\n    // NOTE: DON'T use docID inside the closure\n    final DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(null, fields);\n    return tryModifyDocument(readerIn, docID, (leafDocId, rld) -> {\n      long nextGen = bufferedUpdatesStream.getNextGen();\n      try {\n        Map<String, DocValuesFieldUpdates> fieldUpdatesMap = new HashMap<>();\n        for (DocValuesUpdate update : dvUpdates) {\n          DocValuesFieldUpdates docValuesFieldUpdates = fieldUpdatesMap.computeIfAbsent(update.field, k -> {\n            switch (update.type) {\n              case NUMERIC:\n                return new NumericDocValuesFieldUpdates(nextGen, k, rld.info.info.maxDoc());\n              case BINARY:\n                return new BinaryDocValuesFieldUpdates(nextGen, k, rld.info.info.maxDoc());\n              default:\n                throw new AssertionError(\"type: \" + update.type + \" is not supported\");\n            }\n          });\n          switch (update.type) {\n            case NUMERIC:\n              docValuesFieldUpdates.add(leafDocId, ((NumericDocValuesUpdate) update).value);\n              break;\n            case BINARY:\n              docValuesFieldUpdates.add(leafDocId, ((BinaryDocValuesUpdate) update).value);\n              break;\n            default:\n              throw new AssertionError(\"type: \" + update.type + \" is not supported\");\n          }\n        }\n        for (DocValuesFieldUpdates updates : fieldUpdatesMap.values()) {\n          updates.finish();\n          rld.addDVUpdate(updates);\n        }\n      } finally {\n        bufferedUpdatesStream.finishedSegment(nextGen);\n      }\n      // Must bump changeCount so if no other changes\n      // happened, we still commit this change:\n      changed();\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["33adea025f43af3243278587a46b8d9fd2e8ccf9"]},"commit2Childs":{"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}