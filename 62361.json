{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","commits":[{"id":"6b496a51639fc02b2ff28d1b029b37e42f6c7627","date":1347885256,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestRollingCharBuffer#test().mjava","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = TestUtil.nextInt(random, nextRead - availCount, nextRead - 1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = _TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = _TestUtil.nextInt(random, nextRead-availCount, nextRead-1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = _TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/util/TestRollingCharBuffer#test().mjava","sourceNew":"  public void test() throws Exception {\n    final int ITERS = atLeast(100);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = TestUtil.nextInt(random, nextRead - availCount, nextRead - 1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n    final int ITERS = atLeast(1000);\n    \n    RollingCharBuffer buffer = new RollingCharBuffer();\n\n    Random random = random();\n    for(int iter=0;iter<ITERS;iter++) {\n      final int stringLen = random.nextBoolean() ? random.nextInt(50) : random.nextInt(20000);\n      final String s;\n      if (stringLen == 0) {\n        s = \"\";\n      } else {\n        s = TestUtil.randomUnicodeString(random, stringLen);\n      }\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" s.length()=\" + s.length());\n      }\n      buffer.reset(new StringReader(s));\n      int nextRead = 0;\n      int availCount = 0;\n      while(nextRead < s.length()) {\n        if (VERBOSE) {\n          System.out.println(\"  cycle nextRead=\" + nextRead + \" avail=\" + availCount);\n        }\n        if (availCount == 0 || random.nextBoolean()) {\n          // Read next char\n          if (VERBOSE) {\n            System.out.println(\"    new char\");\n          }\n          assertEquals(s.charAt(nextRead), buffer.get(nextRead));\n          nextRead++;\n          availCount++;\n        } else if (random.nextBoolean()) {\n          // Read previous char\n          int pos = TestUtil.nextInt(random, nextRead - availCount, nextRead - 1);\n          if (VERBOSE) {\n            System.out.println(\"    old char pos=\" + pos);\n          }\n          assertEquals(s.charAt(pos), buffer.get(pos));\n        } else {\n          // Read slice\n          int length;\n          if (availCount == 1) {\n            length = 1;\n          } else {\n            length = TestUtil.nextInt(random, 1, availCount);\n          }\n          int start;\n          if (length == availCount) {\n            start = nextRead - availCount;\n          } else {\n            start = nextRead - availCount + random.nextInt(availCount-length);\n          }\n          if (VERBOSE) {\n            System.out.println(\"    slice start=\" + start + \" length=\" + length);\n          }\n          assertEquals(s.substring(start, start+length),\n                       new String(buffer.get(start, length)));\n        }\n\n        if (availCount > 0 && random.nextInt(20) == 17) {\n          final int toFree = random.nextInt(availCount);\n          if (VERBOSE) {\n            System.out.println(\"    free \" + toFree + \" (avail=\" + (availCount-toFree) + \")\");\n          }\n          buffer.freeBefore(nextRead-(availCount-toFree));\n          availCount -= toFree;\n        }\n      }\n    }\n  }\n\n","bugFix":["0984ad47974c2d5d354519ddb2aa8358973a6271"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6613659748fe4411a7dcf85266e55db1f95f7315":["6b496a51639fc02b2ff28d1b029b37e42f6c7627"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6b496a51639fc02b2ff28d1b029b37e42f6c7627":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71da933d30aea361ccc224d6544c451cbf49916d"],"71da933d30aea361ccc224d6544c451cbf49916d":["6613659748fe4411a7dcf85266e55db1f95f7315"]},"commit2Childs":{"6613659748fe4411a7dcf85266e55db1f95f7315":["71da933d30aea361ccc224d6544c451cbf49916d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6b496a51639fc02b2ff28d1b029b37e42f6c7627"],"6b496a51639fc02b2ff28d1b029b37e42f6c7627":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"71da933d30aea361ccc224d6544c451cbf49916d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}