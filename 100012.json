{"path":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#sendRequest(Request,int).mjava","commits":[{"id":"bc6055f4a2e8e9f9caaec2297010c9502480ed69","date":1050060580,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#sendRequest(Request,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * sends the request over the line.\n     *\n     * @param req                  the request\n     * @param con_timeout          the timeout to use when establishing a socket\n     *      connection; an InterruptedIOException is thrown if the procedure\n     *      times out.\n     * @return                     Description of the Return Value\n     * @exception IOException      if thrown by the socket\n     * @exception ModuleException  if any module throws it during the SSL-\n     *      tunneling handshake\n     */\n    Response sendRequest(Request req, int con_timeout)\n        throws IOException, ModuleException\n    {\n        ByteArrayOutputStream hdr_buf = new ByteArrayOutputStream(600);\n        Response resp = null;\n        boolean keep_alive;\n\n        // The very first request is special in that we need its response\n        // before any further requests may be made. This is to set things\n        // like the server version.\n\n        if (early_stall != null)\n        {\n            try\n            {\n                Log.write(Log.CONN, \"Conn:  Early-stalling Request: \" +\n                        req.getMethod() + \" \" +\n                        req.getRequestURI());\n\n                synchronized (early_stall)\n                {\n                    // wait till the response is received\n                    try\n                    {\n                        early_stall.getVersion();\n                    }\n                    catch (IOException ioe)\n                    {\n                    }\n                    early_stall = null;\n                }\n            }\n            catch (NullPointerException npe)\n            {\n            }\n        }\n\n        String[] con_hdrs = assembleHeaders(req, hdr_buf);\n\n        // determine if the connection should be kept alive after this\n        // request\n\n        try\n        {\n            if (ServerProtocolVersion >= HTTP_1_1 &&\n                    !Util.hasToken(con_hdrs[0], \"close\")\n                     ||\n                    ServerProtocolVersion == HTTP_1_0 &&\n                    Util.hasToken(con_hdrs[0], \"keep-alive\")\n                    )\n            {\n                keep_alive = true;\n            }\n            else\n            {\n                keep_alive = false;\n            }\n        }\n        catch (ParseException pe)\n        {\n            throw new IOException(pe.toString());\n        }\n\n        synchronized (this)\n        {\n            // Sometimes we must stall the pipeline until the previous request\n            // has been answered. However, if we are going to open up a new\n            // connection anyway we don't really need to stall.\n\n            if (late_stall != null)\n            {\n                if (input_demux != null || keepAliveUnknown)\n                {\n                    Log.write(Log.CONN, \"Conn:  Stalling Request: \" +\n                            req.getMethod() + \" \" + req.getRequestURI());\n\n                    try\n                    {\n                        // wait till the response is received\n\n                        late_stall.getVersion();\n                        if (keepAliveUnknown)\n                        {\n                            determineKeepAlive(late_stall);\n                        }\n                    }\n                    catch (IOException ioe)\n                    {\n                    }\n                }\n\n                late_stall = null;\n            }\n\n            /*\n             *  POSTs must not be pipelined because of problems if the connection\n             *  is aborted. Since it is generally impossible to know what urls\n             *  POST will influence it is impossible to determine if a sequence\n             *  of requests containing a POST is idempotent.\n             *  Also, for retried requests we don't want to pipeline either.\n             */\n            if ((req.getMethod().equals(\"POST\") || req.dont_pipeline) &&\n                    prev_resp != null && input_demux != null)\n            {\n                Log.write(Log.CONN, \"Conn:  Stalling Request: \" +\n                        req.getMethod() + \" \" + req.getRequestURI());\n\n                try\n                {\n                    // wait till the response is received\n                    prev_resp.getVersion();\n                }\n                catch (IOException ioe)\n                {\n                }\n            }\n\n            // If the previous request used an output stream, then wait till\n            // all the data has been written\n\n            if (!output_finished)\n            {\n                try\n                {\n                    wait();\n                }\n                catch (InterruptedException ie)\n                {\n                    throw new IOException(ie.toString());\n                }\n            }\n\n            if (req.aborted)\n            {\n                throw new IOException(\"Request aborted by user\");\n            }\n\n            int try_count = 3;\n            /*\n             *  what a hack! This is to handle the case where the server closes\n             *  the connection but we don't realize it until we try to send\n             *  something. The problem is that we only get IOException, but\n             *  we need a finer specification (i.e. whether it's an EPIPE or\n             *  something else); I don't trust relying on the message part\n             *  of IOException (which on SunOS/Solaris gives 'Broken pipe',\n             *  but what on Windoze/Mac?).\n             */\n            while (try_count-- > 0)\n            {\n                try\n                {\n                    // get a client socket\n\n                    Socket sock;\n                    if (input_demux == null ||\n                            (sock = input_demux.getSocket()) == null)\n                    {\n                        sock = getSocket(con_timeout);\n\n                        if (Protocol == HTTPS)\n                        {\n                            if (Proxy_Host != null)\n                            {\n                                Socket[] sarr = {sock};\n                                resp = enableSSLTunneling(sarr, req, con_timeout);\n                                if (resp != null)\n                                {\n                                    resp.final_resp = true;\n                                    return resp;\n                                }\n                                sock = sarr[0];\n                            }\n\n                            sock.setSoTimeout(con_timeout);\n                            //sock = new SSLSocket(sock);\n                        }\n\n                        input_demux = new StreamDemultiplexor(Protocol, sock, this);\n                        DemuxList.addToEnd(input_demux);\n                        keepAliveReqLeft = keepAliveReqMax;\n                    }\n\n                    if (req.aborted)\n                    {\n                        throw new IOException(\"Request aborted by user\");\n                    }\n\n                    Log.write(Log.CONN, \"Conn:  Sending Request: \", hdr_buf);\n\n                    // Send headers\n\n                    OutputStream sock_out = sock.getOutputStream();\n                    if (haveMSLargeWritesBug)\n                    {\n                        sock_out = new MSLargeWritesBugStream(sock_out);\n                    }\n\n                    hdr_buf.writeTo(sock_out);\n\n                    // Wait for \"100 Continue\" status if necessary\n\n                    try\n                    {\n                        if (ServProtVersKnown &&\n                                ServerProtocolVersion >= HTTP_1_1 &&\n                                Util.hasToken(con_hdrs[1], \"100-continue\"))\n                        {\n                            resp = new Response(req, (Proxy_Host != null && Protocol != HTTPS), input_demux);\n                            resp.timeout = 60;\n                            if (resp.getContinue() != 100)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    catch (ParseException pe)\n                    {\n                        throw new IOException(pe.toString());\n                    }\n                    catch (InterruptedIOException iioe)\n                    {\n                    }\n                    finally\n                    {\n                        if (resp != null)\n                        {\n                            resp.timeout = 0;\n                        }\n                    }\n\n                    // POST/PUT data\n\n                    if (req.getData() != null && req.getData().length > 0)\n                    {\n                        if (req.delay_entity > 0)\n                        {\n                            // wait for something on the network; check available()\n                            // roughly every 100 ms\n\n                            long num_units = req.delay_entity / 100;\n                            long one_unit = req.delay_entity / num_units;\n\n                            for (int idx = 0; idx < num_units; idx++)\n                            {\n                                if (input_demux.available(null) != 0)\n                                {\n                                    break;\n                                }\n                                try\n                                {\n                                    Thread.sleep(one_unit);\n                                }\n                                catch (InterruptedException ie)\n                                {\n                                }\n                            }\n\n                            if (input_demux.available(null) == 0)\n                            {\n                                sock_out.write(req.getData());\n                            }\n                            // he's still waiting\n                            else\n                            {\n                                keep_alive = false;\n                            }\n                            // Uh oh!\n                        }\n                        else\n                        {\n                            sock_out.write(req.getData());\n                        }\n                    }\n\n                    if (req.getStream() != null)\n                    {\n                        req.getStream().goAhead(req, sock_out, 0);\n                    }\n                    else\n                    {\n                        sock_out.flush();\n                    }\n\n                    // get a new response.\n                    // Note: this does not do a read on the socket.\n\n                    if (resp == null)\n                    {\n                        resp = new Response(req, (Proxy_Host != null &&\n                                Protocol != HTTPS),\n                                input_demux);\n                    }\n                }\n                catch (IOException ioe)\n                {\n                    Log.write(Log.CONN, \"Conn:  \", ioe);\n\n                    closeDemux(ioe, true);\n\n                    if (try_count == 0 || ioe instanceof UnknownHostException ||\n                            ioe instanceof ConnectException ||\n                            ioe instanceof NoRouteToHostException ||\n                            ioe instanceof InterruptedIOException || req.aborted)\n                    {\n                        throw ioe;\n                    }\n\n                    Log.write(Log.CONN, \"Conn:  Retrying request\");\n                    continue;\n                }\n\n                break;\n            }\n\n            prev_resp = resp;\n\n            // close the stream after this response if necessary\n\n            if ((!keepAliveUnknown && !doesKeepAlive) || !keep_alive ||\n                    (keepAliveReqMax != -1 && keepAliveReqLeft-- == 0))\n            {\n                input_demux.markForClose(resp);\n                input_demux = null;\n            }\n            else\n            {\n                input_demux.restartTimer();\n            }\n\n            if (keepAliveReqMax != -1)\n            {\n                Log.write(Log.CONN, \"Conn:  Number of requests left: \" +\n                        keepAliveReqLeft);\n            }\n\n            /*\n             *  We don't pipeline the first request, as we need some info\n             *  about the server (such as which http version it complies with)\n             */\n            if (!ServProtVersKnown)\n            {\n                early_stall = resp;\n                resp.markAsFirstResponse(req);\n            }\n\n            /*\n             *  Also don't pipeline until we know if the server supports\n             *  keep-alive's or not.\n             *  Note: strictly speaking, HTTP/1.0 keep-alives don't mean we can\n             *  pipeline requests. I seem to remember some (beta?) version\n             *  of Netscape's Enterprise server which barfed if you tried\n             *  push requests down it's throat w/o waiting for the previous\n             *  response first. However, I've not been able to find such a\n             *  server lately, and so I'm taking the risk and assuming we\n             *  can in fact pipeline requests to HTTP/1.0 servers.\n             */\n            if (keepAliveUnknown ||\n            // We don't pipeline POST's ...\n                    !IdempotentSequence.methodIsIdempotent(req.getMethod()) ||\n                    req.dont_pipeline ||\n            // Retries disable pipelining too\n                    neverPipeline)\n            {\n                // Emergency measure: prevent all pipelining\n                late_stall = resp;\n            }\n\n            /*\n             *  If there is an output stream then just tell the other threads to\n             *  wait; the stream will notify() when it's done. If there isn't any\n             *  stream then wake up a waiting thread (if any).\n             */\n            if (req.getStream() != null)\n            {\n                output_finished = false;\n            }\n            else\n            {\n                output_finished = true;\n                notify();\n            }\n\n            // Looks like were finally done\n\n            Log.write(Log.CONN, \"Conn:  Request sent\");\n        }\n\n        return resp;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#sendRequest(Request,int).mjava","sourceNew":null,"sourceOld":"    /**\n     * sends the request over the line.\n     *\n     * @param req                  the request\n     * @param con_timeout          the timeout to use when establishing a socket\n     *      connection; an InterruptedIOException is thrown if the procedure\n     *      times out.\n     * @return                     Description of the Return Value\n     * @exception IOException      if thrown by the socket\n     * @exception ModuleException  if any module throws it during the SSL-\n     *      tunneling handshake\n     */\n    Response sendRequest(Request req, int con_timeout)\n        throws IOException, ModuleException\n    {\n        ByteArrayOutputStream hdr_buf = new ByteArrayOutputStream(600);\n        Response resp = null;\n        boolean keep_alive;\n\n        // The very first request is special in that we need its response\n        // before any further requests may be made. This is to set things\n        // like the server version.\n\n        if (early_stall != null)\n        {\n            try\n            {\n                Log.write(Log.CONN, \"Conn:  Early-stalling Request: \" +\n                        req.getMethod() + \" \" +\n                        req.getRequestURI());\n\n                synchronized (early_stall)\n                {\n                    // wait till the response is received\n                    try\n                    {\n                        early_stall.getVersion();\n                    }\n                    catch (IOException ioe)\n                    {\n                    }\n                    early_stall = null;\n                }\n            }\n            catch (NullPointerException npe)\n            {\n            }\n        }\n\n        String[] con_hdrs = assembleHeaders(req, hdr_buf);\n\n        // determine if the connection should be kept alive after this\n        // request\n\n        try\n        {\n            if (ServerProtocolVersion >= HTTP_1_1 &&\n                    !Util.hasToken(con_hdrs[0], \"close\")\n                     ||\n                    ServerProtocolVersion == HTTP_1_0 &&\n                    Util.hasToken(con_hdrs[0], \"keep-alive\")\n                    )\n            {\n                keep_alive = true;\n            }\n            else\n            {\n                keep_alive = false;\n            }\n        }\n        catch (ParseException pe)\n        {\n            throw new IOException(pe.toString());\n        }\n\n        synchronized (this)\n        {\n            // Sometimes we must stall the pipeline until the previous request\n            // has been answered. However, if we are going to open up a new\n            // connection anyway we don't really need to stall.\n\n            if (late_stall != null)\n            {\n                if (input_demux != null || keepAliveUnknown)\n                {\n                    Log.write(Log.CONN, \"Conn:  Stalling Request: \" +\n                            req.getMethod() + \" \" + req.getRequestURI());\n\n                    try\n                    {\n                        // wait till the response is received\n\n                        late_stall.getVersion();\n                        if (keepAliveUnknown)\n                        {\n                            determineKeepAlive(late_stall);\n                        }\n                    }\n                    catch (IOException ioe)\n                    {\n                    }\n                }\n\n                late_stall = null;\n            }\n\n            /*\n             *  POSTs must not be pipelined because of problems if the connection\n             *  is aborted. Since it is generally impossible to know what urls\n             *  POST will influence it is impossible to determine if a sequence\n             *  of requests containing a POST is idempotent.\n             *  Also, for retried requests we don't want to pipeline either.\n             */\n            if ((req.getMethod().equals(\"POST\") || req.dont_pipeline) &&\n                    prev_resp != null && input_demux != null)\n            {\n                Log.write(Log.CONN, \"Conn:  Stalling Request: \" +\n                        req.getMethod() + \" \" + req.getRequestURI());\n\n                try\n                {\n                    // wait till the response is received\n                    prev_resp.getVersion();\n                }\n                catch (IOException ioe)\n                {\n                }\n            }\n\n            // If the previous request used an output stream, then wait till\n            // all the data has been written\n\n            if (!output_finished)\n            {\n                try\n                {\n                    wait();\n                }\n                catch (InterruptedException ie)\n                {\n                    throw new IOException(ie.toString());\n                }\n            }\n\n            if (req.aborted)\n            {\n                throw new IOException(\"Request aborted by user\");\n            }\n\n            int try_count = 3;\n            /*\n             *  what a hack! This is to handle the case where the server closes\n             *  the connection but we don't realize it until we try to send\n             *  something. The problem is that we only get IOException, but\n             *  we need a finer specification (i.e. whether it's an EPIPE or\n             *  something else); I don't trust relying on the message part\n             *  of IOException (which on SunOS/Solaris gives 'Broken pipe',\n             *  but what on Windoze/Mac?).\n             */\n            while (try_count-- > 0)\n            {\n                try\n                {\n                    // get a client socket\n\n                    Socket sock;\n                    if (input_demux == null ||\n                            (sock = input_demux.getSocket()) == null)\n                    {\n                        sock = getSocket(con_timeout);\n\n                        if (Protocol == HTTPS)\n                        {\n                            if (Proxy_Host != null)\n                            {\n                                Socket[] sarr = {sock};\n                                resp = enableSSLTunneling(sarr, req, con_timeout);\n                                if (resp != null)\n                                {\n                                    resp.final_resp = true;\n                                    return resp;\n                                }\n                                sock = sarr[0];\n                            }\n\n                            sock.setSoTimeout(con_timeout);\n                            //sock = new SSLSocket(sock);\n                        }\n\n                        input_demux = new StreamDemultiplexor(Protocol, sock, this);\n                        DemuxList.addToEnd(input_demux);\n                        keepAliveReqLeft = keepAliveReqMax;\n                    }\n\n                    if (req.aborted)\n                    {\n                        throw new IOException(\"Request aborted by user\");\n                    }\n\n                    Log.write(Log.CONN, \"Conn:  Sending Request: \", hdr_buf);\n\n                    // Send headers\n\n                    OutputStream sock_out = sock.getOutputStream();\n                    if (haveMSLargeWritesBug)\n                    {\n                        sock_out = new MSLargeWritesBugStream(sock_out);\n                    }\n\n                    hdr_buf.writeTo(sock_out);\n\n                    // Wait for \"100 Continue\" status if necessary\n\n                    try\n                    {\n                        if (ServProtVersKnown &&\n                                ServerProtocolVersion >= HTTP_1_1 &&\n                                Util.hasToken(con_hdrs[1], \"100-continue\"))\n                        {\n                            resp = new Response(req, (Proxy_Host != null && Protocol != HTTPS), input_demux);\n                            resp.timeout = 60;\n                            if (resp.getContinue() != 100)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    catch (ParseException pe)\n                    {\n                        throw new IOException(pe.toString());\n                    }\n                    catch (InterruptedIOException iioe)\n                    {\n                    }\n                    finally\n                    {\n                        if (resp != null)\n                        {\n                            resp.timeout = 0;\n                        }\n                    }\n\n                    // POST/PUT data\n\n                    if (req.getData() != null && req.getData().length > 0)\n                    {\n                        if (req.delay_entity > 0)\n                        {\n                            // wait for something on the network; check available()\n                            // roughly every 100 ms\n\n                            long num_units = req.delay_entity / 100;\n                            long one_unit = req.delay_entity / num_units;\n\n                            for (int idx = 0; idx < num_units; idx++)\n                            {\n                                if (input_demux.available(null) != 0)\n                                {\n                                    break;\n                                }\n                                try\n                                {\n                                    Thread.sleep(one_unit);\n                                }\n                                catch (InterruptedException ie)\n                                {\n                                }\n                            }\n\n                            if (input_demux.available(null) == 0)\n                            {\n                                sock_out.write(req.getData());\n                            }\n                            // he's still waiting\n                            else\n                            {\n                                keep_alive = false;\n                            }\n                            // Uh oh!\n                        }\n                        else\n                        {\n                            sock_out.write(req.getData());\n                        }\n                    }\n\n                    if (req.getStream() != null)\n                    {\n                        req.getStream().goAhead(req, sock_out, 0);\n                    }\n                    else\n                    {\n                        sock_out.flush();\n                    }\n\n                    // get a new response.\n                    // Note: this does not do a read on the socket.\n\n                    if (resp == null)\n                    {\n                        resp = new Response(req, (Proxy_Host != null &&\n                                Protocol != HTTPS),\n                                input_demux);\n                    }\n                }\n                catch (IOException ioe)\n                {\n                    Log.write(Log.CONN, \"Conn:  \", ioe);\n\n                    closeDemux(ioe, true);\n\n                    if (try_count == 0 || ioe instanceof UnknownHostException ||\n                            ioe instanceof ConnectException ||\n                            ioe instanceof NoRouteToHostException ||\n                            ioe instanceof InterruptedIOException || req.aborted)\n                    {\n                        throw ioe;\n                    }\n\n                    Log.write(Log.CONN, \"Conn:  Retrying request\");\n                    continue;\n                }\n\n                break;\n            }\n\n            prev_resp = resp;\n\n            // close the stream after this response if necessary\n\n            if ((!keepAliveUnknown && !doesKeepAlive) || !keep_alive ||\n                    (keepAliveReqMax != -1 && keepAliveReqLeft-- == 0))\n            {\n                input_demux.markForClose(resp);\n                input_demux = null;\n            }\n            else\n            {\n                input_demux.restartTimer();\n            }\n\n            if (keepAliveReqMax != -1)\n            {\n                Log.write(Log.CONN, \"Conn:  Number of requests left: \" +\n                        keepAliveReqLeft);\n            }\n\n            /*\n             *  We don't pipeline the first request, as we need some info\n             *  about the server (such as which http version it complies with)\n             */\n            if (!ServProtVersKnown)\n            {\n                early_stall = resp;\n                resp.markAsFirstResponse(req);\n            }\n\n            /*\n             *  Also don't pipeline until we know if the server supports\n             *  keep-alive's or not.\n             *  Note: strictly speaking, HTTP/1.0 keep-alives don't mean we can\n             *  pipeline requests. I seem to remember some (beta?) version\n             *  of Netscape's Enterprise server which barfed if you tried\n             *  push requests down it's throat w/o waiting for the previous\n             *  response first. However, I've not been able to find such a\n             *  server lately, and so I'm taking the risk and assuming we\n             *  can in fact pipeline requests to HTTP/1.0 servers.\n             */\n            if (keepAliveUnknown ||\n            // We don't pipeline POST's ...\n                    !IdempotentSequence.methodIsIdempotent(req.getMethod()) ||\n                    req.dont_pipeline ||\n            // Retries disable pipelining too\n                    neverPipeline)\n            {\n                // Emergency measure: prevent all pipelining\n                late_stall = resp;\n            }\n\n            /*\n             *  If there is an output stream then just tell the other threads to\n             *  wait; the stream will notify() when it's done. If there isn't any\n             *  stream then wake up a waiting thread (if any).\n             */\n            if (req.getStream() != null)\n            {\n                output_finished = false;\n            }\n            else\n            {\n                output_finished = true;\n                notify();\n            }\n\n            // Looks like were finally done\n\n            Log.write(Log.CONN, \"Conn:  Request sent\");\n        }\n\n        return resp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}