{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZDouble(DataOutput,double).mjava","commits":[{"id":"078fa9e94da55eaa1aa1e7393aa84ba7cc986864","date":1418310060,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZDouble(DataOutput,double).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Writes a float in a variable-length format.  Writes between one and \n   * five bytes. Small integral values typically take fewer bytes.\n   * <p>\n   * ZFloat --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; {@link DataOutput#writeByte Uint8}. When it is\n   *       equal to 0xFF then the value is negative and stored in the next\n   *       8 bytes. When it is equal to 0xFE then the value is stored as a\n   *       float in the next 4 bytes. Otherwise if the first bit is set\n   *       then the other bits in the header encode the value plus one and\n   *       no other bytes are read. Otherwise, the value is a positive float\n   *       value whose first byte is the header, and 7 bytes need to be read\n   *       to complete it.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   * <p>\n   */\n  static void writeZDouble(DataOutput out, double d) throws IOException {\n    int intVal = (int) d;\n    final long doubleBits = Double.doubleToLongBits(d);\n    \n    if (d == intVal &&\n        intVal >= -1 && \n        intVal <= 0x7C &&\n        doubleBits != NEGATIVE_ZERO_DOUBLE) {\n      // small integer value [-1..124]: single byte\n      out.writeByte((byte) (0x80 | (intVal + 1)));\n      return;\n    } else if (d == (float) d) {\n      // d has an accurate float representation: 5 bytes\n      out.writeByte((byte) 0xFE);\n      out.writeInt(Float.floatToIntBits((float) d));\n    } else if ((doubleBits >>> 63) == 0) {\n      // other positive doubles: 8 bytes\n      out.writeLong(doubleBits);\n    } else {\n      // other negative doubles: 9 bytes\n      out.writeByte((byte) 0xFF);\n      out.writeLong(doubleBits);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83caedc5d9e910bc771bdecafbe0430361462397"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83caedc5d9e910bc771bdecafbe0430361462397","date":1440445428,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZDouble(DataOutput,double).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter#writeZDouble(DataOutput,double).mjava","sourceNew":"  /** \n   * Writes a float in a variable-length format.  Writes between one and \n   * five bytes. Small integral values typically take fewer bytes.\n   * <p>\n   * ZFloat --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; {@link DataOutput#writeByte Uint8}. When it is\n   *       equal to 0xFF then the value is negative and stored in the next\n   *       8 bytes. When it is equal to 0xFE then the value is stored as a\n   *       float in the next 4 bytes. Otherwise if the first bit is set\n   *       then the other bits in the header encode the value plus one and\n   *       no other bytes are read. Otherwise, the value is a positive float\n   *       value whose first byte is the header, and 7 bytes need to be read\n   *       to complete it.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   */\n  static void writeZDouble(DataOutput out, double d) throws IOException {\n    int intVal = (int) d;\n    final long doubleBits = Double.doubleToLongBits(d);\n    \n    if (d == intVal &&\n        intVal >= -1 && \n        intVal <= 0x7C &&\n        doubleBits != NEGATIVE_ZERO_DOUBLE) {\n      // small integer value [-1..124]: single byte\n      out.writeByte((byte) (0x80 | (intVal + 1)));\n      return;\n    } else if (d == (float) d) {\n      // d has an accurate float representation: 5 bytes\n      out.writeByte((byte) 0xFE);\n      out.writeInt(Float.floatToIntBits((float) d));\n    } else if ((doubleBits >>> 63) == 0) {\n      // other positive doubles: 8 bytes\n      out.writeLong(doubleBits);\n    } else {\n      // other negative doubles: 9 bytes\n      out.writeByte((byte) 0xFF);\n      out.writeLong(doubleBits);\n    }\n  }\n\n","sourceOld":"  /** \n   * Writes a float in a variable-length format.  Writes between one and \n   * five bytes. Small integral values typically take fewer bytes.\n   * <p>\n   * ZFloat --&gt; Header, Bytes*?\n   * <ul>\n   *    <li>Header --&gt; {@link DataOutput#writeByte Uint8}. When it is\n   *       equal to 0xFF then the value is negative and stored in the next\n   *       8 bytes. When it is equal to 0xFE then the value is stored as a\n   *       float in the next 4 bytes. Otherwise if the first bit is set\n   *       then the other bits in the header encode the value plus one and\n   *       no other bytes are read. Otherwise, the value is a positive float\n   *       value whose first byte is the header, and 7 bytes need to be read\n   *       to complete it.\n   *    <li>Bytes --&gt; Potential additional bytes to read depending on the\n   *       header.\n   * </ul>\n   * <p>\n   */\n  static void writeZDouble(DataOutput out, double d) throws IOException {\n    int intVal = (int) d;\n    final long doubleBits = Double.doubleToLongBits(d);\n    \n    if (d == intVal &&\n        intVal >= -1 && \n        intVal <= 0x7C &&\n        doubleBits != NEGATIVE_ZERO_DOUBLE) {\n      // small integer value [-1..124]: single byte\n      out.writeByte((byte) (0x80 | (intVal + 1)));\n      return;\n    } else if (d == (float) d) {\n      // d has an accurate float representation: 5 bytes\n      out.writeByte((byte) 0xFE);\n      out.writeInt(Float.floatToIntBits((float) d));\n    } else if ((doubleBits >>> 63) == 0) {\n      // other positive doubles: 8 bytes\n      out.writeLong(doubleBits);\n    } else {\n      // other negative doubles: 9 bytes\n      out.writeByte((byte) 0xFF);\n      out.writeLong(doubleBits);\n    }\n  }\n\n","bugFix":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"078fa9e94da55eaa1aa1e7393aa84ba7cc986864":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83caedc5d9e910bc771bdecafbe0430361462397"],"83caedc5d9e910bc771bdecafbe0430361462397":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"]},"commit2Childs":{"078fa9e94da55eaa1aa1e7393aa84ba7cc986864":["83caedc5d9e910bc771bdecafbe0430361462397"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["078fa9e94da55eaa1aa1e7393aa84ba7cc986864"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"83caedc5d9e910bc771bdecafbe0430361462397":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}