{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","commits":[{"id":"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a","date":1589907167,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","pathOld":"/dev/null","sourceNew":"    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1, path);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1, path);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","sourceOld":"    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1, path);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1, path);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","bugFix":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getProperties());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCoreName());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getVariables());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider.CachedCollectionRef#getColl().mjava","sourceNew":null,"sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public DocCollection getColl() throws InterruptedException, IOException {\n      DocCollection dc = coll;\n      if (dc != null) {\n        return dc;\n      }\n      lock.lock();\n      try {\n        if (coll != null) {\n          return coll;\n        } else {\n          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();\n          nodeReplicaMap.forEach((n, replicas) -> {\n            synchronized (replicas) {\n              replicas.forEach(ri -> {\n                if (!ri.getCollection().equals(name)) {\n                  return;\n                }\n                Map<String, Object> props;\n                synchronized (ri) {\n                  props = new HashMap<>(ri.getProperties());\n                }\n                props.put(ZkStateReader.NODE_NAME_PROP, n);\n                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCoreName());\n                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());\n                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());\n                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());\n                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())\n                    .put(ri.getName(), r);\n              });\n            }\n          });\n\n          // add empty slices\n          sliceProperties.forEach((c, perSliceProps) -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            perSliceProps.forEach((slice, props) -> {\n              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());\n            });\n          });\n          // add empty collections\n          collProperties.keySet().forEach(c -> {\n            if (!c.equals(name)) {\n              return;\n            }\n            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());\n          });\n\n          Map<String, Map<String, Replica>> shards = collMap.get(name);\n          Map<String, Slice> slices = new HashMap<>();\n          shards.forEach((s, replicas) -> {\n            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());\n            Slice slice = new Slice(s, replicas, sliceProps, name);\n            slices.put(s, slice);\n          });\n          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());\n          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap(\"name\", DocRouter.DEFAULT_NAME));\n          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault(\"name\", DocRouter.DEFAULT_NAME));\n          String path = ZkStateReader.getCollectionPath(name);\n          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1);\n          try {\n            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();\n            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));\n            if (!stateManager.hasData(path)) {\n              try {\n                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);\n              } catch (AlreadyExistsException e) {\n                // try updating\n                stateManager.setData(path, data, zkVersion);\n              }\n            } else {\n              stateManager.setData(path, data, zkVersion);\n            }\n            // verify version\n            VersionedData vd = stateManager.getData(path);\n            assert vd.getVersion() == zkVersion + 1;\n            zkVersion++;\n          } catch (KeeperException | BadVersionException e) {\n            // should never happen?\n            throw new RuntimeException(\"error saving \" + coll, e);\n          }\n        }\n      } finally {\n        lock.unlock();\n      }\n      return coll;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}