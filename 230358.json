{"path":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testIndexingBatchPerRequestWithHttpSolrClient().mjava","commits":[{"id":"0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b","date":1576537086,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testIndexingBatchPerRequestWithHttpSolrClient().mjava","pathOld":"/dev/null","sourceNew":"  public void testIndexingBatchPerRequestWithHttpSolrClient() throws Exception {\n    final CloudSolrClient cloudClient = cluster.getSolrClient();\n    final String collectionName = createAndSetNewDefaultCollection();\n\n    final int numDocsPerBatch = atLeast(5);\n    final int numBatchesPerThread = atLeast(5);\n      \n    final CountDownLatch abort = new CountDownLatch(1);\n    class BatchIndexer implements Runnable {\n      private boolean keepGoing() {\n        return 0 < abort.getCount();\n      }\n      \n      final int name;\n      public BatchIndexer(int name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        try {\n          for (int batchId = 0; batchId < numBatchesPerThread && keepGoing(); batchId++) {\n            final UpdateRequest req = new UpdateRequest();\n            for (int docId = 0; docId < numDocsPerBatch && keepGoing(); docId++) {\n              req.add(sdoc(\"id\", \"indexer\" + name + \"_\" + batchId + \"_\" + docId,\n                           \"test_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n            }\n            assertEquals(0, req.process(cloudClient).getStatus());\n          }\n        } catch (Throwable e) {\n          abort.countDown();\n          throw new RuntimeException(e);\n        }\n      }\n    };\n    final ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"batchIndexing\");\n    final int numThreads = random().nextInt(TEST_NIGHTLY ? 4 : 2) + 1;\n    final List<Future<?>> futures = new ArrayList<>(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      futures.add(executor.submit(new BatchIndexer(i)));\n    }\n    final int totalDocsExpected = numThreads * numBatchesPerThread * numDocsPerBatch;\n    ExecutorUtil.shutdownAndAwaitTermination(executor);\n\n    for (Future result : futures) {\n      assertFalse(result.isCancelled());\n      assertTrue(result.isDone());\n      // all we care about is propogating any possibile execution exception...\n      final Object ignored = result.get();\n    }\n    \n    cloudClient.commit();\n    assertEquals(totalDocsExpected, cloudClient.query(params(\"q\",\"*:*\")).getResults().getNumFound());\n    checkShardConsistency(params(\"q\",\"*:*\", \"rows\", \"\"+totalDocsExpected, \"_trace\",\"batches_done\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b945b8f5bba0303382bc69d60c0c287714f23328","date":1576586294,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testIndexingBatchPerRequestWithHttpSolrClient().mjava","pathOld":"/dev/null","sourceNew":"  public void testIndexingBatchPerRequestWithHttpSolrClient() throws Exception {\n    final CloudSolrClient cloudClient = cluster.getSolrClient();\n    final String collectionName = createAndSetNewDefaultCollection();\n\n    final int numDocsPerBatch = atLeast(5);\n    final int numBatchesPerThread = atLeast(5);\n      \n    final CountDownLatch abort = new CountDownLatch(1);\n    class BatchIndexer implements Runnable {\n      private boolean keepGoing() {\n        return 0 < abort.getCount();\n      }\n      \n      final int name;\n      public BatchIndexer(int name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        try {\n          for (int batchId = 0; batchId < numBatchesPerThread && keepGoing(); batchId++) {\n            final UpdateRequest req = new UpdateRequest();\n            for (int docId = 0; docId < numDocsPerBatch && keepGoing(); docId++) {\n              req.add(sdoc(\"id\", \"indexer\" + name + \"_\" + batchId + \"_\" + docId,\n                           \"test_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n            }\n            assertEquals(0, req.process(cloudClient).getStatus());\n          }\n        } catch (Throwable e) {\n          abort.countDown();\n          throw new RuntimeException(e);\n        }\n      }\n    };\n    final ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"batchIndexing\");\n    final int numThreads = random().nextInt(TEST_NIGHTLY ? 4 : 2) + 1;\n    final List<Future<?>> futures = new ArrayList<>(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      futures.add(executor.submit(new BatchIndexer(i)));\n    }\n    final int totalDocsExpected = numThreads * numBatchesPerThread * numDocsPerBatch;\n    ExecutorUtil.shutdownAndAwaitTermination(executor);\n\n    for (Future result : futures) {\n      assertFalse(result.isCancelled());\n      assertTrue(result.isDone());\n      // all we care about is propogating any possibile execution exception...\n      final Object ignored = result.get();\n    }\n    \n    cloudClient.commit();\n    assertEquals(totalDocsExpected, cloudClient.query(params(\"q\",\"*:*\")).getResults().getNumFound());\n    checkShardConsistency(params(\"q\",\"*:*\", \"rows\", \"\"+totalDocsExpected, \"_trace\",\"batches_done\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testIndexingBatchPerRequestWithHttpSolrClient().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest#testIndexingBatchPerRequestWithHttpSolrClient().mjava","sourceNew":"  public void testIndexingBatchPerRequestWithHttpSolrClient() throws Exception {\n    final CloudSolrClient cloudClient = cluster.getSolrClient();\n    final String collectionName = createAndSetNewDefaultCollection();\n\n    final int numDocsPerBatch = atLeast(5);\n    final int numBatchesPerThread = atLeast(5);\n      \n    final CountDownLatch abort = new CountDownLatch(1);\n    class BatchIndexer implements Runnable {\n      private boolean keepGoing() {\n        return 0 < abort.getCount();\n      }\n      \n      final int name;\n      public BatchIndexer(int name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        try {\n          for (int batchId = 0; batchId < numBatchesPerThread && keepGoing(); batchId++) {\n            final UpdateRequest req = new UpdateRequest();\n            for (int docId = 0; docId < numDocsPerBatch && keepGoing(); docId++) {\n              req.add(sdoc(\"id\", \"indexer\" + name + \"_\" + batchId + \"_\" + docId,\n                           \"test_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n            }\n            assertEquals(0, req.process(cloudClient).getStatus());\n          }\n        } catch (Throwable e) {\n          abort.countDown();\n          throw new RuntimeException(e);\n        }\n      }\n    };\n    final ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"batchIndexing\");\n    final int numThreads = random().nextInt(TEST_NIGHTLY ? 4 : 2) + 1;\n    final List<Future<?>> futures = new ArrayList<>(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      futures.add(executor.submit(new BatchIndexer(i)));\n    }\n    final int totalDocsExpected = numThreads * numBatchesPerThread * numDocsPerBatch;\n    ExecutorUtil.shutdownAndAwaitTermination(executor);\n\n    for (@SuppressWarnings({\"rawtypes\"})Future result : futures) {\n      assertFalse(result.isCancelled());\n      assertTrue(result.isDone());\n      // all we care about is propogating any possibile execution exception...\n      final Object ignored = result.get();\n    }\n    \n    cloudClient.commit();\n    assertEquals(totalDocsExpected, cloudClient.query(params(\"q\",\"*:*\")).getResults().getNumFound());\n    checkShardConsistency(params(\"q\",\"*:*\", \"rows\", \"\"+totalDocsExpected, \"_trace\",\"batches_done\"));\n  }\n\n","sourceOld":"  public void testIndexingBatchPerRequestWithHttpSolrClient() throws Exception {\n    final CloudSolrClient cloudClient = cluster.getSolrClient();\n    final String collectionName = createAndSetNewDefaultCollection();\n\n    final int numDocsPerBatch = atLeast(5);\n    final int numBatchesPerThread = atLeast(5);\n      \n    final CountDownLatch abort = new CountDownLatch(1);\n    class BatchIndexer implements Runnable {\n      private boolean keepGoing() {\n        return 0 < abort.getCount();\n      }\n      \n      final int name;\n      public BatchIndexer(int name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        try {\n          for (int batchId = 0; batchId < numBatchesPerThread && keepGoing(); batchId++) {\n            final UpdateRequest req = new UpdateRequest();\n            for (int docId = 0; docId < numDocsPerBatch && keepGoing(); docId++) {\n              req.add(sdoc(\"id\", \"indexer\" + name + \"_\" + batchId + \"_\" + docId,\n                           \"test_t\", TestUtil.randomRealisticUnicodeString(random(), 200)));\n            }\n            assertEquals(0, req.process(cloudClient).getStatus());\n          }\n        } catch (Throwable e) {\n          abort.countDown();\n          throw new RuntimeException(e);\n        }\n      }\n    };\n    final ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"batchIndexing\");\n    final int numThreads = random().nextInt(TEST_NIGHTLY ? 4 : 2) + 1;\n    final List<Future<?>> futures = new ArrayList<>(numThreads);\n    for (int i = 0; i < numThreads; i++) {\n      futures.add(executor.submit(new BatchIndexer(i)));\n    }\n    final int totalDocsExpected = numThreads * numBatchesPerThread * numDocsPerBatch;\n    ExecutorUtil.shutdownAndAwaitTermination(executor);\n\n    for (Future result : futures) {\n      assertFalse(result.isCancelled());\n      assertTrue(result.isDone());\n      // all we care about is propogating any possibile execution exception...\n      final Object ignored = result.get();\n    }\n    \n    cloudClient.commit();\n    assertEquals(totalDocsExpected, cloudClient.query(params(\"q\",\"*:*\")).getResults().getNumFound());\n    checkShardConsistency(params(\"q\",\"*:*\", \"rows\", \"\"+totalDocsExpected, \"_trace\",\"batches_done\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b945b8f5bba0303382bc69d60c0c287714f23328":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b945b8f5bba0303382bc69d60c0c287714f23328","0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b"],"b945b8f5bba0303382bc69d60c0c287714f23328":[],"0a29b6e8b148762c68adf55b9d2c2aa5ae411a5b":["aa2585c33d5d66a1c837c312221eb55ddb3c4300","b945b8f5bba0303382bc69d60c0c287714f23328"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b945b8f5bba0303382bc69d60c0c287714f23328","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}