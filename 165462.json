{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e05a6b13f8ec24f996ca64281722b9935403280","date":1330096938,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":["97becc6f32abceab12335ac4802f448ed88a318b","9ce667c6d3400b22523701c549c0d35e26da8b46","786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262","date":1343558498,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eae2a56dc810a17cf807d831f720dec931a03de","date":1349262073,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f24f21e70a092329fc6f920115592dc9529d379","date":1349391034,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it (IFD will incRef/protect the\n    // new files we created):\n    checkpoint();\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957a84c0bae71ad6978009bd4c38e597ce0d1741","date":1349438483,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it (IFD will incRef/protect the\n    // new files we created):\n    checkpoint();\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e80fef3b60b4c0a460f7de813603daf3d48b569","date":1350401924,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db4fdbf3d262768eabc027cd8321edca0cd11fa8","date":1350574784,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n      if (dropSegment) {\n        readerPool.drop(mergedDeletes.info);\n      }\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66b61ab77ab36893d701d693f1b6df2a383bb7b5","date":1364405461,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      deleter.deleteNewFiles(merge.info.files());\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes =  merge.info.info.getDocCount() == 0 ? null : commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.info.getDocCount() == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.getPendingDeleteCount() == merge.info.info.getDocCount());\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.info.getDocCount() != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n\n    if (mergedDeletes != null) {\n      if (dropSegment) {\n        mergedDeletes.dropChanges();\n      }\n      readerPool.release(mergedDeletes);\n    }\n\n    if (dropSegment) {\n      assert !segmentInfos.contains(merge.info);\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n    }\n\n    boolean success = false;\n    try {\n      // Must close before checkpoint, otherwise IFD won't be\n      // able to delete the held-open files from the merge\n      // readers:\n      closeMergeReaders(merge, false);\n      success = true;\n    } finally {\n      // Must note the change to segmentInfos so any commits\n      // in-flight don't lose it (IFD will incRef/protect the\n      // new files we created):\n      if (success) {\n        checkpoint();\n      } else {\n        try {\n          checkpoint();\n        } catch (Throwable t) {\n          // Ignore so we keep throwing original exception.\n        }\n      }\n    }\n\n    deleter.deletePendingFiles();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commitMerge: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"9eae2a56dc810a17cf807d831f720dec931a03de":["ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","1e05a6b13f8ec24f996ca64281722b9935403280"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["957a84c0bae71ad6978009bd4c38e597ce0d1741","7e80fef3b60b4c0a460f7de813603daf3d48b569"],"957a84c0bae71ad6978009bd4c38e597ce0d1741":["5f24f21e70a092329fc6f920115592dc9529d379"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["1e05a6b13f8ec24f996ca64281722b9935403280"],"1e05a6b13f8ec24f996ca64281722b9935403280":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"66b61ab77ab36893d701d693f1b6df2a383bb7b5":["7e80fef3b60b4c0a460f7de813603daf3d48b569"],"7e80fef3b60b4c0a460f7de813603daf3d48b569":["957a84c0bae71ad6978009bd4c38e597ce0d1741"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","203d7d3cb7712e10ef33009a63247ae40c302d7a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262"],"ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"5f24f21e70a092329fc6f920115592dc9529d379":["9eae2a56dc810a17cf807d831f720dec931a03de"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["66b61ab77ab36893d701d693f1b6df2a383bb7b5"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"9eae2a56dc810a17cf807d831f720dec931a03de":["5f24f21e70a092329fc6f920115592dc9529d379"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1e05a6b13f8ec24f996ca64281722b9935403280"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":[],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"957a84c0bae71ad6978009bd4c38e597ce0d1741":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","7e80fef3b60b4c0a460f7de813603daf3d48b569"],"1e05a6b13f8ec24f996ca64281722b9935403280":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"66b61ab77ab36893d701d693f1b6df2a383bb7b5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7e80fef3b60b4c0a460f7de813603daf3d48b569":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","66b61ab77ab36893d701d693f1b6df2a383bb7b5"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"ce880d3c7ddcd8a40e3fc6dc3ac48082a0a9d262":["9eae2a56dc810a17cf807d831f720dec931a03de","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"5f24f21e70a092329fc6f920115592dc9529d379":["957a84c0bae71ad6978009bd4c38e597ce0d1741"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","db4fdbf3d262768eabc027cd8321edca0cd11fa8","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}