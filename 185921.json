{"path":"contrib/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","commits":[{"id":"043c298cb215f13ba7b9b81d20760704e8f93d66","date":1107566743,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4d1f544536b6c6ad3f1d34803c651c019795f51","date":1115339471,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/wordnetlc/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"043c298cb215f13ba7b9b81d20760704e8f93d66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4d1f544536b6c6ad3f1d34803c651c019795f51":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b4d1f544536b6c6ad3f1d34803c651c019795f51"]},"commit2Childs":{"043c298cb215f13ba7b9b81d20760704e8f93d66":["b4d1f544536b6c6ad3f1d34803c651c019795f51"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"b4d1f544536b6c6ad3f1d34803c651c019795f51":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}