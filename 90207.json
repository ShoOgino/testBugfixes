{"path":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\"));\n    doc.add(new Field(\"id\", Integer.toString(id), StringField.TYPE_STORED));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new NumericField(\"trieInt\", id));\n    doc.add(new NumericField(\"trieLong\", (long) id));\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\"));\n    doc.add(new Field(\"id\", Integer.toString(id), StringField.TYPE_STORED));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new NumericField(\"trieInt\", id));\n    doc.add(new NumericField(\"trieLong\", (long) id));\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\"));\n    doc.add(new Field(\"id\", Integer.toString(id), StringField.TYPE_STORED));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id));\n    doc.add(new LongField(\"trieLong\", (long) id));\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\"));\n    doc.add(new Field(\"id\", Integer.toString(id), StringField.TYPE_STORED));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new NumericField(\"trieInt\", id));\n    doc.add(new NumericField(\"trieLong\", (long) id));\n    writer.addDocument(doc);\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766"],"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\"));\n    doc.add(new Field(\"id\", Integer.toString(id), StringField.TYPE_STORED));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id));\n    doc.add(new LongField(\"trieLong\", (long) id));\n    writer.addDocument(doc);\n  }\n\n","bugFix":["a78a90fc9701e511308346ea29f4f5e548bb39fe","1509f151d7692d84fae414b2b799ac06ba60fcb4","7e4db59c6b6c10e25322cfb41c4c19d78b4298bd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a3b444707abab6c7f63c331b3f44971c53b0f07","date":1339533739,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new ByteDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new DerefBytesDocValuesField(\"dvBytesDerefFixed\", ref, true));\n    doc.add(new DerefBytesDocValuesField(\"dvBytesDerefVar\", ref, false));\n    doc.add(new SortedBytesDocValuesField(\"dvBytesSortedFixed\", ref, true));\n    doc.add(new SortedBytesDocValuesField(\"dvBytesSortedVar\", ref, false));\n    doc.add(new StraightBytesDocValuesField(\"dvBytesStraightFixed\", ref, true));\n    doc.add(new StraightBytesDocValuesField(\"dvBytesStraightVar\", ref, false));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new IntDocValuesField(\"dvInt\", id));\n    doc.add(new LongDocValuesField(\"dvLong\", id));\n    doc.add(new PackedLongDocValuesField(\"dvPacked\", id));\n    doc.add(new ShortDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new SortedDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new ByteDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new DerefBytesDocValuesField(\"dvBytesDerefFixed\", ref, true));\n    doc.add(new DerefBytesDocValuesField(\"dvBytesDerefVar\", ref, false));\n    doc.add(new SortedBytesDocValuesField(\"dvBytesSortedFixed\", ref, true));\n    doc.add(new SortedBytesDocValuesField(\"dvBytesSortedVar\", ref, false));\n    doc.add(new StraightBytesDocValuesField(\"dvBytesStraightFixed\", ref, true));\n    doc.add(new StraightBytesDocValuesField(\"dvBytesStraightVar\", ref, false));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new IntDocValuesField(\"dvInt\", id));\n    doc.add(new LongDocValuesField(\"dvLong\", id));\n    doc.add(new PackedLongDocValuesField(\"dvPacked\", id));\n    doc.add(new ShortDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10e89cbe24422ef92a37fc037a955728de2e12cf","date":1359053475,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new SortedDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new ByteDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new DerefBytesDocValuesField(\"dvBytesDerefFixed\", ref, true));\n    doc.add(new DerefBytesDocValuesField(\"dvBytesDerefVar\", ref, false));\n    doc.add(new SortedBytesDocValuesField(\"dvBytesSortedFixed\", ref, true));\n    doc.add(new SortedBytesDocValuesField(\"dvBytesSortedVar\", ref, false));\n    doc.add(new StraightBytesDocValuesField(\"dvBytesStraightFixed\", ref, true));\n    doc.add(new StraightBytesDocValuesField(\"dvBytesStraightVar\", ref, false));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new IntDocValuesField(\"dvInt\", id));\n    doc.add(new LongDocValuesField(\"dvLong\", id));\n    doc.add(new PackedLongDocValuesField(\"dvPacked\", id));\n    doc.add(new ShortDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":["5a3b444707abab6c7f63c331b3f44971c53b0f07"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fe3b1894255151160e7a26231483e8ab0e310a7","date":1362971493,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf67308cf3e605faada2e2e5092aff47ae822912","date":1404140785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cc45c615dbb82bf79d5f9550286098367874fbf","date":1409571423,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#addDoc(IndexWriter,int).mjava","sourceNew":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","sourceOld":"  private void addDoc(IndexWriter writer, int id) throws IOException\n  {\n    Document doc = new Document();\n    doc.add(new TextField(\"content\", \"aaa\", Field.Store.NO));\n    doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n    FieldType customType2 = new FieldType(TextField.TYPE_STORED);\n    customType2.setStoreTermVectors(true);\n    customType2.setStoreTermVectorPositions(true);\n    customType2.setStoreTermVectorOffsets(true);\n    doc.add(new Field(\"autf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"utf8\", \"Lu\\uD834\\uDD1Ece\\uD834\\uDD60ne \\u0000 \\u2620 ab\\ud917\\udc17cd\", customType2));\n    doc.add(new Field(\"content2\", \"here is more content with aaa aaa aaa\", customType2));\n    doc.add(new Field(\"fie\\u2C77ld\", \"field with non-ascii name\", customType2));\n    // add numeric fields, to test if flex preserves encoding\n    doc.add(new IntField(\"trieInt\", id, Field.Store.NO));\n    doc.add(new LongField(\"trieLong\", (long) id, Field.Store.NO));\n    // add docvalues fields\n    doc.add(new NumericDocValuesField(\"dvByte\", (byte) id));\n    byte bytes[] = new byte[] {\n      (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id\n    };\n    BytesRef ref = new BytesRef(bytes);\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesDerefVar\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedFixed\", ref));\n    doc.add(new SortedDocValuesField(\"dvBytesSortedVar\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightFixed\", ref));\n    doc.add(new BinaryDocValuesField(\"dvBytesStraightVar\", ref));\n    doc.add(new DoubleDocValuesField(\"dvDouble\", (double)id));\n    doc.add(new FloatDocValuesField(\"dvFloat\", (float)id));\n    doc.add(new NumericDocValuesField(\"dvInt\", id));\n    doc.add(new NumericDocValuesField(\"dvLong\", id));\n    doc.add(new NumericDocValuesField(\"dvPacked\", id));\n    doc.add(new NumericDocValuesField(\"dvShort\", (short)id));\n    doc.add(new SortedSetDocValuesField(\"dvSortedSet\", ref));\n    doc.add(new SortedNumericDocValuesField(\"dvSortedNumeric\", id));\n    // a field with both offsets and term vectors for a cross-check\n    FieldType customType3 = new FieldType(TextField.TYPE_STORED);\n    customType3.setStoreTermVectors(true);\n    customType3.setStoreTermVectorPositions(true);\n    customType3.setStoreTermVectorOffsets(true);\n    customType3.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    doc.add(new Field(\"content5\", \"here is more content with aaa aaa aaa\", customType3));\n    // a field that omits only positions\n    FieldType customType4 = new FieldType(TextField.TYPE_STORED);\n    customType4.setStoreTermVectors(true);\n    customType4.setStoreTermVectorPositions(false);\n    customType4.setStoreTermVectorOffsets(true);\n    customType4.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    doc.add(new Field(\"content6\", \"here is more content with aaa aaa aaa\", customType4));\n    // TODO: \n    //   index different norms types via similarity (we use a random one currently?!)\n    //   remove any analyzer randomness, explicitly add payloads for certain fields.\n    writer.addDocument(doc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf67308cf3e605faada2e2e5092aff47ae822912":["3fe3b1894255151160e7a26231483e8ab0e310a7"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"10e89cbe24422ef92a37fc037a955728de2e12cf":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["cf67308cf3e605faada2e2e5092aff47ae822912","4cc45c615dbb82bf79d5f9550286098367874fbf"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3fe3b1894255151160e7a26231483e8ab0e310a7":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["5a3b444707abab6c7f63c331b3f44971c53b0f07","10e89cbe24422ef92a37fc037a955728de2e12cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cc45c615dbb82bf79d5f9550286098367874fbf":["cf67308cf3e605faada2e2e5092aff47ae822912"],"5a3b444707abab6c7f63c331b3f44971c53b0f07":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["5a3b444707abab6c7f63c331b3f44971c53b0f07"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"]},"commit2Childs":{"cf67308cf3e605faada2e2e5092aff47ae822912":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","4cc45c615dbb82bf79d5f9550286098367874fbf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"10e89cbe24422ef92a37fc037a955728de2e12cf":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["5a3b444707abab6c7f63c331b3f44971c53b0f07"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"3fe3b1894255151160e7a26231483e8ab0e310a7":["cf67308cf3e605faada2e2e5092aff47ae822912"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3fe3b1894255151160e7a26231483e8ab0e310a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4cc45c615dbb82bf79d5f9550286098367874fbf":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"5a3b444707abab6c7f63c331b3f44971c53b0f07":["d4d69c535930b5cce125cff868d40f6373dc27d4","423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["10e89cbe24422ef92a37fc037a955728de2e12cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}