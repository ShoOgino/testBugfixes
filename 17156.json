{"path":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","commits":[{"id":"4d7e42d2692288d7e3f3e38cbfcc31ef1251054d","date":1461702806,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        BytesRef[] bytesRefs = new BytesRef[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          bytesRefs[i] = term.toBytesRef();\n        }\n\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, bytesRefs, maxDocFreq));\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6a801a843f945a61e015ee9334ef03aec6b01ac","date":1461864682,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        Term[] terms = new Term[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          BytesRef ref = term.toBytesRef();\n          terms[i] = new Term(fname, ref);\n        }\n\n        ArrayUtil.timSort(terms);\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, terms, maxDocFreq));\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        BytesRef[] bytesRefs = new BytesRef[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          bytesRefs[i] = term.toBytesRef();\n        }\n\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, bytesRefs, maxDocFreq));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        Term[] terms = new Term[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          BytesRef ref = term.toBytesRef();\n          terms[i] = new Term(fname, ref);\n        }\n\n        ArrayUtil.timSort(terms);\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, terms, maxDocFreq));\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        BytesRef[] bytesRefs = new BytesRef[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          bytesRefs[i] = term.toBytesRef();\n        }\n\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, bytesRefs, maxDocFreq));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e05158fccbb5082f97e4ae2566c5ecfb9df35b7a","date":1501604915,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        SchemaField sf = req.getSchema().getField(fname);\n\n        // if we don't limit by maxDocFreq, then simply use a normal set query\n        if (maxDocFreq == Integer.MAX_VALUE) {\n          return sf.getType().getSetQuery(this, sf, Arrays.asList(splitVals));\n        }\n\n        if (sf.getType().isPointField()) {\n          PointSetQuery setQ = null;\n          if (sf.getType().getNumberType() == NumberType.INTEGER) {\n            int[] vals = new int[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Integer.parseInt(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          } else if (sf.getType().getNumberType() == NumberType.LONG || sf.getType().getNumberType() == NumberType.DATE) {\n            long[] vals = new long[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Long.parseLong(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          } else if (sf.getType().getNumberType() == NumberType.FLOAT) {\n            float[] vals = new float[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Float.parseFloat(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          } else if (sf.getType().getNumberType() == NumberType.DOUBLE) {\n            double[] vals = new double[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Double.parseDouble(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          }\n\n          setQ.setMaxDocFreq(maxDocFreq);\n          return setQ;\n        }\n\n        Term[] terms = new Term[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          BytesRef ref = term.toBytesRef();\n          terms[i] = new Term(fname, ref);\n        }\n\n        ArrayUtil.timSort(terms);\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, terms, maxDocFreq));\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        Term[] terms = new Term[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          BytesRef ref = term.toBytesRef();\n          terms[i] = new Term(fname, ref);\n        }\n\n        ArrayUtil.timSort(terms);\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, terms, maxDocFreq));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin#createParser(String,SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        SchemaField sf = req.getSchema().getField(fname);\n\n        // if we don't limit by maxDocFreq, then simply use a normal set query\n        if (maxDocFreq == Integer.MAX_VALUE) {\n          return sf.getType().getSetQuery(this, sf, Arrays.asList(splitVals));\n        }\n\n        if (sf.getType().isPointField()) {\n          PointSetQuery setQ = null;\n          if (sf.getType().getNumberType() == NumberType.INTEGER) {\n            int[] vals = new int[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Integer.parseInt(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          } else if (sf.getType().getNumberType() == NumberType.LONG || sf.getType().getNumberType() == NumberType.DATE) {\n            long[] vals = new long[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Long.parseLong(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          } else if (sf.getType().getNumberType() == NumberType.FLOAT) {\n            float[] vals = new float[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Float.parseFloat(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          } else if (sf.getType().getNumberType() == NumberType.DOUBLE) {\n            double[] vals = new double[splitVals.length];\n            for (int i=0; i<vals.length; i++) {\n              vals[i] = Double.parseDouble(splitVals[i]);\n            }\n            Arrays.sort(vals);\n            setQ = PointSetQuery.newSetQuery(sf.getName(), vals);\n          }\n\n          setQ.setMaxDocFreq(maxDocFreq);\n          return setQ;\n        }\n\n        Term[] terms = new Term[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          BytesRef ref = term.toBytesRef();\n          terms[i] = new Term(fname, ref);\n        }\n\n        ArrayUtil.timSort(terms);\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, terms, maxDocFreq));\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n    return new QParser(qstr, localParams, params, req) {\n      @Override\n      public Query parse() throws SyntaxError {\n        String fname = localParams.get(QueryParsing.F);\n        FieldType ft = req.getSchema().getFieldTypeNoEx(fname);\n        int maxDocFreq = localParams.getInt(\"maxDocFreq\", Integer.MAX_VALUE);\n        String qstr = localParams.get(QueryParsing.V);//never null\n\n        if (qstr.length() == 0) {\n          return new MatchNoDocsQuery();\n        }\n\n        final String[] splitVals = qstr.split(\",\");\n\n        Term[] terms = new Term[splitVals.length];\n        BytesRefBuilder term = new BytesRefBuilder();\n        for (int i = 0; i < splitVals.length; i++) {\n          String stringVal = splitVals[i].trim();\n          if (ft != null) {\n            ft.readableToIndexed(stringVal, term);\n          } else {\n            term.copyChars(stringVal);\n          }\n          BytesRef ref = term.toBytesRef();\n          terms[i] = new Term(fname, ref);\n        }\n\n        ArrayUtil.timSort(terms);\n        return new ConstantScoreQuery(new GraphTermsQuery(fname, terms, maxDocFreq));\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["f6a801a843f945a61e015ee9334ef03aec6b01ac","e05158fccbb5082f97e4ae2566c5ecfb9df35b7a"],"e05158fccbb5082f97e4ae2566c5ecfb9df35b7a":["f6a801a843f945a61e015ee9334ef03aec6b01ac"],"f6a801a843f945a61e015ee9334ef03aec6b01ac":["4d7e42d2692288d7e3f3e38cbfcc31ef1251054d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d7e42d2692288d7e3f3e38cbfcc31ef1251054d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e05158fccbb5082f97e4ae2566c5ecfb9df35b7a"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4d7e42d2692288d7e3f3e38cbfcc31ef1251054d","f6a801a843f945a61e015ee9334ef03aec6b01ac"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"e05158fccbb5082f97e4ae2566c5ecfb9df35b7a":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6a801a843f945a61e015ee9334ef03aec6b01ac":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","e05158fccbb5082f97e4ae2566c5ecfb9df35b7a","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d7e42d2692288d7e3f3e38cbfcc31ef1251054d"],"4d7e42d2692288d7e3f3e38cbfcc31ef1251054d":["f6a801a843f945a61e015ee9334ef03aec6b01ac","55b50463286869f584cf849d1587a0fcd54d1dfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}