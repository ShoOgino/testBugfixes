{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":1,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n    \n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE,\n        core, CoreAdminParams.DELETE_INSTANCE_DIR, \"true\", CoreAdminParams.DELETE_DATA_DIR, \"true\");\n        \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results, false, null,\n        shardHandler);\n        \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;// check if the core unload removed the\n                                                                              // corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n        \n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n    \n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE,\n        core, CoreAdminParams.DELETE_INSTANCE_DIR, \"true\", CoreAdminParams.DELETE_DATA_DIR, \"true\");\n        \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results, false, null,\n        shardHandler);\n        \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;// check if the core unload removed the\n                                                                              // corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n        \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bbb741690cdafda7f1f7549c26351c912917a69","date":1453203134,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n    params.add(CoreAdminParams.DELETE_INSTANCE_DIR, \"true\");\n    params.add(CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n    \n    String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // assume the core exists and try to unload it\n    Map m = makeMap(\"qt\", adminPath, CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString(), CoreAdminParams.CORE,\n        core, CoreAdminParams.DELETE_INSTANCE_DIR, \"true\", CoreAdminParams.DELETE_DATA_DIR, \"true\");\n        \n    ShardRequest sreq = new ShardRequest();\n    sreq.purpose = 1;\n    sreq.shards = new String[] {baseUrl};\n    sreq.actualShards = sreq.shards;\n    sreq.params = new ModifiableSolrParams(new MapSolrParams(m));\n    try {\n      shardHandler.submit(sreq, baseUrl, sreq.params);\n    } catch (Exception e) {\n      log.warn(\"Exception trying to unload core \" + sreq, e);\n    }\n    \n    collectShardResponses(replica.getState() != Replica.State.ACTIVE ? new NamedList() : results, false, null,\n        shardHandler);\n        \n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;// check if the core unload removed the\n                                                                              // corenode zk enry\n    deleteCoreNode(collectionName, replicaName, replica, core); // try and ensure core info is removed from clusterstate\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n        \n  }\n\n","bugFix":null,"bugIntro":["34127d6b305c3e200d697bfcb58e639d65250c6f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34127d6b305c3e200d697bfcb58e639d65250c6f","date":1457034866,"type":3,"author":"anshum","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n    params.add(CoreAdminParams.DELETE_INSTANCE_DIR, \"true\");\n    params.add(CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","bugFix":["3bbb741690cdafda7f1f7549c26351c912917a69"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n    params.add(CoreAdminParams.DELETE_INSTANCE_DIR, \"true\");\n    params.add(CoreAdminParams.DELETE_DATA_DIR, \"true\");\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1777912fb613f51063554d81f71c1b70d6bcd77","date":1470897768,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws KeeperException, InterruptedException {\n    log.info(\"deleteReplica() : {}\", Utils.toJSONString(message));\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    boolean parallel = message.getBool(\"parallel\", false);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    AtomicReference<Exception> exp = new AtomicReference<>();\n\n    Callable<Boolean> callable = () -> {\n      try {\n        processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n        //check if the core unload removed the corenode zk entry\n        if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n\n        // try and ensure core info is removed from cluster state\n        deleteCoreNode(collectionName, replicaName, replica, core);\n        if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      tpe.submit(callable);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteReplicaCmd#deleteReplica(ClusterState,ZkNodeProps,NamedList,Runnable).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results, Runnable onComplete)\n      throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    boolean parallel = message.getBool(\"parallel\", false);\n\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n\n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    AtomicReference<Map<String, String>> requestMap = new AtomicReference<>(null);\n    if (asyncId != null) {\n      requestMap.set(new HashMap<>(1, 1.0f));\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    boolean isLive = ocmh.zkStateReader.getClusterState().getLiveNodes().contains(replica.getNodeName());\n    if (isLive) {\n      ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap.get());\n    }\n\n    Callable<Boolean> callable = () -> {\n      try {\n        if (isLive) {\n          ocmh.processResponses(results, shardHandler, false, null, asyncId, requestMap.get());\n\n          //check if the core unload removed the corenode zk entry\n          if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return Boolean.TRUE;\n        }\n\n        // try and ensure core info is removed from cluster state\n        ocmh.deleteCoreNode(collectionName, replicaName, replica, core);\n        if (ocmh.waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return Boolean.TRUE;\n        return Boolean.FALSE;\n      } catch (Exception e) {\n        results.add(\"failure\", \"Could not complete delete \" + e.getMessage());\n        throw e;\n      } finally {\n        if (onComplete != null) onComplete.run();\n      }\n    };\n\n    if (!parallel) {\n      try {\n        if (!callable.call())\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n      } catch (InterruptedException | KeeperException e) {\n        throw e;\n      } catch (Exception ex) {\n        throw new SolrException(SolrException.ErrorCode.UNKNOWN, \"Error waiting for corenode gone\", ex);\n      }\n\n    } else {\n      ocmh.tpe.submit(callable);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteReplica(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results)\n      throws KeeperException, InterruptedException {\n    checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP, REPLICA_PROP);\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    String replicaName = message.getStr(REPLICA_PROP);\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = coll.getSlice(shard);\n    if (slice == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Invalid shard name : \" + shard + \" in collection : \" + collectionName);\n    }\n    Replica replica = slice.getReplica(replicaName);\n    if (replica == null) {\n      ArrayList<String> l = new ArrayList<>();\n      for (Replica r : slice.getReplicas())\n        l.add(r.getName());\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid replica : \" + replicaName + \" in shard/collection : \"\n          + shard + \"/\" + collectionName + \" available replicas are \" + StrUtils.join(l, ','));\n    }\n    \n    // If users are being safe and only want to remove a shard if it is down, they can specify onlyIfDown=true\n    // on the command.\n    if (Boolean.parseBoolean(message.getStr(ONLY_IF_DOWN)) && replica.getState() != Replica.State.DOWN) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Attempted to remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName\n              + \" with onlyIfDown='true', but state is '\" + replica.getStr(ZkStateReader.STATE_PROP) + \"'\");\n    }\n\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n    String core = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = null;\n    if (asyncId != null) {\n      requestMap = new HashMap<>(1, 1.0f);\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n    params.add(CoreAdminParams.CORE, core);\n\n    params.set(CoreAdminParams.DELETE_INDEX, message.getBool(CoreAdminParams.DELETE_INDEX, true));\n    params.set(CoreAdminParams.DELETE_INSTANCE_DIR, message.getBool(CoreAdminParams.DELETE_INSTANCE_DIR, true));\n    params.set(CoreAdminParams.DELETE_DATA_DIR, message.getBool(CoreAdminParams.DELETE_DATA_DIR, true));\n\n    sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    processResponses(results, shardHandler, false, null, asyncId, requestMap);\n\n    //check if the core unload removed the corenode zk entry\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 5000)) return;\n\n    // try and ensure core info is removed from cluster state\n    deleteCoreNode(collectionName, replicaName, replica, core);\n    if (waitForCoreNodeGone(collectionName, shard, replicaName, 30000)) return;\n    \n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not  remove replica : \" + collectionName + \"/\" + shard + \"/\" + replicaName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3bbb741690cdafda7f1f7549c26351c912917a69":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","b1777912fb613f51063554d81f71c1b70d6bcd77"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"34127d6b305c3e200d697bfcb58e639d65250c6f":["3bbb741690cdafda7f1f7549c26351c912917a69"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["3bbb741690cdafda7f1f7549c26351c912917a69","34127d6b305c3e200d697bfcb58e639d65250c6f"],"b1777912fb613f51063554d81f71c1b70d6bcd77":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["403d05f7f8d69b65659157eff1bc1d2717f04c66"]},"commit2Childs":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["3bbb741690cdafda7f1f7549c26351c912917a69"],"3bbb741690cdafda7f1f7549c26351c912917a69":["34127d6b305c3e200d697bfcb58e639d65250c6f","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"34127d6b305c3e200d697bfcb58e639d65250c6f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["403d05f7f8d69b65659157eff1bc1d2717f04c66","b1777912fb613f51063554d81f71c1b70d6bcd77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b1777912fb613f51063554d81f71c1b70d6bcd77":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}