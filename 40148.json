{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","commits":[{"id":"746e3645169db50c8f53252b30d6bc9ac21dea7c","date":1357597773,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n      meta.writeVInt(field.number);\n      // nocommit handle var length too!!\n      int length = -1;\n      for(BytesRef v : values) {\n        if (length == -1) {\n          length = v.length;\n        } else if (length != v.length) {\n          throw new UnsupportedOperationException();\n        }\n      }\n      // nocommit don't hardwire fixedLength to 1:\n      meta.writeByte((byte) 1);\n      meta.writeVInt(length);\n      meta.writeLong(data.getFilePointer());\n      for(BytesRef value : values) {\n        data.writeBytes(value.bytes, value.offset, value.length);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf39fad3cd224bbe2a1acfbb2792690c8a62be1b","date":1357611186,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"    @Override\n    public void addBinaryField(FieldInfo field, final Iterable<BytesRef> values) throws IOException {\n      // write the byte[] data\n      meta.writeVInt(field.number);\n      int minLength = Integer.MAX_VALUE;\n      int maxLength = Integer.MIN_VALUE;\n      final long startFP = data.getFilePointer();\n      for(BytesRef v : values) {\n        minLength = Math.min(minLength, v.length);\n        maxLength = Math.max(maxLength, v.length);\n        data.writeBytes(v.bytes, v.offset, v.length);\n      }\n      meta.writeVInt(minLength);\n      meta.writeVInt(maxLength);\n      meta.writeLong(startFP);\n      \n      // if minLength == maxLength, its a fixed-length byte[], we are done (the addresses are implicit)\n      // otherwise, we need to record the length fields...\n      // TODO: make this more efficient. this is just as inefficient as 4.0 codec.... we can do much better.\n      if (minLength != maxLength) {\n        addNumericField(field, new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            final Iterator<BytesRef> inner = values.iterator();\n            return new Iterator<Number>() {\n              long addr = 0;\n\n              @Override\n              public boolean hasNext() {\n                return inner.hasNext();\n              }\n\n              @Override\n              public Number next() {\n                BytesRef b = inner.next();\n                addr += b.length;\n                return addr; // nocommit don't box\n              }\n\n              @Override\n              public void remove() { throw new UnsupportedOperationException(); } \n            };\n          }\n        });\n      }\n    }\n\n","sourceOld":"    @Override\n    public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n      meta.writeVInt(field.number);\n      // nocommit handle var length too!!\n      int length = -1;\n      for(BytesRef v : values) {\n        if (length == -1) {\n          length = v.length;\n        } else if (length != v.length) {\n          throw new UnsupportedOperationException();\n        }\n      }\n      // nocommit don't hardwire fixedLength to 1:\n      meta.writeByte((byte) 1);\n      meta.writeVInt(length);\n      meta.writeLong(data.getFilePointer());\n      for(BytesRef value : values) {\n        data.writeBytes(value.bytes, value.offset, value.length);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be442aa722f1c08c70ec5d9938c9f80a8138e627","date":1357613095,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"    @Override\n    public void addBinaryField(FieldInfo field, final Iterable<BytesRef> values) throws IOException {\n      // write the byte[] data\n      meta.writeVInt(field.number);\n      int minLength = Integer.MAX_VALUE;\n      int maxLength = Integer.MIN_VALUE;\n      final long startFP = data.getFilePointer();\n      int count = 0;\n      for(BytesRef v : values) {\n        minLength = Math.min(minLength, v.length);\n        maxLength = Math.max(maxLength, v.length);\n        data.writeBytes(v.bytes, v.offset, v.length);\n        count++;\n      }\n      meta.writeVInt(minLength);\n      meta.writeVInt(maxLength);\n      meta.writeVInt(count);\n      meta.writeLong(startFP);\n      \n      // if minLength == maxLength, its a fixed-length byte[], we are done (the addresses are implicit)\n      // otherwise, we need to record the length fields...\n      // TODO: make this more efficient. this is just as inefficient as 4.0 codec.... we can do much better.\n      if (minLength != maxLength) {\n        addNumericField(field, new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            final Iterator<BytesRef> inner = values.iterator();\n            return new Iterator<Number>() {\n              long addr = 0;\n\n              @Override\n              public boolean hasNext() {\n                return inner.hasNext();\n              }\n\n              @Override\n              public Number next() {\n                BytesRef b = inner.next();\n                addr += b.length;\n                return addr; // nocommit don't box\n              }\n\n              @Override\n              public void remove() { throw new UnsupportedOperationException(); } \n            };\n          }\n        });\n      }\n    }\n\n","sourceOld":"    @Override\n    public void addBinaryField(FieldInfo field, final Iterable<BytesRef> values) throws IOException {\n      // write the byte[] data\n      meta.writeVInt(field.number);\n      int minLength = Integer.MAX_VALUE;\n      int maxLength = Integer.MIN_VALUE;\n      final long startFP = data.getFilePointer();\n      for(BytesRef v : values) {\n        minLength = Math.min(minLength, v.length);\n        maxLength = Math.max(maxLength, v.length);\n        data.writeBytes(v.bytes, v.offset, v.length);\n      }\n      meta.writeVInt(minLength);\n      meta.writeVInt(maxLength);\n      meta.writeLong(startFP);\n      \n      // if minLength == maxLength, its a fixed-length byte[], we are done (the addresses are implicit)\n      // otherwise, we need to record the length fields...\n      // TODO: make this more efficient. this is just as inefficient as 4.0 codec.... we can do much better.\n      if (minLength != maxLength) {\n        addNumericField(field, new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            final Iterator<BytesRef> inner = values.iterator();\n            return new Iterator<Number>() {\n              long addr = 0;\n\n              @Override\n              public boolean hasNext() {\n                return inner.hasNext();\n              }\n\n              @Override\n              public Number next() {\n                BytesRef b = inner.next();\n                addr += b.length;\n                return addr; // nocommit don't box\n              }\n\n              @Override\n              public void remove() { throw new UnsupportedOperationException(); } \n            };\n          }\n        });\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68acf69be1b41192ae2278afc452bb66f6349cba","date":1357657311,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.Lucene41SimpleDocValuesConsumer#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":null,"sourceOld":"    @Override\n    public void addBinaryField(FieldInfo field, final Iterable<BytesRef> values) throws IOException {\n      // write the byte[] data\n      meta.writeVInt(field.number);\n      int minLength = Integer.MAX_VALUE;\n      int maxLength = Integer.MIN_VALUE;\n      final long startFP = data.getFilePointer();\n      int count = 0;\n      for(BytesRef v : values) {\n        minLength = Math.min(minLength, v.length);\n        maxLength = Math.max(maxLength, v.length);\n        data.writeBytes(v.bytes, v.offset, v.length);\n        count++;\n      }\n      meta.writeVInt(minLength);\n      meta.writeVInt(maxLength);\n      meta.writeVInt(count);\n      meta.writeLong(startFP);\n      \n      // if minLength == maxLength, its a fixed-length byte[], we are done (the addresses are implicit)\n      // otherwise, we need to record the length fields...\n      // TODO: make this more efficient. this is just as inefficient as 4.0 codec.... we can do much better.\n      if (minLength != maxLength) {\n        addNumericField(field, new Iterable<Number>() {\n          @Override\n          public Iterator<Number> iterator() {\n            final Iterator<BytesRef> inner = values.iterator();\n            return new Iterator<Number>() {\n              long addr = 0;\n\n              @Override\n              public boolean hasNext() {\n                return inner.hasNext();\n              }\n\n              @Override\n              public Number next() {\n                BytesRef b = inner.next();\n                addr += b.length;\n                return addr; // nocommit don't box\n              }\n\n              @Override\n              public void remove() { throw new UnsupportedOperationException(); } \n            };\n          }\n        });\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf39fad3cd224bbe2a1acfbb2792690c8a62be1b":["746e3645169db50c8f53252b30d6bc9ac21dea7c"],"68acf69be1b41192ae2278afc452bb66f6349cba":["be442aa722f1c08c70ec5d9938c9f80a8138e627"],"746e3645169db50c8f53252b30d6bc9ac21dea7c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be442aa722f1c08c70ec5d9938c9f80a8138e627":["cf39fad3cd224bbe2a1acfbb2792690c8a62be1b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"cf39fad3cd224bbe2a1acfbb2792690c8a62be1b":["be442aa722f1c08c70ec5d9938c9f80a8138e627"],"68acf69be1b41192ae2278afc452bb66f6349cba":[],"746e3645169db50c8f53252b30d6bc9ac21dea7c":["cf39fad3cd224bbe2a1acfbb2792690c8a62be1b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["746e3645169db50c8f53252b30d6bc9ac21dea7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"be442aa722f1c08c70ec5d9938c9f80a8138e627":["68acf69be1b41192ae2278afc452bb66f6349cba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["68acf69be1b41192ae2278afc452bb66f6349cba","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}