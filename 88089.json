{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","commits":[{"id":"5bab390672c049be9259a87550b243010d8b8423","date":1457865679,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"/dev/null","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 26L * numDocs);\n    long counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intoSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intoSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9b61f1fc042cfd65c32d71e62e0ccd025608485","date":1457866404,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 1024, 256, Long.BYTES, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 26L * numDocs);\n    long counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intoSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intoSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"387b0bb5e7b29d4bd5e49de2c9b618f9ab88c89b","date":1457873811,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 1024, 256, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 1024, 256, Long.BYTES, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b84d416bbd661ae4b2a28d103bdfccb851e00de","date":1458041762,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 1024, 256, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":["387b0bb5e7b29d4bd5e49de2c9b618f9ab88c89b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e52a98a3809d9d747b7694f15f80b7018403ef5","date":1459072349,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    r.verify(numDocs);\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs, false);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long indexFP = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in, in, in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    long indexFP = w.finish(out);\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/Test2BBKDPoints#test2D().mjava","sourceNew":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", new BKDConfig(2, 2, Long.BYTES, BKDConfig.DEFAULT_MAX_POINTS_IN_LEAF_NODE),\n                                BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long indexFP = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in, in, in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void test2D() throws Exception {\n    Directory dir = FSDirectory.open(createTempDir(\"2BBKDPoints2D\"));\n\n    final int numDocs = (Integer.MAX_VALUE / 26) + 100;\n\n    BKDWriter w = new BKDWriter(numDocs, dir, \"_0\", 2, 2, Long.BYTES,\n                                BKDWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP, 26L * numDocs);\n    int counter = 0;\n    byte[] packedBytes = new byte[2*Long.BYTES];\n    for (int docID = 0; docID < numDocs; docID++) {\n      for (int j=0;j<26;j++) {\n        // first a random int:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, 0);\n        // then our counter, which will overflow a bit in the end:\n        NumericUtils.intToSortableBytes(counter, packedBytes, Integer.BYTES);\n        // then two random ints for the 2nd dimension:\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES);\n        NumericUtils.intToSortableBytes(random().nextInt(), packedBytes, Long.BYTES + Integer.BYTES);\n        w.add(packedBytes, docID);\n        counter++;\n      }\n      if (VERBOSE && docID % 100000 == 0) {\n        System.out.println(docID + \" of \" + numDocs + \"...\");\n      }\n    }\n    IndexOutput out = dir.createOutput(\"2d.bkd\", IOContext.DEFAULT);\n    Runnable finalizer = w.finish(out, out, out);\n    long indexFP = out.getFilePointer();\n    finalizer.run();\n    out.close();\n\n    IndexInput in = dir.openInput(\"2d.bkd\", IOContext.DEFAULT);\n    in.seek(indexFP);\n    BKDReader r = new BKDReader(in, in, in);\n    CheckIndex.VerifyPointsVisitor visitor = new CheckIndex.VerifyPointsVisitor(\"2d\", numDocs, r);\n    r.intersect(visitor);\n    assertEquals(r.size(), visitor.getPointCountSeen());\n    assertEquals(r.getDocCount(), visitor.getDocCountSeen());\n    in.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"f6652c943595e92c187ee904c382863013eae28f":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"387b0bb5e7b29d4bd5e49de2c9b618f9ab88c89b":["a9b61f1fc042cfd65c32d71e62e0ccd025608485"],"a9b61f1fc042cfd65c32d71e62e0ccd025608485":["5bab390672c049be9259a87550b243010d8b8423"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"2b84d416bbd661ae4b2a28d103bdfccb851e00de":["387b0bb5e7b29d4bd5e49de2c9b618f9ab88c89b"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"1e52a98a3809d9d747b7694f15f80b7018403ef5":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"5bab390672c049be9259a87550b243010d8b8423":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9856095f7afb5a607bf5e65077615ed91273508c":["1e52a98a3809d9d747b7694f15f80b7018403ef5","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"387b0bb5e7b29d4bd5e49de2c9b618f9ab88c89b":["2b84d416bbd661ae4b2a28d103bdfccb851e00de"],"a9b61f1fc042cfd65c32d71e62e0ccd025608485":["387b0bb5e7b29d4bd5e49de2c9b618f9ab88c89b"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"2b84d416bbd661ae4b2a28d103bdfccb851e00de":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["f6652c943595e92c187ee904c382863013eae28f","9856095f7afb5a607bf5e65077615ed91273508c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5bab390672c049be9259a87550b243010d8b8423"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"1e52a98a3809d9d747b7694f15f80b7018403ef5":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["1e52a98a3809d9d747b7694f15f80b7018403ef5"],"5bab390672c049be9259a87550b243010d8b8423":["a9b61f1fc042cfd65c32d71e62e0ccd025608485"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}