{"path":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions())\n        hasDeletions = true;\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions())\n        hasDeletions = true;\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions())\n        hasDeletions = true;\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f237ee05f4e8e1fae6614bce022e0dc66c5ed39e","date":1277411648,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n\n    final List<Fields> subFields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> fieldSlices = new ArrayList<ReaderUtil.Slice>();\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i], subReaders[i].maxDoc(), i);\n      subReaderToSlice.put(subReaders[i], slice);\n\n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n        fieldSlices.add(slice);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory);\n    }\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory, codecs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b8414cdacb05e1277df96a30710f570f4251d9a","date":1323040348,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n\n    if (!readOnly) {\n      maxIndexVersion = SegmentInfos.readCurrentVersion(directory);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4","date":1323543613,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/BaseMultiReader#BaseMultiReader(R[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  protected BaseMultiReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n      numDocs += subReaders[i].numDocs();    // compute numDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n    topLevelContext = ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":["fe43a17fb193c95257604ee5486e9f6e2a392c28","fe43a17fb193c95257604ee5486e9f6e2a392c28","98a04f56464afdffd4c430d6c47a0c868a38354e","98a04f56464afdffd4c430d6c47a0c868a38354e","a2a81b3988dfbdfb187c425043b89868e359b238","a2a81b3988dfbdfb187c425043b89868e359b238"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/BaseMultiReader#BaseMultiReader(R[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#initialize(SegmentReader[]).mjava","sourceNew":"  protected BaseMultiReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n      numDocs += subReaders[i].numDocs();    // compute numDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n    topLevelContext = ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private void initialize(SegmentReader[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    final AtomicReaderContext[] subReaderCtx = new AtomicReaderContext[subReaders.length];\n    topLevelReaderContext = new CompositeReaderContext(this, subReaderCtx, subReaderCtx);\n    final List<Fields> subFields = new ArrayList<Fields>();\n    \n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      subReaderCtx[i] = new AtomicReaderContext(topLevelReaderContext, subReaders[i], i, maxDoc, i, maxDoc);\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n      \n      final Fields f = subReaders[i].fields();\n      if (f != null) {\n        subFields.add(f);\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["7b91922b55d15444d554721b352861d028eb8278","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","f237ee05f4e8e1fae6614bce022e0dc66c5ed39e"],"7b91922b55d15444d554721b352861d028eb8278":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"4b8414cdacb05e1277df96a30710f570f4251d9a":["7b91922b55d15444d554721b352861d028eb8278"],"6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f237ee05f4e8e1fae6614bce022e0dc66c5ed39e","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["f237ee05f4e8e1fae6614bce022e0dc66c5ed39e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["7b91922b55d15444d554721b352861d028eb8278","4b8414cdacb05e1277df96a30710f570f4251d9a"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["5f4e87790277826a2aea119328600dfb07761f32","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4"],"f237ee05f4e8e1fae6614bce022e0dc66c5ed39e":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5f4e87790277826a2aea119328600dfb07761f32","f237ee05f4e8e1fae6614bce022e0dc66c5ed39e"],"5f4e87790277826a2aea119328600dfb07761f32":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"7b91922b55d15444d554721b352861d028eb8278":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","4b8414cdacb05e1277df96a30710f570f4251d9a","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"4b8414cdacb05e1277df96a30710f570f4251d9a":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["7b91922b55d15444d554721b352861d028eb8278","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"f237ee05f4e8e1fae6614bce022e0dc66c5ed39e":["5f4e87790277826a2aea119328600dfb07761f32","29ef99d61cda9641b6250bf9567329a6e65f901d","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}