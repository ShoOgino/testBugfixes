{"path":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,Supplier[T]).mjava","commits":[{"id":"6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f","date":1532682688,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#PriorityQueue(int,Supplier[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/PriorityQueue#getSentinelObject().mjava","sourceNew":"  /**\n   * Create a priority queue that is pre-filled with sentinel objects, so that\n   * the code which uses that queue can always assume it's full and only change\n   * the top without attempting to insert any new object.<br>\n   *\n   * Those sentinel values should always compare worse than any non-sentinel\n   * value (i.e., {@link #lessThan} should always favor the\n   * non-sentinel values).<br>\n   *\n   * By default, the supplier returns null, which means the queue will not be\n   * filled with sentinel values. Otherwise, the value returned will be used to\n   * pre-populate the queue.<br>\n   *\n   * If this method is extended to return a non-null value, then the following\n   * usage pattern is recommended:\n   *\n   * <pre class=\"prettyprint\">\n   * PriorityQueue&lt;MyObject&gt; pq = new MyQueue&lt;MyObject&gt;(numHits);\n   * // save the 'top' element, which is guaranteed to not be null.\n   * MyObject pqTop = pq.top();\n   * &lt;...&gt;\n   * // now in order to add a new element, which is 'better' than top (after\n   * // you've verified it is better), it is as simple as:\n   * pqTop.change().\n   * pqTop = pq.updateTop();\n   * </pre>\n   *\n   * <b>NOTE:</b> the given supplier will be called {@code maxSize} times,\n   * relying on a new object to be returned and will not check if it's null again.\n   * Therefore you should ensure any call to this method creates a new instance and\n   * behaves consistently, e.g., it cannot return null if it previously returned\n   * non-null and all returned instances must {@link #lessThan compare equal}.\n   */\n  public PriorityQueue(int maxSize, Supplier<T> sentinelObjectSupplier) {\n    final int heapSize;\n    if (0 == maxSize) {\n      // We allocate 1 extra to avoid if statement in top()\n      heapSize = 2;\n    } else {\n\n      if ((maxSize < 0) || (maxSize >= ArrayUtil.MAX_ARRAY_LENGTH)) {\n        // Throw exception to prevent confusing OOME:\n        throw new IllegalArgumentException(\"maxSize must be >= 0 and < \" + (ArrayUtil.MAX_ARRAY_LENGTH) + \"; got: \" + maxSize);\n      }\n\n      // NOTE: we add +1 because all access to heap is\n      // 1-based not 0-based.  heap[0] is unused.\n      heapSize = maxSize + 1;\n    }\n    // T is unbounded type, so this unchecked cast works always:\n    @SuppressWarnings(\"unchecked\") final T[] h = (T[]) new Object[heapSize];\n    this.heap = h;\n    this.maxSize = maxSize;\n\n    // If sentinel objects are supported, populate the queue with them\n    T sentinel = sentinelObjectSupplier.get();\n    if (sentinel != null) {\n      heap[1] = sentinel;\n      for (int i = 2; i < heap.length; i++) {\n        heap[i] = sentinelObjectSupplier.get();\n      }\n      size = maxSize;\n    }\n  }\n\n","sourceOld":"  /**\n   * This method can be overridden by extending classes to return a sentinel\n   * object which will be used by the {@link PriorityQueue#PriorityQueue(int,boolean)}\n   * constructor to fill the queue, so that the code which uses that queue can always\n   * assume it's full and only change the top without attempting to insert any new\n   * object.<br>\n   *\n   * Those sentinel values should always compare worse than any non-sentinel\n   * value (i.e., {@link #lessThan} should always favor the\n   * non-sentinel values).<br>\n   *\n   * By default, this method returns null, which means the queue will not be\n   * filled with sentinel values. Otherwise, the value returned will be used to\n   * pre-populate the queue. Adds sentinel values to the queue.<br>\n   *\n   * If this method is extended to return a non-null value, then the following\n   * usage pattern is recommended:\n   *\n   * <pre class=\"prettyprint\">\n   * // extends getSentinelObject() to return a non-null value.\n   * PriorityQueue&lt;MyObject&gt; pq = new MyQueue&lt;MyObject&gt;(numHits);\n   * // save the 'top' element, which is guaranteed to not be null.\n   * MyObject pqTop = pq.top();\n   * &lt;...&gt;\n   * // now in order to add a new element, which is 'better' than top (after\n   * // you've verified it is better), it is as simple as:\n   * pqTop.change().\n   * pqTop = pq.updateTop();\n   * </pre>\n   *\n   * <b>NOTE:</b> if this method returns a non-null value, it will be called by\n   * the {@link PriorityQueue#PriorityQueue(int,boolean)} constructor\n   * {@link #size()} times, relying on a new object to be returned and will not\n   * check if it's null again. Therefore you should ensure any call to this\n   * method creates a new instance and behaves consistently, e.g., it cannot\n   * return null if it previously returned non-null.\n   *\n   * @return the sentinel object to use to pre-populate the queue, or null if\n   *         sentinel objects are not supported.\n   */\n  protected T getSentinelObject() {\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f"]},"commit2Childs":{"6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6a01c2b1a66c8ed2fb15d4cbdc6d024d91a2047f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}