{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryModifyDocument(IndexReader,int,DocModifier).mjava","commits":[{"id":"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd","date":1525696559,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryModifyDocument(IndexReader,int,DocModifier).mjava","pathOld":"/dev/null","sourceNew":"  private synchronized long tryModifyDocument(IndexReader readerIn, int docID, DocModifier toApply) throws IOException {\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n\n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          toApply.run(docID, rld);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n    return -1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4987206dabc9f3576bb1df72e987094a7dad6e4f","date":1527510516,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryModifyDocument(IndexReader,int,DocModifier).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryModifyDocument(IndexReader,int,DocModifier).mjava","sourceNew":"  private synchronized long tryModifyDocument(IndexReader readerIn, int docID, DocModifier toApply) throws IOException {\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n\n    final SegmentCommitInfo info = ((SegmentReader) reader).getOriginalSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          toApply.run(docID, rld);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n    return -1;\n  }\n\n","sourceOld":"  private synchronized long tryModifyDocument(IndexReader readerIn, int docID, DocModifier toApply) throws IOException {\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n\n    final SegmentCommitInfo info = ((SegmentReader) reader).getSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          toApply.run(docID, rld);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n    return -1;\n  }\n\n","bugFix":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07024a7318c25225dc4d070cf6d047315b73aaf","date":1586885963,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryModifyDocument(IndexReader,int,DocModifier).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#tryModifyDocument(IndexReader,int,DocModifier).mjava","sourceNew":"  private synchronized long tryModifyDocument(IndexReader readerIn, int docID, DocModifier toApply) throws IOException {\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n\n    final SegmentCommitInfo info = ((SegmentReader) reader).getOriginalSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          toApply.run(docID, rld);\n          return docWriter.getNextSequenceNumber();\n        }\n      }\n    }\n    return -1;\n  }\n\n","sourceOld":"  private synchronized long tryModifyDocument(IndexReader readerIn, int docID, DocModifier toApply) throws IOException {\n    final LeafReader reader;\n    if (readerIn instanceof LeafReader) {\n      // Reader is already atomic: use the incoming docID:\n      reader = (LeafReader) readerIn;\n    } else {\n      // Composite reader: lookup sub-reader and re-base docID:\n      List<LeafReaderContext> leaves = readerIn.leaves();\n      int subIndex = ReaderUtil.subIndex(docID, leaves);\n      reader = leaves.get(subIndex).reader();\n      docID -= leaves.get(subIndex).docBase;\n      assert docID >= 0;\n      assert docID < reader.maxDoc();\n    }\n\n    if (!(reader instanceof SegmentReader)) {\n      throw new IllegalArgumentException(\"the reader must be a SegmentReader or composite reader containing only SegmentReaders\");\n    }\n\n    final SegmentCommitInfo info = ((SegmentReader) reader).getOriginalSegmentInfo();\n\n    // TODO: this is a slow linear search, but, number of\n    // segments should be contained unless something is\n    // seriously wrong w/ the index, so it should be a minor\n    // cost:\n\n    if (segmentInfos.indexOf(info) != -1) {\n      ReadersAndUpdates rld = getPooledInstance(info, false);\n      if (rld != null) {\n        synchronized(bufferedUpdatesStream) {\n          toApply.run(docID, rld);\n          return docWriter.deleteQueue.getNextSequenceNumber();\n        }\n      }\n    }\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b07024a7318c25225dc4d070cf6d047315b73aaf":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b07024a7318c25225dc4d070cf6d047315b73aaf"]},"commit2Childs":{"b07024a7318c25225dc4d070cf6d047315b73aaf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}