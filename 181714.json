{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","commits":[{"id":"1072b8e47b50f1c4fb039e1f54a736f381d6f809","date":1438956441,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      Stat stat = new Stat();\n      byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7477015ee104ad8144fba06b9b0a8ea93aea50f8","date":1450790907,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      Stat stat = new Stat();\n      byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3726445f8e9a7d398466439f0f84b5bb329fdcc","date":1460555680,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b4df85b7268ca40452d6c01343d8eb00ed1f70a","date":1463171656,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection newState = ref.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(loadedData.getCollectionStates().get(coll).get(), newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27b43f9a8cc600a073ced9342cb6882853856049","date":1463221077,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          DocCollection newState = loadedData.getCollectionStates().get(coll).get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection newState = ref.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(loadedData.getCollectionStates().get(coll).get(), newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2eb19eaa7d0f6d8962ad08f50892f7fdd52db0cf","date":1463249301,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          DocCollection newState = loadedData.getCollectionStates().get(coll).get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ebce138cd0e2e76c0ab6e22f4e612ace9da0dc","date":1464963170,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ed55f2bfbc6da6c47312889f4946f1ace920e7","date":1465034744,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f","date":1467384467,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Map<String, DocCollection> updatedCollections = new HashMap<>();\n        for (String coll : this.collectionWatches.keySet()) {\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (newState == null) {\n            // check that we haven't just migrated\n            newState = watchedCollectionStates.get(coll);\n          }\n          if (!Objects.equals(oldState, newState)) {\n            updatedCollections.put(coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n        constructState(updatedCollections);\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n        constructState(Collections.emptyMap());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> liveNodes = this.liveNodes; // volatile read\n        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n          String coll = watchEntry.getKey();\n          CollectionWatch collWatch = watchEntry.getValue();\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          if (ref == null)\n            continue;\n          // legacy collections are always in-memory\n          DocCollection oldState = ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (!collWatch.stateWatchers.isEmpty()\n              && !Objects.equals(oldState, newState)) {\n            notifyStateWatchers(liveNodes, coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f54f0eff6955cf57610f6b93dbbba3a2bf540619","date":1467968491,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> updatedCollections = new HashSet<>();\n        for (String coll : this.collectionWatches.keySet()) {\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (newState == null) {\n            // check that we haven't just migrated\n            newState = watchedCollectionStates.get(coll);\n          }\n          if (!Objects.equals(oldState, newState)) {\n            updatedCollections.add(coll);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n        constructState(updatedCollections);\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n        constructState(Collections.emptySet());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Map<String, DocCollection> updatedCollections = new HashMap<>();\n        for (String coll : this.collectionWatches.keySet()) {\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (newState == null) {\n            // check that we haven't just migrated\n            newState = watchedCollectionStates.get(coll);\n          }\n          if (!Objects.equals(oldState, newState)) {\n            updatedCollections.put(coll, newState);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n        constructState(updatedCollections);\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n        constructState(Collections.emptyMap());\n      }\n    }\n  }\n\n","bugFix":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> updatedCollections = new HashSet<>();\n        for (String coll : this.collectionWatches.keySet()) {\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (newState == null) {\n            // check that we haven't just migrated\n            newState = watchedCollectionStates.get(coll);\n          }\n          if (!Objects.equals(oldState, newState)) {\n            updatedCollections.add(coll);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n        constructState(updatedCollections);\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n        constructState(Collections.emptySet());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher)\n      throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":4,"author":"murblanc","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#refreshLegacyClusterState(Watcher).mjava","sourceNew":null,"sourceOld":"  /**\n   * Refresh legacy (shared) clusterstate.json\n   */\n  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {\n    try {\n      final Stat stat = new Stat();\n      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n      synchronized (getUpdateLock()) {\n        if (this.legacyClusterStateVersion >= stat.getVersion()) {\n          // Nothing to do, someone else updated same or newer.\n          return;\n        }\n        Set<String> updatedCollections = new HashSet<>();\n        for (String coll : this.collectionWatches.keySet()) {\n          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n          // legacy collections are always in-memory\n          DocCollection oldState = ref == null ? null : ref.get();\n          ClusterState.CollectionRef newRef = loadedData.getCollectionStates().get(coll);\n          DocCollection newState = newRef == null ? null : newRef.get();\n          if (newState == null) {\n            // check that we haven't just migrated\n            newState = watchedCollectionStates.get(coll);\n          }\n          if (!Objects.equals(oldState, newState)) {\n            updatedCollections.add(coll);\n          }\n        }\n        this.legacyCollectionStates = loadedData.getCollectionStates();\n        this.legacyClusterStateVersion = stat.getVersion();\n        constructState(updatedCollections);\n      }\n    } catch (KeeperException.NoNodeException e) {\n      // Ignore missing legacy clusterstate.json.\n      synchronized (getUpdateLock()) {\n        this.legacyCollectionStates = emptyMap();\n        this.legacyClusterStateVersion = 0;\n        constructState(Collections.emptySet());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2eb19eaa7d0f6d8962ad08f50892f7fdd52db0cf":["27b43f9a8cc600a073ced9342cb6882853856049"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"14ed55f2bfbc6da6c47312889f4946f1ace920e7":["14ebce138cd0e2e76c0ab6e22f4e612ace9da0dc"],"f54f0eff6955cf57610f6b93dbbba3a2bf540619":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"14ebce138cd0e2e76c0ab6e22f4e612ace9da0dc":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"0ad30c6a479e764150a3316e57263319775f1df2":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","2eb19eaa7d0f6d8962ad08f50892f7fdd52db0cf"],"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f":["14ed55f2bfbc6da6c47312889f4946f1ace920e7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"1072b8e47b50f1c4fb039e1f54a736f381d6f809":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","0ad30c6a479e764150a3316e57263319775f1df2"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["7477015ee104ad8144fba06b9b0a8ea93aea50f8","d3726445f8e9a7d398466439f0f84b5bb329fdcc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"27b43f9a8cc600a073ced9342cb6882853856049":["5b4df85b7268ca40452d6c01343d8eb00ed1f70a"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"5b4df85b7268ca40452d6c01343d8eb00ed1f70a":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"2eb19eaa7d0f6d8962ad08f50892f7fdd52db0cf":["0ad30c6a479e764150a3316e57263319775f1df2"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"14ed55f2bfbc6da6c47312889f4946f1ace920e7":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"f54f0eff6955cf57610f6b93dbbba3a2bf540619":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"d3726445f8e9a7d398466439f0f84b5bb329fdcc":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"14ebce138cd0e2e76c0ab6e22f4e612ace9da0dc":["14ed55f2bfbc6da6c47312889f4946f1ace920e7"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["14ebce138cd0e2e76c0ab6e22f4e612ace9da0dc"],"1072b8e47b50f1c4fb039e1f54a736f381d6f809":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","5b4df85b7268ca40452d6c01343d8eb00ed1f70a"],"27b43f9a8cc600a073ced9342cb6882853856049":["2eb19eaa7d0f6d8962ad08f50892f7fdd52db0cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["d3726445f8e9a7d398466439f0f84b5bb329fdcc","9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"5b4df85b7268ca40452d6c01343d8eb00ed1f70a":["27b43f9a8cc600a073ced9342cb6882853856049"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}