{"path":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","commits":[{"id":"b62da6a75575f59a016a076b4753dc6e20c74b44","date":1219528967,"type":1,"author":"Karl-Johan Wettin","isMerge":false,"pathNew":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"contrib/snowball/src/java/net/sf/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bc7429500777cb3888bd40a90e5da1a57aa1681","date":1263421761,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current.charAt(c + common) - w.s.charAt(i2);\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5aa159e1ac4009d23cea92797d3804da4f5e7ad","date":1264041909,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38c26570a4fd6cf0856801c977a2bc9c28a5424c","date":1264074890,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"/dev/null","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d40ff39db4a2b90a440b97f2a7d7eda344f004ef","date":1264074978,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":null,"sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject,\n\t\t\t\t\t\t    new Object[0]);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b62da6a75575f59a016a076b4753dc6e20c74b44":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a5aa159e1ac4009d23cea92797d3804da4f5e7ad":["8bc7429500777cb3888bd40a90e5da1a57aa1681"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"38c26570a4fd6cf0856801c977a2bc9c28a5424c":["a5aa159e1ac4009d23cea92797d3804da4f5e7ad"],"d40ff39db4a2b90a440b97f2a7d7eda344f004ef":["38c26570a4fd6cf0856801c977a2bc9c28a5424c"],"8bc7429500777cb3888bd40a90e5da1a57aa1681":["b62da6a75575f59a016a076b4753dc6e20c74b44"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d40ff39db4a2b90a440b97f2a7d7eda344f004ef"]},"commit2Childs":{"b62da6a75575f59a016a076b4753dc6e20c74b44":["8bc7429500777cb3888bd40a90e5da1a57aa1681"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b62da6a75575f59a016a076b4753dc6e20c74b44"],"a5aa159e1ac4009d23cea92797d3804da4f5e7ad":["38c26570a4fd6cf0856801c977a2bc9c28a5424c"],"38c26570a4fd6cf0856801c977a2bc9c28a5424c":["d40ff39db4a2b90a440b97f2a7d7eda344f004ef"],"d40ff39db4a2b90a440b97f2a7d7eda344f004ef":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8bc7429500777cb3888bd40a90e5da1a57aa1681":["a5aa159e1ac4009d23cea92797d3804da4f5e7ad"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}