{"path":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","commits":[{"id":"1a51ec81f1fd009bf893bd88ec1c7b964fae6fab","date":1354403647,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"/dev/null","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"175e4d353e3036fad2ad89ae6815c4418b4c3c8e","date":1378375735,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(ArrayUtil.copyOfSubArray(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(ArrayUtil.copyOfSubArray(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(ArrayUtil.copyOfSubArray(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(Arrays.copyOfRange(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"617d6d4150e0fb2acef8980ce51e3b8e628fb200","date":1580326292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode#testPartialDecompress().mjava","sourceNew":"  public void testPartialDecompress() throws IOException {\n    Random random = random();\n    final int iterations = atLeast(random, 3);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray(random);\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random.nextInt(decompressed.length);\n        length = random.nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(ArrayUtil.copyOfSubArray(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","sourceOld":"  public void testPartialDecompress() throws IOException {\n    final int iterations = atLeast(10);\n    for (int i = 0; i < iterations; ++i) {\n      final byte[] decompressed = randomArray();\n      final byte[] compressed = compress(decompressed, 0, decompressed.length);\n      final int offset, length;\n      if (decompressed.length == 0) {\n        offset = length = 0;\n      } else {\n        offset = random().nextInt(decompressed.length);\n        length = random().nextInt(decompressed.length - offset);\n      }\n      final byte[] restored = decompress(compressed, decompressed.length, offset, length);\n      assertArrayEquals(ArrayUtil.copyOfSubArray(decompressed, offset, offset + length), restored);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"175e4d353e3036fad2ad89ae6815c4418b4c3c8e":["1a51ec81f1fd009bf893bd88ec1c7b964fae6fab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["175e4d353e3036fad2ad89ae6815c4418b4c3c8e","9798d0818e7a880546802b509792d3f3d57babd2"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1a51ec81f1fd009bf893bd88ec1c7b964fae6fab"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["9798d0818e7a880546802b509792d3f3d57babd2"],"9798d0818e7a880546802b509792d3f3d57babd2":["175e4d353e3036fad2ad89ae6815c4418b4c3c8e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"1a51ec81f1fd009bf893bd88ec1c7b964fae6fab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["175e4d353e3036fad2ad89ae6815c4418b4c3c8e","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"175e4d353e3036fad2ad89ae6815c4418b4c3c8e":["b70042a8a492f7054d480ccdd2be9796510d4327","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","1a51ec81f1fd009bf893bd88ec1c7b964fae6fab"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9798d0818e7a880546802b509792d3f3d57babd2":["b70042a8a492f7054d480ccdd2be9796510d4327","617d6d4150e0fb2acef8980ce51e3b8e628fb200","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"1a51ec81f1fd009bf893bd88ec1c7b964fae6fab":["175e4d353e3036fad2ad89ae6815c4418b4c3c8e","407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}