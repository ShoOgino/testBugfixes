{"path":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"245c71087515ed70d4fb9d9484f9dcbd79eebdfc","date":1331372561,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    assertU(adoc(\"id\", \"42\", \"trait_ss\", \"Tool\", \"trait_ss\", \"Obnoxious\",\n            \"name\", \"Zapp Brannigan\"));\n    assertU(adoc(\"id\", \"43\" ,\n            \"title\", \"Democratic Order op Planets\"));\n    assertU(adoc(\"id\", \"44\", \"trait_ss\", \"Tool\",\n            \"name\", \"The Zapper\"));\n    assertU(adoc(\"id\", \"45\", \"trait_ss\", \"Chauvinist\",\n            \"title\", \"25 star General\"));\n    assertU(adoc(\"id\", \"46\", \n                 \"trait_ss\", \"Obnoxious\",\n                 \"subject\", \"Defeated the pacifists op the Gandhi nebula\",\n                 \"t_special\", \"literal:colon value\",\n                 \"movies_t\", \"first is Mission: Impossible, second is Terminator 2: Judgement Day.  Terminator:3 ok...\",\n                 \"foo_i\", \"8\"\n    ));\n    assertU(adoc(\"id\", \"47\", \"trait_ss\", \"Pig\",\n            \"text\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n    assertU(adoc(\"id\", \"48\", \"text_sw\", \"this has gigabyte potential\", \"foo_i\",\"100\"));\n    assertU(adoc(\"id\", \"49\", \"text_sw\", \"start the big apple end\", \"foo_i\",\"-100\"));\n    assertU(adoc(\"id\", \"50\", \"text_sw\", \"start new big city end\"));\n\n    assertU(commit());\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b53e1fdeb877dfb9c1aba24b343170ae7ffe7108","date":1332297168,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 50]\";\n    String allr = \"*[count(//doc)=9]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":["20349324eb18d1565d301e59be543989f38743d3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"576a4c26b3d237aa2626e691ea3b4fa016037fe3","date":1332565608,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n\n  assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":["81c86ba78280d33631b3536414395ad80a19a8af","20349324eb18d1565d301e59be543989f38743d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"220acde8206f5221383e3777429a4fb84bed289f","date":1339892825,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b360a3d5b9d443b4e880d2c92724cffd7def8db","date":1490740768,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36d81030ef9ff5ae6820e560c0833127181c7a2c","date":1490873946,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text_sw\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a4260b228cfff6ad78ac88d519f0f7746529c3c","date":1493136145,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            nor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8e2c1ef13fc86db819bf881ef0d9e0765eadfa0","date":1497958776,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a91f19e3f7576973404e13b7ecfb8ae94f313921","date":1511358452,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // _query_ should be excluded by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\",\n                \"debugQuery\", \"true\"),\n            nor,\n        \"//str[@name='parsedquery_toString'][.='+(((text:queri) (text:\\\"geofilt d 20 sfield store pt 12 34 56 78\\\"))~2)']\");\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        nor);\n\n    // should work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"uf\", \"id\",\n        \"uf\", \"_query_\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by omission\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4aee4980038a10791618ea04e79233ce5cbf6607","date":1511366888,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // _query_ should be excluded by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\",\n                \"debugQuery\", \"true\"),\n            nor,\n        \"//str[@name='parsedquery_toString'][.='+(((text:queri) (text:\\\"geofilt d 20 sfield store pt 12 34 56 78\\\"))~2)']\");\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        nor);\n\n    // should work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"uf\", \"id\",\n        \"uf\", \"_query_\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by omission\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // special fields (and real field id) should be included by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // should also work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by ommision\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf9d6fd2b46a1c50382c5cef6be68fd0525946ff","date":1580036619,"type":3,"author":"andywebb1975","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testFocusQueryParser().mjava","sourceNew":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n\n    assertQ(\"ideographic space should be considered whitespace\",\n        req(\"q\",\"\\u3000\",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // _query_ should be excluded by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\",\n                \"debugQuery\", \"true\"),\n            nor,\n        \"//str[@name='parsedquery_toString'][.='+(((text:queri) (text:\\\"geofilt d 20 sfield store pt 12 34 56 78\\\"))~2)']\");\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        nor);\n\n    // should work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"uf\", \"id\",\n        \"uf\", \"_query_\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by omission\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","sourceOld":"  // test the edismax query parser based on the dismax parser\n  public void testFocusQueryParser() {\n    String allq = \"id:[42 TO 51]\";\n    String allr = \"*[count(//doc)=10]\";\n    String oner = \"*[count(//doc)=1]\";\n    String twor = \"*[count(//doc)=2]\";\n    String nor = \"*[count(//doc)=0]\";\n    \n    assertQ(\"blank q\",\n        req(\"q\",\" \",\n            \"q.alt\",allq,\n            \"defType\",\"edismax\")\n        ,allr);\n    \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n          req(\"q\", \"literal:colon\", \n              \"qf\", \"t_special\",\n              \"defType\", \"edismax\"),\n          \"//doc[1]/str[@name='id'][.='46']\"); \n\n    assertQ(\"standard request handler returns all matches\",\n            req(allq),\n            allr\n    );\n\n   assertQ(\"edismax query parser returns all matches\",\n            req(\"q\", allq,\n                \"defType\", \"edismax\"\n            ),\n            allr\n    );\n\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that field types that aren't applicable don't cause an exception to be thrown\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"trait_ss foo_i foo_f foo_dt foo_l foo_d foo_b\",\n               \"q\",\"Tool\"), twor\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:100\"), oner\n    );\n\n   // test that numeric field types can be queried\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n               \"q\",\"foo_i:-100\"), oner\n    );\n\n   // test that numeric field types can be queried  via qf\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw foo_i\",\n               \"q\",\"100\"), oner\n    );\n\n    assertQ(\"qf defaults to df\",\n        req(\"defType\", \"edismax\", \"df\", \"trait_ss\",\n        \"q\",\"Tool\"), twor\n    );\n\n   assertQ(\"qf defaults to defaultSearchField\"\n           , req( \"defType\", \"edismax\"\n                 ,\"q\",\"op\")\n           , twor\n           );\n   \n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"AND\",\n               \"q\",\"Order op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \n               \"qf\", \"name title subject text_sw\",\n               \"q.op\", \"OR\",\n               \"q\",\"Order op\"), twor\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order AND op\"), oner\n    );\n   assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order and op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"+Order op\"), oner\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order OR op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"Order or op\"), twor\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n               \"q\",\"*:*\"), allr\n    );\n\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"star OR (-star)\"), allr\n    );\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"name title subject text\",\n           \"q\",\"id:42 OR (-id:42)\"), allr\n    );\n\n    // test that basic synonyms work\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"GB\"), oner\n    );\n\n    // test for stopword removal in main query part\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_sw\",\n           \"q\",\"the big\"), twor\n    );\n\n    // test for stopwords not removed   \n    assertQ(req(\"defType\", \"edismax\", \n                \"qf\", \"text_sw\", \n                \"stopwords\",\"false\",\n                \"q.op\",\"AND\",\n                \"q\",\"the big\"), oner\n    );\n\n    // searching for a literal colon value when clearly not used for a field\n    assertQ(\"expected doc is missing (using standard)\",\n            req(\"q\", \"t_special:literal\\\\:colon\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal\\\\:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/field)\",\n            req(\"q\", \"t_special:literal:colon\", \n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using escaped edismax w/qf)\",\n            req(\"q\", \"literal\\\\:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\"); \n    assertQ(\"expected doc is missing (using un-escaped edismax w/qf)\",\n            req(\"q\", \"literal:colon\", \n                \"qf\", \"t_special\",\n                \"defType\", \"edismax\"),\n            \"//doc[1]/str[@name='id'][.='46']\");\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"terminator:3\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission:Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission : Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Mission: Impossible\", \"qf\",\"movies_t\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 2: Judgement Day\", \"qf\",\"movies_t\"),\n            oner);\n\n    // make sure the clause wasn't eliminated\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator 10: Judgement Day\", \"qf\",\"movies_t\"),\n            nor);\n\n    // throw in a numeric field\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"true\"),\n            nor);\n    // When sow=false, the per-field query structures differ (no \"Terminator\" query on integer field foo_i),\n    // so a dismax-per-field is constructed.  As a result, mm=100% is applied per-field instead of per-term;\n    // since there is only one term (100) required in the foo_i field's dismax, the query can match docs that\n    // only have the 100 term in the foo_i field, and don't necessarily have \"Terminator\" in any field.\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\", \"sow\",\"false\"),\n            oner);\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 100\", \"qf\",\"movies_t foo_i\"), // default sow=false\n        oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"100%\", \"q\",\"Terminator: 8\", \"qf\",\"movies_t foo_i\"),\n            oner);\n\n    assertQ(req(\"defType\",\"edismax\", \"mm\",\"0\", \"q\",\"movies_t:Terminator 100\", \"qf\",\"movies_t foo_i\"),\n            twor);\n    \n    // special psuedo-fields like _query_ and _val_\n\n    // _query_ should be excluded by default\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\",\n                \"debugQuery\", \"true\"),\n            nor,\n        \"//str[@name='parsedquery_toString'][.='+(((text:queri) (text:\\\"geofilt d 20 sfield store pt 12 34 56 78\\\"))~2)']\");\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        nor);\n\n    // should work when explicitly allowed\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id _query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\",\n                \"uf\", \"_query_\",\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            oner);\n    // again; this time use embedded local-params style\n    assertQ(req(\"defType\", \"edismax\",\n        \"mm\", \"100%\",\n        \"fq\", \"id:51\",\n        \"uf\", \"id\",\n        \"uf\", \"_query_\",\n        \"q\", \" {!geofilt d=20 sfield=store pt=12.34,-56.78}\"),//notice leading space\n        oner);\n\n    // should fail when prohibited\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"* -_query_\", // explicitly excluded\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n    assertQ(req(\"defType\", \"edismax\", \n                \"mm\", \"100%\",\n                \"fq\", \"id:51\",\n                \"uf\", \"id\", // excluded by omission\n                \"q\", \"_query_:\\\"{!geofilt d=20 sfield=store pt=12.34,-56.78}\\\"\"),\n            nor);\n\n\n    /** stopword removal in conjunction with multi-word synonyms at query time\n     * break this test.\n     // multi-word synonyms\n     // remove id:50 which contans the false match      \n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"text_t\", \"indent\",\"true\", \"debugQuery\",\"true\",\n           \"q\",\"-id:50 nyc\"), oner\n    );\n    **/\n\n    /*** these fail because multi-word synonyms are being used at query time\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"id title\",\n           \"q\",\"nyc\"), oner\n    );\n\n    // this will incorrectly match \"new big city\"\n    assertQ(req(\"defType\", \"edismax\", \"qf\", \"title\",\n           \"q\",\"the big apple\"), nor\n    );\n    ***/\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["c26f00b574427b55127e869b935845554afde1fa","245c71087515ed70d4fb9d9484f9dcbd79eebdfc"],"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["e55782fb51a6e9789542818eb2161a3247f39ace"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["220acde8206f5221383e3777429a4fb84bed289f","19275ba31e621f6da1b83bf13af75233876fd3d4"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"cf9d6fd2b46a1c50382c5cef6be68fd0525946ff":["4aee4980038a10791618ea04e79233ce5cbf6607"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["28288370235ed02234a64753cdbf0c6ec096304a"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["220acde8206f5221383e3777429a4fb84bed289f"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":["c03778630c4604270d88c148afb8c7de35b51d3c"],"c03778630c4604270d88c148afb8c7de35b51d3c":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"e55782fb51a6e9789542818eb2161a3247f39ace":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"b53e1fdeb877dfb9c1aba24b343170ae7ffe7108":["245c71087515ed70d4fb9d9484f9dcbd79eebdfc"],"28288370235ed02234a64753cdbf0c6ec096304a":["7a4260b228cfff6ad78ac88d519f0f7746529c3c","c8e2c1ef13fc86db819bf881ef0d9e0765eadfa0"],"7a4260b228cfff6ad78ac88d519f0f7746529c3c":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"],"220acde8206f5221383e3777429a4fb84bed289f":["576a4c26b3d237aa2626e691ea3b4fa016037fe3"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["36d81030ef9ff5ae6820e560c0833127181c7a2c","7a4260b228cfff6ad78ac88d519f0f7746529c3c"],"576a4c26b3d237aa2626e691ea3b4fa016037fe3":["b53e1fdeb877dfb9c1aba24b343170ae7ffe7108"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c8e2c1ef13fc86db819bf881ef0d9e0765eadfa0":["7a4260b228cfff6ad78ac88d519f0f7746529c3c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4aee4980038a10791618ea04e79233ce5cbf6607":["28288370235ed02234a64753cdbf0c6ec096304a","a91f19e3f7576973404e13b7ecfb8ae94f313921"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"245c71087515ed70d4fb9d9484f9dcbd79eebdfc":["c26f00b574427b55127e869b935845554afde1fa"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","c8e2c1ef13fc86db819bf881ef0d9e0765eadfa0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf9d6fd2b46a1c50382c5cef6be68fd0525946ff"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["7a4260b228cfff6ad78ac88d519f0f7746529c3c"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"c26f00b574427b55127e869b935845554afde1fa":["38e3b736c7ca086d61b7dbb841c905ee115490da","245c71087515ed70d4fb9d9484f9dcbd79eebdfc"],"cf9d6fd2b46a1c50382c5cef6be68fd0525946ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a91f19e3f7576973404e13b7ecfb8ae94f313921":["4aee4980038a10791618ea04e79233ce5cbf6607"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"c03778630c4604270d88c148afb8c7de35b51d3c":["36d81030ef9ff5ae6820e560c0833127181c7a2c"],"e55782fb51a6e9789542818eb2161a3247f39ace":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"],"28288370235ed02234a64753cdbf0c6ec096304a":["a91f19e3f7576973404e13b7ecfb8ae94f313921","4aee4980038a10791618ea04e79233ce5cbf6607"],"b53e1fdeb877dfb9c1aba24b343170ae7ffe7108":["576a4c26b3d237aa2626e691ea3b4fa016037fe3"],"7a4260b228cfff6ad78ac88d519f0f7746529c3c":["28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1","c8e2c1ef13fc86db819bf881ef0d9e0765eadfa0"],"220acde8206f5221383e3777429a4fb84bed289f":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","19275ba31e621f6da1b83bf13af75233876fd3d4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"576a4c26b3d237aa2626e691ea3b4fa016037fe3":["220acde8206f5221383e3777429a4fb84bed289f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c8e2c1ef13fc86db819bf881ef0d9e0765eadfa0":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"4aee4980038a10791618ea04e79233ce5cbf6607":["cf9d6fd2b46a1c50382c5cef6be68fd0525946ff"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"245c71087515ed70d4fb9d9484f9dcbd79eebdfc":["38e3b736c7ca086d61b7dbb841c905ee115490da","b53e1fdeb877dfb9c1aba24b343170ae7ffe7108"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a258fbb26824fd104ed795e5d9033d2d040049ee","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}