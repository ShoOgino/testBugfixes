{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","sourceNew":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    Transition maxTransition = null;\n    for (Transition transition : sortedTransitions[state]) {\n      if (transition.min < leadLabel) {\n        maxTransition = transition;\n      }\n    }\n\n    assert maxTransition != null;\n\n    // Append floorLabel\n    final int floorLabel;\n    if (maxTransition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = maxTransition.max;\n    }\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = maxTransition.to.getNumber();\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      Transition[] transitions = sortedTransitions[state];\n      if (transitions.length == 0) {\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        assert transitions.length != 0;\n        Transition lastTransition = transitions[transitions.length-1];\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        term.bytes[idx] = (byte) lastTransition.max;\n        state = lastTransition.to.getNumber();\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    Transition maxTransition = null;\n    for (Transition transition : sortedTransitions[state]) {\n      if (transition.min < leadLabel) {\n        maxTransition = transition;\n      }\n    }\n\n    assert maxTransition != null;\n\n    // Append floorLabel\n    final int floorLabel;\n    if (maxTransition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = maxTransition.max;\n    }\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = maxTransition.to.getNumber();\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      Transition[] transitions = sortedTransitions[state];\n      if (transitions.length == 0) {\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        assert transitions.length != 0;\n        Transition lastTransition = transitions[transitions.length-1];\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        term.bytes[idx] = (byte) lastTransition.max;\n        state = lastTransition.to.getNumber();\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","sourceNew":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(lightAutomaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    lightAutomaton.initTransition(state, scratch);\n    int numTransitions = lightAutomaton.getNumTransitions(state);\n    int maxIndex = -1;\n    int lastMin = 0;\n    for(int i=0;i<numTransitions;i++) {\n      lightAutomaton.getNextTransition(scratch);\n      if (scratch.min < leadLabel) {\n        maxIndex = i;\n      }\n      assert scratch.min >= lastMin;\n      lastMin = scratch.min;\n      // nocommit else break?\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    lightAutomaton.getTransition(state, maxIndex, scratch);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (scratch.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = scratch.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = scratch.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = lightAutomaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        lightAutomaton.getTransition(state, numTransitions-1, scratch);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) scratch.max;\n        state = scratch.dest;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    Transition maxTransition = null;\n    for (Transition transition : sortedTransitions[state]) {\n      if (transition.min < leadLabel) {\n        maxTransition = transition;\n      }\n    }\n\n    assert maxTransition != null;\n\n    // Append floorLabel\n    final int floorLabel;\n    if (maxTransition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = maxTransition.max;\n    }\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = maxTransition.to.getNumber();\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      Transition[] transitions = sortedTransitions[state];\n      if (transitions.length == 0) {\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        assert transitions.length != 0;\n        Transition lastTransition = transitions[transitions.length-1];\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        term.bytes[idx] = (byte) lastTransition.max;\n        state = lastTransition.to.getNumber();\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","sourceNew":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(lightAutomaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    int maxIndex = -1;\n    int numTransitions = lightAutomaton.initTransition(state, transition);\n    for(int i=0;i<numTransitions;i++) {\n      lightAutomaton.getNextTransition(transition);\n      if (transition.min < leadLabel) {\n        maxIndex = i;\n      } else {\n        // Transitions are alway sorted\n        break;\n      }\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    lightAutomaton.getTransition(state, maxIndex, transition);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (transition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = transition.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = transition.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = lightAutomaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        lightAutomaton.getTransition(state, numTransitions-1, transition);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) transition.max;\n        state = transition.dest;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(lightAutomaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    lightAutomaton.initTransition(state, scratch);\n    int numTransitions = lightAutomaton.getNumTransitions(state);\n    int maxIndex = -1;\n    int lastMin = 0;\n    for(int i=0;i<numTransitions;i++) {\n      lightAutomaton.getNextTransition(scratch);\n      if (scratch.min < leadLabel) {\n        maxIndex = i;\n      }\n      assert scratch.min >= lastMin;\n      lastMin = scratch.min;\n      // nocommit else break?\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    lightAutomaton.getTransition(state, maxIndex, scratch);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (scratch.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = scratch.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = scratch.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = lightAutomaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        lightAutomaton.getTransition(state, numTransitions-1, scratch);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) scratch.max;\n        state = scratch.dest;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","sourceNew":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(automaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    int maxIndex = -1;\n    int numTransitions = automaton.initTransition(state, transition);\n    for(int i=0;i<numTransitions;i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min < leadLabel) {\n        maxIndex = i;\n      } else {\n        // Transitions are alway sorted\n        break;\n      }\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    automaton.getTransition(state, maxIndex, transition);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (transition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = transition.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = transition.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = automaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        automaton.getTransition(state, numTransitions-1, transition);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) transition.max;\n        state = transition.dest;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(lightAutomaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    int maxIndex = -1;\n    int numTransitions = lightAutomaton.initTransition(state, transition);\n    for(int i=0;i<numTransitions;i++) {\n      lightAutomaton.getNextTransition(transition);\n      if (transition.min < leadLabel) {\n        maxIndex = i;\n      } else {\n        // Transitions are alway sorted\n        break;\n      }\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    lightAutomaton.getTransition(state, maxIndex, transition);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (transition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = transition.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = transition.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = lightAutomaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        lightAutomaton.getTransition(state, numTransitions-1, transition);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) transition.max;\n        state = transition.dest;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","sourceNew":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(automaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    int maxIndex = -1;\n    int numTransitions = automaton.initTransition(state, transition);\n    for(int i=0;i<numTransitions;i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min < leadLabel) {\n        maxIndex = i;\n      } else {\n        // Transitions are alway sorted\n        break;\n      }\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    automaton.getTransition(state, maxIndex, transition);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (transition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = transition.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = transition.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = automaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        automaton.getTransition(state, numTransitions-1, transition);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) transition.max;\n        state = transition.dest;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    Transition maxTransition = null;\n    for (Transition transition : sortedTransitions[state]) {\n      if (transition.min < leadLabel) {\n        maxTransition = transition;\n      }\n    }\n\n    assert maxTransition != null;\n\n    // Append floorLabel\n    final int floorLabel;\n    if (maxTransition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = maxTransition.max;\n    }\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = maxTransition.to.getNumber();\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      Transition[] transitions = sortedTransitions[state];\n      if (transitions.length == 0) {\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        assert transitions.length != 0;\n        Transition lastTransition = transitions[transitions.length-1];\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        term.bytes[idx] = (byte) lastTransition.max;\n        state = lastTransition.to.getNumber();\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRefBuilder,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#addTail(int,BytesRef,int,int).mjava","sourceNew":"  private BytesRef addTail(int state, BytesRefBuilder term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(automaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    int maxIndex = -1;\n    int numTransitions = automaton.initTransition(state, transition);\n    for(int i=0;i<numTransitions;i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min < leadLabel) {\n        maxIndex = i;\n      } else {\n        // Transitions are alway sorted\n        break;\n      }\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    automaton.getTransition(state, maxIndex, transition);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (transition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = transition.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    term.grow(1+idx);\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.setByteAt(idx, (byte) floorLabel);\n\n    state = transition.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = automaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.setLength(idx);\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term.get();\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        automaton.getTransition(state, numTransitions-1, transition);\n        term.grow(1+idx);\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.setByteAt(idx, (byte) transition.max);\n        state = transition.dest;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  private BytesRef addTail(int state, BytesRef term, int idx, int leadLabel) {\n    //System.out.println(\"addTail state=\" + state + \" term=\" + term.utf8ToString() + \" idx=\" + idx + \" leadLabel=\" + (char) leadLabel);\n    //System.out.println(automaton.toDot());\n    // Find biggest transition that's < label\n    // TODO: use binary search here\n    int maxIndex = -1;\n    int numTransitions = automaton.initTransition(state, transition);\n    for(int i=0;i<numTransitions;i++) {\n      automaton.getNextTransition(transition);\n      if (transition.min < leadLabel) {\n        maxIndex = i;\n      } else {\n        // Transitions are alway sorted\n        break;\n      }\n    }\n\n    //System.out.println(\"  maxIndex=\" + maxIndex);\n\n    assert maxIndex != -1;\n    automaton.getTransition(state, maxIndex, transition);\n\n    // Append floorLabel\n    final int floorLabel;\n    if (transition.max > leadLabel-1) {\n      floorLabel = leadLabel-1;\n    } else {\n      floorLabel = transition.max;\n    }\n    //System.out.println(\"  floorLabel=\" + (char) floorLabel);\n    if (idx >= term.bytes.length) {\n      term.grow(1+idx);\n    }\n    //if (DEBUG) System.out.println(\"  add floorLabel=\" + (char) floorLabel + \" idx=\" + idx);\n    term.bytes[idx] = (byte) floorLabel;\n\n    state = transition.dest;\n    //System.out.println(\"  dest: \" + state);\n    idx++;\n\n    // Push down to last accept state\n    while (true) {\n      numTransitions = automaton.getNumTransitions(state);\n      if (numTransitions == 0) {\n        //System.out.println(\"state=\" + state + \" 0 trans\");\n        assert runAutomaton.isAccept(state);\n        term.length = idx;\n        //if (DEBUG) System.out.println(\"  return \" + term.utf8ToString());\n        return term;\n      } else {\n        // We are pushing \"top\" -- so get last label of\n        // last transition:\n        //System.out.println(\"get state=\" + state + \" numTrans=\" + numTransitions);\n        automaton.getTransition(state, numTransitions-1, transition);\n        if (idx >= term.bytes.length) {\n          term.grow(1+idx);\n        }\n        //if (DEBUG) System.out.println(\"  push maxLabel=\" + (char) lastTransition.max + \" idx=\" + idx);\n        //System.out.println(\"  add trans dest=\" + scratch.dest + \" label=\" + (char) scratch.max);\n        term.bytes[idx] = (byte) transition.max;\n        state = transition.dest;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c84485629d80d203608e8975a1139de9933cc38":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}