{"path":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","commits":[{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"/dev/null","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n      Thread.sleep(5000);\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (!state.equals(\"running\")) {\n        state = getRequestState(\"2000\", server);\n        if (state.equals(\"completed\") || state.equals(\"failed\"))\n          break;\n        Thread.sleep(100);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0428390b48819d16046c743692336336c129d872","6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"/dev/null","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n      Thread.sleep(5000);\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (!state.equals(\"running\")) {\n        state = getRequestState(\"2000\", server);\n        if (state.equals(\"completed\") || state.equals(\"failed\"))\n          break;\n        Thread.sleep(100);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74fe755c1cb9c998d933b455c573e86e9ef5d2aa","date":1401724046,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n      Thread.sleep(5000);\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (!state.equals(\"running\")) {\n        state = getRequestState(\"2000\", server);\n        if (state.equals(\"completed\") || state.equals(\"failed\"))\n          break;\n        Thread.sleep(100);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ff2ea054f72177967223fb032d708ad8020e80a","date":1401922976,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      server.request(request);\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0428390b48819d16046c743692336336c129d872","date":1402354740,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      server.request(request);\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      invokeCollectionApi(\"action\", CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      server.request(request);\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":["6f26f74e4969851a019d28f10315cb1c77786f22"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a7d7ef06ef6f04ba2de657e90e0458048a967c6","date":1409691631,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(server);\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      server.request(request);\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      CollectionAdminRequest.splitShard(\"collection1\", SHARD1, server, \"2000\");\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      server.request(request);\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrServer server = createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0)));\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(server);\n\n      String state = getRequestState(\"2000\", server);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", server);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      server.request(request);\n\n      state = getRequestState(\"2000\", server);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n    try {\n\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      } finally {\n        client.shutdown();\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n\n    try {\n\n      SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":["6f26f74e4969851a019d28f10315cb1c77786f22","bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n    try {\n\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      } finally {\n        client.shutdown();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"182acd29cf4cb1644a02b8517f3a5b867c0d7cce","date":1432665213,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard();\n      splitShardRequest.setCollectionName(\"collection1\");\n      splitShardRequest.setShardName(SHARD1);\n      splitShardRequest.setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3088cdaa24ffe3ef44713ac9484114bd56eca2af","date":1453441194,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      String state = getRequestState(\"2000\", client);\n      while (state.equals(\"submitted\")) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertTrue(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\", state.equals(\"running\"));\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertTrue(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but isn't.\" +\n          \"It is [\" + state + \"]\", state.equals(\"running\"));\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac97ea104d893f16aab430d9904473bc1f233f3c","date":1496249396,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n      splitShardRequest.processAsync(\"2000\",client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3217321f3e1d7922898c6c633d17acfa840d6875","date":1496257480,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n      splitShardRequest.processAsync(\"2000\",client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n      splitShardRequest.processAsync(\"2000\",client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n      splitShardRequest.processAsync(\"2000\",client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = new SplitShard()\n              .setCollectionName(\"collection1\")\n              .setShardName(SHARD1)\n              .setAsyncId(\"2000\");\n      splitShardRequest.process(client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest#testLongAndShortRunningParallelApiCalls().mjava","sourceNew":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n      splitShardRequest.processAsync(\"2000\",client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      @SuppressWarnings({\"rawtypes\"})\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","sourceOld":"  private void testLongAndShortRunningParallelApiCalls() throws InterruptedException, IOException, SolrServerException {\n\n    Thread indexThread = new Thread() {\n      @Override\n      public void run() {\n        Random random = random();\n        int max = atLeast(random, 200);\n        for (int id = 101; id < max; id++) {\n          try {\n            doAddDoc(String.valueOf(id));\n          } catch (Exception e) {\n            log.error(\"Exception while adding docs\", e);\n          }\n        }\n      }\n    };\n    indexThread.start();\n    try (SolrClient client = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n\n      SplitShard splitShardRequest = CollectionAdminRequest.splitShard(\"collection1\").setShardName(SHARD1);\n      splitShardRequest.processAsync(\"2000\",client);\n\n      RequestStatusState state = getRequestState(\"2000\", client);\n      while (state ==  RequestStatusState.SUBMITTED) {\n        state = getRequestState(\"2000\", client);\n        Thread.sleep(10);\n      }\n      assertSame(\"SplitShard task [2000] was supposed to be in [running] but isn't. It is [\" + state + \"]\",\n          RequestStatusState.RUNNING, state);\n\n      // CLUSTERSTATE is always mutually exclusive, it should return with a response before the split completes\n\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionParams.CollectionAction.CLUSTERSTATUS.toString());\n      params.set(\"collection\", \"collection1\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n\n      client.request(request);\n\n      state = getRequestState(\"2000\", client);\n\n      assertSame(\"After invoking OVERSEERSTATUS, SplitShard task [2000] was still supposed to be in [running] but \"\n          + \"isn't. It is [\" + state + \"]\", RequestStatusState.RUNNING, state);\n\n    } finally {\n      try {\n        indexThread.join();\n      } catch (InterruptedException e) {\n        log.warn(\"Indexing thread interrupted.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8ff2ea054f72177967223fb032d708ad8020e80a":["74fe755c1cb9c998d933b455c573e86e9ef5d2aa"],"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"bafca15d8e408346a67f4282ad1143b88023893b":["4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"3217321f3e1d7922898c6c633d17acfa840d6875":["3088cdaa24ffe3ef44713ac9484114bd56eca2af","ac97ea104d893f16aab430d9904473bc1f233f3c"],"0428390b48819d16046c743692336336c129d872":["8ff2ea054f72177967223fb032d708ad8020e80a"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6f26f74e4969851a019d28f10315cb1c77786f22"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["3088cdaa24ffe3ef44713ac9484114bd56eca2af","3217321f3e1d7922898c6c633d17acfa840d6875"],"4a7d7ef06ef6f04ba2de657e90e0458048a967c6":["0428390b48819d16046c743692336336c129d872"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["3088cdaa24ffe3ef44713ac9484114bd56eca2af","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["3217321f3e1d7922898c6c633d17acfa840d6875"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"6f26f74e4969851a019d28f10315cb1c77786f22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["bafca15d8e408346a67f4282ad1143b88023893b"],"74fe755c1cb9c998d933b455c573e86e9ef5d2aa":["6f26f74e4969851a019d28f10315cb1c77786f22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"8ff2ea054f72177967223fb032d708ad8020e80a":["0428390b48819d16046c743692336336c129d872"],"3088cdaa24ffe3ef44713ac9484114bd56eca2af":["ac97ea104d893f16aab430d9904473bc1f233f3c","3217321f3e1d7922898c6c633d17acfa840d6875","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","e9017cf144952056066919f1ebc7897ff9bd71b1"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3217321f3e1d7922898c6c633d17acfa840d6875"],"bafca15d8e408346a67f4282ad1143b88023893b":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"3217321f3e1d7922898c6c633d17acfa840d6875":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"0428390b48819d16046c743692336336c129d872":["4a7d7ef06ef6f04ba2de657e90e0458048a967c6"],"b7605579001505896d48b07160075a5c8b8e128e":[],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"4a7d7ef06ef6f04ba2de657e90e0458048a967c6":["bafca15d8e408346a67f4282ad1143b88023893b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["182acd29cf4cb1644a02b8517f3a5b867c0d7cce"],"182acd29cf4cb1644a02b8517f3a5b867c0d7cce":["3088cdaa24ffe3ef44713ac9484114bd56eca2af"],"6f26f74e4969851a019d28f10315cb1c77786f22":["b7605579001505896d48b07160075a5c8b8e128e","74fe755c1cb9c998d933b455c573e86e9ef5d2aa"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"74fe755c1cb9c998d933b455c573e86e9ef5d2aa":["8ff2ea054f72177967223fb032d708ad8020e80a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}