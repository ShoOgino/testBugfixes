{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory).mjava","pathOld":"/dev/null","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion, SearcherFactory searcherFactory) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        message(\"init: marker hit count: \" + s.search(new TermQuery(new Term(\"marker\", \"marker\")), 1).totalHits);\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion, SearcherFactory searcherFactory) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion, SearcherFactory searcherFactory) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        message(\"init: marker hit count: \" + s.search(new TermQuery(new Term(\"marker\", \"marker\")), 1).totalHits);\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion, SearcherFactory searcherFactory) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"2b844e2ae5435a8d4d925003c10027c25e26e02d":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"2b844e2ae5435a8d4d925003c10027c25e26e02d":[],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["2b844e2ae5435a8d4d925003c10027c25e26e02d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2b844e2ae5435a8d4d925003c10027c25e26e02d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}