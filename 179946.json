{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23550189554f52bad1625fceab84a71d20a4df3f","date":1321064526,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":["ac3e6437547a34cce2b5405ce0cf9e3af578401e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","date":1367858986,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195","date":1373388895,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n\n      TopDocsCollector topCollector;\n\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      DocSetCollector setCollector;\n\n       if (!needScores) {\n         collector = setCollector = new DocSetCollector(smallSetSize, maxDoc);\n       } else {\n         collector = setCollector = new DocSetDelegateCollector(smallSetSize, maxDoc, new Collector() {\n           Scorer scorer;\n           @Override\n          public void setScorer(Scorer scorer) {\n             this.scorer = scorer;\n           }\n           @Override\n          public void collect(int doc) throws IOException {\n             float score = scorer.score();\n             if (score > topscore[0]) topscore[0]=score;\n           }\n           @Override\n          public void setNextReader(AtomicReaderContext context) {\n           }\n           @Override\n          public boolean acceptsDocsOutOfOrder() {\n             return false;\n           }\n         });\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetDelegateCollector(maxDoc>>6, maxDoc, topCollector);\n      Collector collector = setCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3219e7215437030592c42ca55b29e3f77e0d6808","date":1402349186,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    final long timeAllowed = cmd.getTimeAllowed();\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       if (terminateEarly) {\n         collector = new EarlyTerminatingCollector(collector, cmd.len);\n       }\n       if( timeAllowed > 0 ) {\n         collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n       }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n       try {\n         super.search(query, luceneFilter, collector);\n         if(collector instanceof DelegatingCollector) {\n           ((DelegatingCollector)collector).finish();\n         }\n       }\n       catch( TimeLimitingCollector.TimeExceededException x ) {\n         log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n         qr.setPartialResults(true);\n       }\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed );\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0","date":1442027674,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    int smallSetSize = maxDoc>>6;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(smallSetSize, maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc>>6, maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n       if (!needScores) {\n         collector = setCollector;\n       } else {\n         final Collector topScoreCollector = new SimpleCollector() {\n          \n           Scorer scorer;\n           \n           @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n           \n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n        \n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n       }\n       \n       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();      \n\n      totalHits = topCollector.getTotalHits();\n      assert(totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter==null && pf.postFilter==null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3","date":1485881524,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = setCollector.getDocSet();\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16fb59ed0a06960e7f3c0343d15d638ec5ea2b10","date":1527104253,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      Collector collector = MultiCollector.wrap(topCollector, setCollector);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size());\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d8a0350513120be3cf48c0eafd6b8787fcd3ec","date":1586897159,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"640ded7811e1b7d29236a5e2934ec3cd266a8199","date":1588973147,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactHits(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b8ad6d99eb2424679c78255c369b8fac243e7dd","date":1590104557,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactHits(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72afa881b0b5c361ebd0b6d37927fe072151fbe0","date":1590107364,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactHits(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListAndSetNC(QueryResult,QueryCommand).mjava","sourceNew":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      @SuppressWarnings({\"rawtypes\"})\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","sourceOld":"  // any DocSet returned is for the query only, without any filtering... that way it may\n  // be cached if desired.\n  private DocSet getDocListAndSetNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n    DocSet set;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    int maxDoc = maxDoc();\n    cmd.setMinExactCount(Integer.MAX_VALUE);// We need the full DocSet\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n\n      Collector collector;\n      final DocSetCollector setCollector = new DocSetCollector(maxDoc);\n\n      if (!needScores) {\n        collector = setCollector;\n      } else {\n        final Collector topScoreCollector = new SimpleCollector() {\n\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.TOP_SCORES;\n          }\n        };\n\n        collector = MultiCollector.wrap(setCollector, topScoreCollector);\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = set.size();\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      DocSetCollector setCollector = new DocSetCollector(maxDoc);\n      MaxScoreCollector maxScoreCollector = null;\n      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));\n\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collectors.add(maxScoreCollector);\n      }\n\n      Collector collector = MultiCollector.wrap(collectors);\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      set = DocSetUtil.getDocSet(setCollector, this);\n\n      totalHits = topCollector.getTotalHits();\n      assert (totalHits == set.size()) || qr.isPartialResults();\n\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, TotalHits.Relation.EQUAL_TO));\n    // TODO: if we collect results before the filter, we just need to intersect with\n    // that filter to generate the DocSet for qr.setDocSet()\n    qr.setDocSet(set);\n\n    // TODO: currently we don't generate the DocSet for the base query,\n    // but the QueryDocSet == CompleteDocSet if filter==null.\n    return pf.filter == null && pf.postFilter == null ? qr.getDocSet() : null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"640ded7811e1b7d29236a5e2934ec3cd266a8199":["d4d8a0350513120be3cf48c0eafd6b8787fcd3ec"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["ac9de183adbc9483681f275ac1e2d92ed19f52e1","0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["1db68e96dd908fcd79ef809095822736aa601d08"],"72afa881b0b5c361ebd0b6d37927fe072151fbe0":["640ded7811e1b7d29236a5e2934ec3cd266a8199","6b8ad6d99eb2424679c78255c369b8fac243e7dd"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["16fb59ed0a06960e7f3c0343d15d638ec5ea2b10","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2","ae73da626f97850c922c42736f808d0378e165f0"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["23550189554f52bad1625fceab84a71d20a4df3f"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3"],"3219e7215437030592c42ca55b29e3f77e0d6808":["ae73da626f97850c922c42736f808d0378e165f0"],"6b8ad6d99eb2424679c78255c369b8fac243e7dd":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"d4d8a0350513120be3cf48c0eafd6b8787fcd3ec":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3","9fc47cb7b4346802411bb432f501ed0673d7119e"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["72afa881b0b5c361ebd0b6d37927fe072151fbe0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["3219e7215437030592c42ca55b29e3f77e0d6808"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["23550189554f52bad1625fceab84a71d20a4df3f","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"16fb59ed0a06960e7f3c0343d15d638ec5ea2b10":["417142ff08fda9cf0b72d5133e63097a166c6458"],"ae73da626f97850c922c42736f808d0378e165f0":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"23550189554f52bad1625fceab84a71d20a4df3f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["16fb59ed0a06960e7f3c0343d15d638ec5ea2b10"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"]},"commit2Childs":{"640ded7811e1b7d29236a5e2934ec3cd266a8199":["72afa881b0b5c361ebd0b6d37927fe072151fbe0","6b8ad6d99eb2424679c78255c369b8fac243e7dd"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"c26f00b574427b55127e869b935845554afde1fa":["23550189554f52bad1625fceab84a71d20a4df3f"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"a3584d3db8b472772e3329d9d95d584b68ae997e":["d4d8a0350513120be3cf48c0eafd6b8787fcd3ec"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"72afa881b0b5c361ebd0b6d37927fe072151fbe0":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"1db68e96dd908fcd79ef809095822736aa601d08":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"3219e7215437030592c42ca55b29e3f77e0d6808":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"6b8ad6d99eb2424679c78255c369b8fac243e7dd":["72afa881b0b5c361ebd0b6d37927fe072151fbe0"],"d4d8a0350513120be3cf48c0eafd6b8787fcd3ec":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"417142ff08fda9cf0b72d5133e63097a166c6458":["16fb59ed0a06960e7f3c0343d15d638ec5ea2b10"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"16fb59ed0a06960e7f3c0343d15d638ec5ea2b10":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"ae73da626f97850c922c42736f808d0378e165f0":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","3219e7215437030592c42ca55b29e3f77e0d6808"],"23550189554f52bad1625fceab84a71d20a4df3f":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","1d3f7ab1a502671bbdb03bcced21e764d2483221"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","15e323346eac5e4685c0a9f2df85eb96b4239bbb","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}