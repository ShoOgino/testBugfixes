{"path":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40d527f1505faaeef6026b8c5edd5ba37a3c59ca","date":1319678087,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time ot init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          SolrConfig.severeErrors.add( ex );\n          SolrException e = new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n          SolrException.logOnce(log,null,e);\n          throw e;\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba9a527ca6b00f668b0a55c9633742cf70a05fec","date":1332905879,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7cf6ebde2188bcc6d0523f1eb74e734695522dc","date":1332941885,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0242ba41ae04434a68e1eaafe5e711a3d7d6208a","date":1332995871,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(DEFAULT_HANDLER_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<PluginInfo,SolrRequestHandler>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2336740b200d02b6a5fb18b70454dd9aa26f5b47","date":1407004842,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig,List[PluginInfo]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config, List<PluginInfo> implicits){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    ArrayList<PluginInfo> infos = new ArrayList<>(implicits);\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config ){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      if (requestHandler instanceof PluginInfoInitialized) {\n        ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e56881a4ebc3438313e3c008a7124ba0f8ecc7bf","date":1416997673,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig,List[PluginInfo]).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> implicitInfoMap= new HashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) implicitInfoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(implicitInfoMap.containsKey(info.name)) implicitInfoMap.remove(info.name);\n    ArrayList<PluginInfo> infos = new ArrayList<>(implicitInfoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config, List<PluginInfo> implicits){\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> implicitInfoMap= new HashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) implicitInfoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(implicitInfoMap.containsKey(info.name)) implicitInfoMap.remove(info.name);\n    ArrayList<PluginInfo> infos = new ArrayList<>(implicitInfoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8d1f2c78f560980e5822db6905bb3b2f52fdbe5","date":1417094182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> implicitInfoMap= new HashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) implicitInfoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(implicitInfoMap.containsKey(info.name)) implicitInfoMap.remove(info.name);\n    ArrayList<PluginInfo> infos = new ArrayList<>(implicitInfoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9bd61f133870fb7f5098ae91eeda31b729d446","date":1418891132,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className);\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className, info.initArgs );\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b96ad5eead3ef9b09cee72d7b54b8bfc369859bd","date":1419078070,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        String lib = info.attributes.get(\"lib\");\n        if(lib != null){\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core);\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core, info.className);\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7eea62cd13a5ddc4fb9abea3b3820ff3128cb26","date":1419094190,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if (infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\");\n        String lib = info.attributes.get(\"lib\");\n        if (lib != null) {\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if (startup != null) {\n          if (\"lazy\".equals(startup)) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper(core);\n          } else {\n            throw new Exception(\"Unknown startup value: '\" + startup + \"' for: \" + info.className);\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n        \n        handlers.put(info, requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if (old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if (info.isDefault()) {\n          old = register(\"\", requestHandler);\n          if (old != null) log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName());\n        }\n        log.info(\"created \" + info.name + \": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if(infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\") ;\n        String lib = info.attributes.get(\"lib\");\n        if(lib != null){\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if( startup != null ) {\n          if( \"lazy\".equals(startup) ) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper( core);\n          } else {\n            throw new Exception( \"Unknown startup value: '\"+startup+\"' for: \"+info.className );\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n\n        handlers.put(info,requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if(old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if(info.isDefault()){\n          old = register(\"\",requestHandler);\n          if(old != null)\n            log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName()); \n        }\n        log.info(\"created \"+info.name+\": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1","date":1423220905,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\");\n        String lib = info.attributes.get(\"lib\");\n        if (lib != null) {\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if (startup != null) {\n          if (\"lazy\".equals(startup)) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper(core);\n          } else {\n            throw new Exception(\"Unknown startup value: '\" + startup + \"' for: \" + info.className);\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n        \n        handlers.put(info, requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if (old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if (info.isDefault()) {\n          old = register(\"\", requestHandler);\n          if (old != null) log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName());\n        }\n        log.info(\"created \" + info.name + \": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName()))\n      if (infoMap.containsKey(info.name)) infoMap.remove(info.name);\n    for (Map.Entry e : core.getSolrConfig().getOverlay().getReqHandlers().entrySet())\n      infoMap.put((String)e.getKey(), new PluginInfo(SolrRequestHandler.TYPE, (Map)e.getValue()));\n\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    infos.addAll(config.getPluginInfos(SolrRequestHandler.class.getName()));\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\");\n        String lib = info.attributes.get(\"lib\");\n        if (lib != null) {\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if (startup != null) {\n          if (\"lazy\".equals(startup)) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper(core);\n          } else {\n            throw new Exception(\"Unknown startup value: '\" + startup + \"' for: \" + info.className);\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n        \n        handlers.put(info, requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if (old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if (info.isDefault()) {\n          old = register(\"\", requestHandler);\n          if (old != null) log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName());\n        }\n        log.info(\"created \" + info.name + \": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = ImplicitPlugins.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if(!handlers.alias( \"/select\",\"\")){\n      if(!handlers.alias( \"standard\",\"\")){\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\");\n        String lib = info.attributes.get(\"lib\");\n        if (lib != null) {\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if (startup != null) {\n          if (\"lazy\".equals(startup)) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper(core);\n          } else {\n            throw new Exception(\"Unknown startup value: '\" + startup + \"' for: \" + info.className);\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n        \n        handlers.put(info, requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if (old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if (info.isDefault()) {\n          old = register(\"\", requestHandler);\n          if (old != null) log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName());\n        }\n        log.info(\"created \" + info.name + \": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = ImplicitPlugins.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if(!handlers.alias( \"/select\",\"\")){\n      if(!handlers.alias( \"standard\",\"\")){\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config){\n    List<PluginInfo> implicits = PluginsRegistry.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<PluginInfo,SolrRequestHandler> handlers = new LinkedHashMap<>();\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n    for (PluginInfo info : infos) {\n      try {\n        SolrRequestHandler requestHandler;\n        String startup = info.attributes.get(\"startup\");\n        String lib = info.attributes.get(\"lib\");\n        if (lib != null) {\n          requestHandler = new DynamicLazyRequestHandlerWrapper(core);\n        } else if (startup != null) {\n          if (\"lazy\".equals(startup)) {\n            log.info(\"adding lazy requestHandler: \" + info.className);\n            requestHandler = new LazyRequestHandlerWrapper(core);\n          } else {\n            throw new Exception(\"Unknown startup value: '\" + startup + \"' for: \" + info.className);\n          }\n        } else {\n          requestHandler = core.createRequestHandler(info.className);\n        }\n        if (requestHandler instanceof RequestHandlerBase) ((RequestHandlerBase) requestHandler).setPluginInfo(info);\n        \n        handlers.put(info, requestHandler);\n        SolrRequestHandler old = register(info.name, requestHandler);\n        if (old != null) {\n          log.warn(\"Multiple requestHandler registered to the same name: \" + info.name + \" ignoring: \" + old.getClass().getName());\n        }\n        if (info.isDefault()) {\n          old = register(\"\", requestHandler);\n          if (old != null) log.warn(\"Multiple default requestHandler registered\" + \" ignoring: \" + old.getClass().getName());\n        }\n        log.info(\"created \" + info.name + \": \" + info.className);\n      } catch (Exception ex) {\n          throw new SolrException\n            (ErrorCode.SERVER_ERROR, \"RequestHandler init failure\", ex);\n      }\n    }\n\n    // we've now registered all handlers, time to init them in the same order\n    for (Map.Entry<PluginInfo,SolrRequestHandler> entry : handlers.entrySet()) {\n      PluginInfo info = entry.getKey();\n      SolrRequestHandler requestHandler = entry.getValue();\n      info = applyInitParams(config, info);\n      if (requestHandler instanceof PluginInfoInitialized) {\n       ((PluginInfoInitialized) requestHandler).init(info);\n      } else{\n        requestHandler.init(info.initArgs);\n      }\n    }\n\n    if(get(\"\") == null) register(\"\", get(\"/select\"));//defacto default handler\n    if(get(\"\") == null) register(\"\", get(\"standard\"));//old default handler name; TODO remove?\n    if(get(\"\") == null)\n      log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb795a05e912609e957829cb36bb98abd1393ca1","date":1441206807,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = ImplicitPlugins.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = ImplicitPlugins.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if(!handlers.alias( \"/select\",\"\")){\n      if(!handlers.alias( \"standard\",\"\")){\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4","date":1456067995,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = ImplicitPlugins.getHandlers(core);\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d62172dd2fc1195c7e475550ac394a9948a18ae","date":1474974102,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.debug(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.debug(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.debug(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.info(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/RequestHandlers#initHandlersFromConfig(SolrConfig).mjava","sourceNew":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    if (log.isDebugEnabled()) {\n      log.debug(\"Registered paths: {}\", StrUtils.join(new ArrayList<>(handlers.keySet()), ','));\n    }\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Read solrconfig.xml and register the appropriate handlers\n   * \n   * This function should <b>only</b> be called from the SolrCore constructor.  It is\n   * not intended as a public API.\n   * \n   * While the normal runtime registration contract is that handlers MUST be initialized\n   * before they are registered, this function does not do that exactly.\n   *\n   * This function registers all handlers first and then calls init() for each one.\n   *\n   * This is OK because this function is only called at startup and there is no chance that\n   * a handler could be asked to handle a request before it is initialized.\n   * \n   * The advantage to this approach is that handlers can know what path they are registered\n   * to and what other handlers are available at startup.\n   * \n   * Handlers will be registered and initialized in the order they appear in solrconfig.xml\n   */\n\n  void initHandlersFromConfig(SolrConfig config) {\n    List<PluginInfo> implicits = core.getImplicitHandlers();\n    // use link map so we iterate in the same order\n    Map<String, PluginInfo> infoMap= new LinkedHashMap<>();\n    //deduping implicit and explicit requesthandlers\n    for (PluginInfo info : implicits) infoMap.put(info.name,info);\n    for (PluginInfo info : config.getPluginInfos(SolrRequestHandler.class.getName())) infoMap.put(info.name, info);\n    ArrayList<PluginInfo> infos = new ArrayList<>(infoMap.values());\n\n    List<PluginInfo> modifiedInfos = new ArrayList<>();\n    for (PluginInfo info : infos) {\n      modifiedInfos.add(applyInitParams(config, info));\n    }\n    handlers.init(Collections.emptyMap(),core, modifiedInfos);\n    handlers.alias(handlers.getDefault(), \"\");\n    log.debug(\"Registered paths: {}\" , StrUtils.join(new ArrayList<>(handlers.keySet()) , ',' ));\n    if (handlers.get(\"\") == null && !handlers.alias(\"/select\", \"\")) {\n      if (handlers.get(\"\") == null && !handlers.alias(\"standard\", \"\")) {\n        log.warn(\"no default request handler is registered (either '/select' or 'standard')\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2336740b200d02b6a5fb18b70454dd9aa26f5b47":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a7cf6ebde2188bcc6d0523f1eb74e734695522dc":["ba9a527ca6b00f668b0a55c9633742cf70a05fec"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1","9aea0485ecacb6734c17da2d02569816c23a69c1"],"140be51d03394488536f4aacedace29f9b318347":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"fb795a05e912609e957829cb36bb98abd1393ca1":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1":["b7eea62cd13a5ddc4fb9abea3b3820ff3128cb26"],"fd9bd61f133870fb7f5098ae91eeda31b729d446":["d8d1f2c78f560980e5822db6905bb3b2f52fdbe5"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["40d527f1505faaeef6026b8c5edd5ba37a3c59ca"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1"],"d8d1f2c78f560980e5822db6905bb3b2f52fdbe5":["e56881a4ebc3438313e3c008a7124ba0f8ecc7bf"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0242ba41ae04434a68e1eaafe5e711a3d7d6208a"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4"],"b7eea62cd13a5ddc4fb9abea3b3820ff3128cb26":["b96ad5eead3ef9b09cee72d7b54b8bfc369859bd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b96ad5eead3ef9b09cee72d7b54b8bfc369859bd":["fd9bd61f133870fb7f5098ae91eeda31b729d446"],"0242ba41ae04434a68e1eaafe5e711a3d7d6208a":["a7cf6ebde2188bcc6d0523f1eb74e734695522dc"],"ba9a527ca6b00f668b0a55c9633742cf70a05fec":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4":["fb795a05e912609e957829cb36bb98abd1393ca1"],"e56881a4ebc3438313e3c008a7124ba0f8ecc7bf":["2336740b200d02b6a5fb18b70454dd9aa26f5b47"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"40d527f1505faaeef6026b8c5edd5ba37a3c59ca":["c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["140be51d03394488536f4aacedace29f9b318347"]},"commit2Childs":{"2336740b200d02b6a5fb18b70454dd9aa26f5b47":["e56881a4ebc3438313e3c008a7124ba0f8ecc7bf"],"a7cf6ebde2188bcc6d0523f1eb74e734695522dc":["0242ba41ae04434a68e1eaafe5e711a3d7d6208a"],"c26f00b574427b55127e869b935845554afde1fa":["40d527f1505faaeef6026b8c5edd5ba37a3c59ca"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"140be51d03394488536f4aacedace29f9b318347":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["140be51d03394488536f4aacedace29f9b318347","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"fb795a05e912609e957829cb36bb98abd1393ca1":["7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4"],"c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"fd9bd61f133870fb7f5098ae91eeda31b729d446":["b96ad5eead3ef9b09cee72d7b54b8bfc369859bd"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["ba9a527ca6b00f668b0a55c9633742cf70a05fec"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fb795a05e912609e957829cb36bb98abd1393ca1"],"d8d1f2c78f560980e5822db6905bb3b2f52fdbe5":["fd9bd61f133870fb7f5098ae91eeda31b729d446"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2336740b200d02b6a5fb18b70454dd9aa26f5b47"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b7eea62cd13a5ddc4fb9abea3b3820ff3128cb26":["c9f9f3353941a7e1d1addbd7f9f901a292f6a4d1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"ba9a527ca6b00f668b0a55c9633742cf70a05fec":["a7cf6ebde2188bcc6d0523f1eb74e734695522dc"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"0242ba41ae04434a68e1eaafe5e711a3d7d6208a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b96ad5eead3ef9b09cee72d7b54b8bfc369859bd":["b7eea62cd13a5ddc4fb9abea3b3820ff3128cb26"],"7a4f4b06bdac8a9a670d952d17df0ce87e02a2e4":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","0d62172dd2fc1195c7e475550ac394a9948a18ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"e56881a4ebc3438313e3c008a7124ba0f8ecc7bf":["d8d1f2c78f560980e5822db6905bb3b2f52fdbe5"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"40d527f1505faaeef6026b8c5edd5ba37a3c59ca":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}