{"path":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","commits":[{"id":"1f192203c3feece147e3227c2446101d33858d81","date":1438359704,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            return NumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                mval.exists = exists(doc);\n                mval.value = mval.exists ? longVal(doc) : 0;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b4e1f3a5a48661eea57fe5a644ae5d8a8c7145ef"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4e1f3a5a48661eea57fe5a644ae5d8a8c7145ef","date":1441300930,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return NumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redudnent ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? NumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            return NumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                mval.exists = exists(doc);\n                mval.value = mval.exists ? longVal(doc) : 0;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":["1f192203c3feece147e3227c2446101d33858d81"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redudnent ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return NumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redudnent ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? NumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redundant ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redudnent ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redundant ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redudnent ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redundant ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redundant ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07d484b0e04092b9bc21e9eb8f63db45753cecde","date":1476755981,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              lastDocID = docID;\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              lastDocID = docID;\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          @Override\n          public long longVal(int doc) {\n            BytesRef bytes = view.get(doc);\n            if (0 == bytes.length) {\n              // the only way this should be possible is for non existent value\n              assert !exists(doc) : \"zero bytes for doc, but exists is true\";\n              return 0L;\n            }\n            return LegacyNumericUtils.prefixCodedToLong(bytes);\n          }\n\n          @Override\n          public boolean exists(int doc) {\n            return -1 != view.getOrd(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) {\n                // micro optimized (eliminate at least one redudnent ord check) \n                //mval.exists = exists(doc);\n                //mval.value = mval.exists ? longVal(doc) : 0;\n                //\n                BytesRef bytes = view.get(doc);\n                mval.exists = (0 == bytes.length);\n                mval.value = mval.exists ? LegacyNumericUtils.prefixCodedToLong(bytes) : 0L;\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/TrieLongField#getSingleValueSource(SortedSetSelector.Type,SchemaField).mjava","sourceNew":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(@SuppressWarnings({\"rawtypes\"})Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              lastDocID = docID;\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  protected ValueSource getSingleValueSource(SortedSetSelector.Type choice, SchemaField f) {\n    \n    return new SortedSetFieldSource(f.getName(), choice) {\n      @Override\n      public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n        SortedSetFieldSource thisAsSortedSetFieldSource = this; // needed for nested anon class ref\n        \n        SortedSetDocValues sortedSet = DocValues.getSortedSet(readerContext.reader(), field);\n        SortedDocValues view = SortedSetSelector.wrap(sortedSet, selector);\n        \n        return new LongDocValues(thisAsSortedSetFieldSource) {\n          private int lastDocID;\n\n          private boolean setDoc(int docID) throws IOException {\n            if (docID < lastDocID) {\n              throw new IllegalArgumentException(\"docs out of order: lastDocID=\" + lastDocID + \" docID=\" + docID);\n            }\n            if (docID > view.docID()) {\n              lastDocID = docID;\n              return docID == view.advance(docID);\n            } else {\n              return docID == view.docID();\n            }\n          }\n\n          @Override\n          public long longVal(int doc) throws IOException {\n            if (setDoc(doc)) {\n              BytesRef bytes = view.binaryValue();\n              assert bytes.length > 0;\n              return LegacyNumericUtils.prefixCodedToLong(bytes);\n            } else {\n              return 0L;\n            }\n          }\n\n          @Override\n          public boolean exists(int doc) throws IOException {\n            return setDoc(doc);\n          }\n\n          @Override\n          public ValueFiller getValueFiller() {\n            return new ValueFiller() {\n              private final MutableValueLong mval = new MutableValueLong();\n              \n              @Override\n              public MutableValue getValue() {\n                return mval;\n              }\n              \n              @Override\n              public void fillValue(int doc) throws IOException {\n                if (setDoc(doc)) {\n                  mval.exists = true;\n                  mval.value = LegacyNumericUtils.prefixCodedToLong(view.binaryValue());\n                } else {\n                  mval.exists = false;\n                  mval.value = 0L;\n                }\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b4e1f3a5a48661eea57fe5a644ae5d8a8c7145ef":["1f192203c3feece147e3227c2446101d33858d81"],"07d484b0e04092b9bc21e9eb8f63db45753cecde":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"1f192203c3feece147e3227c2446101d33858d81":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["d470c8182e92b264680e34081b75e70a9f2b3c89","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["07d484b0e04092b9bc21e9eb8f63db45753cecde"],"770342641f7b505eaa8dccdc666158bff2419109":["b4e1f3a5a48661eea57fe5a644ae5d8a8c7145ef"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["770342641f7b505eaa8dccdc666158bff2419109","07d484b0e04092b9bc21e9eb8f63db45753cecde"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["770342641f7b505eaa8dccdc666158bff2419109","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["770342641f7b505eaa8dccdc666158bff2419109"]},"commit2Childs":{"b4e1f3a5a48661eea57fe5a644ae5d8a8c7145ef":["770342641f7b505eaa8dccdc666158bff2419109"],"07d484b0e04092b9bc21e9eb8f63db45753cecde":["06a8891f085f71282bb3ece1b1732b68f07813a3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1f192203c3feece147e3227c2446101d33858d81":["b4e1f3a5a48661eea57fe5a644ae5d8a8c7145ef"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["07d484b0e04092b9bc21e9eb8f63db45753cecde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1f192203c3feece147e3227c2446101d33858d81"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"770342641f7b505eaa8dccdc666158bff2419109":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}