{"path":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","commits":[{"id":"acdd729ace9db5d0803eea4849ddc3c2ba196127","date":1181861605,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    try {\n      if( SolrRequest.METHOD.GET == request.getMethod() ) {\n        if( streams != null ) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n        }\n        method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n      }\n      else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n        \n        String url = _baseURL + path;\n        boolean isMultipart = ( streams != null && streams.size() > 1 );\n        \n        if( streams == null || isMultipart ) {\n          // Without streams, just post the parameters\n          PostMethod post = new PostMethod( url );\n\n          Iterator<String> iter = params.getParameterNamesIterator();\n          while( iter.hasNext() ) {\n            String p = iter.next();\n            String[] vals = params.getParams( p );\n            if( vals != null && vals.length > 0 ) {\n              for( String v : vals ) {\n                post.addParameter( p, (v==null)?null:v );\n              }\n            }\n            else {\n              post.addParameter( p, null );\n            }\n          }\n\n          post.getParams().setContentCharset(\"UTF-8\");   \n\n          if( isMultipart ) {\n            int i=0;\n              Part[] parts = new Part[streams.size()];\n              \n              for( ContentStream content : streams ) {\n                final ContentStream c = content;\n                \n                String charSet = null;\n                String transferEncoding = null;\n                parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                  @Override\n                  protected long lengthOfData() throws IOException {\n                    return c.getSize();\n                  }\n\n                  @Override\n                  protected void sendData(OutputStream out) throws IOException {\n                    IOUtils.copy( c.getReader(), out );\n                  }\n                }; \n              }\n              \n              // Set the multi-part request\n              post.setRequestEntity(\n                  new MultipartRequestEntity(\n                    parts,\n                    post.getParams() )\n              );\n              method = post;\n          }\n\n          method = post;\n        }\n        // It is has one stream, it is the post body, put the params in the URL\n        else {\n          String pstr = ClientUtils.toQueryString( params, false );\n          PostMethod post = new PostMethod( url+pstr );\n            \n          // Single stream as body\n          // Using a loop just to get the first one\n          for( ContentStream content : streams ) {\n            post.setRequestEntity( \n              new InputStreamRequestEntity(\n                content.getStream(),\n                content.getContentType()) );\n            break;\n          }\n          method = post;\n        }\n      }\n      else {\n        throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.addRequestHeader( \"User-Agent\", AGENT );\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = getHttpConnection().executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      Reader reader = new InputStreamReader( method.getResponseBodyAsStream(), charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    if( request.getCore() != null ) {\n      path = \"/@\"+request.getCore()+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    try {\n      if( SolrRequest.METHOD.GET == request.getMethod() ) {\n        if( streams != null ) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n        }\n        method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n      }\n      else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n        \n        String url = _baseURL + path;\n        boolean isMultipart = ( streams != null && streams.size() > 1 );\n        \n        if( streams == null || isMultipart ) {\n          // Without streams, just post the parameters\n          PostMethod post = new PostMethod( url );\n\n          Iterator<String> iter = params.getParameterNamesIterator();\n          while( iter.hasNext() ) {\n            String p = iter.next();\n            String[] vals = params.getParams( p );\n            if( vals != null && vals.length > 0 ) {\n              for( String v : vals ) {\n                post.addParameter( p, (v==null)?null:v );\n              }\n            }\n            else {\n              post.addParameter( p, null );\n            }\n          }\n\n          post.getParams().setContentCharset(\"UTF-8\");   \n\n          if( isMultipart ) {\n            int i=0;\n              Part[] parts = new Part[streams.size()];\n              \n              for( ContentStream content : streams ) {\n                final ContentStream c = content;\n                \n                String charSet = null;\n                String transferEncoding = null;\n                parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                  @Override\n                  protected long lengthOfData() throws IOException {\n                    return c.getSize();\n                  }\n\n                  @Override\n                  protected void sendData(OutputStream out) throws IOException {\n                    IOUtils.copy( c.getReader(), out );\n                  }\n                }; \n              }\n              \n              // Set the multi-part request\n              post.setRequestEntity(\n                  new MultipartRequestEntity(\n                    parts,\n                    post.getParams() )\n              );\n              method = post;\n          }\n\n          method = post;\n        }\n        // It is has one stream, it is the post body, put the params in the URL\n        else {\n          String pstr = ClientUtils.toQueryString( params, false );\n          PostMethod post = new PostMethod( url+pstr );\n            \n          // Single stream as body\n          // Using a loop just to get the first one\n          for( ContentStream content : streams ) {\n            post.setRequestEntity( \n              new InputStreamRequestEntity(\n                content.getStream(),\n                content.getContentType()) );\n            break;\n          }\n          method = post;\n        }\n      }\n      else {\n        throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.addRequestHeader( \"User-Agent\", AGENT );\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = getHttpConnection().executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      Reader reader = new InputStreamReader( method.getResponseBodyAsStream(), charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    try {\n      if( SolrRequest.METHOD.GET == request.getMethod() ) {\n        if( streams != null ) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n        }\n        method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n      }\n      else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n        \n        String url = _baseURL + path;\n        boolean isMultipart = ( streams != null && streams.size() > 1 );\n        \n        if( streams == null || isMultipart ) {\n          // Without streams, just post the parameters\n          PostMethod post = new PostMethod( url );\n\n          Iterator<String> iter = params.getParameterNamesIterator();\n          while( iter.hasNext() ) {\n            String p = iter.next();\n            String[] vals = params.getParams( p );\n            if( vals != null && vals.length > 0 ) {\n              for( String v : vals ) {\n                post.addParameter( p, (v==null)?null:v );\n              }\n            }\n            else {\n              post.addParameter( p, null );\n            }\n          }\n\n          post.getParams().setContentCharset(\"UTF-8\");   \n\n          if( isMultipart ) {\n            int i=0;\n              Part[] parts = new Part[streams.size()];\n              \n              for( ContentStream content : streams ) {\n                final ContentStream c = content;\n                \n                String charSet = null;\n                String transferEncoding = null;\n                parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                  @Override\n                  protected long lengthOfData() throws IOException {\n                    return c.getSize();\n                  }\n\n                  @Override\n                  protected void sendData(OutputStream out) throws IOException {\n                    IOUtils.copy( c.getReader(), out );\n                  }\n                }; \n              }\n              \n              // Set the multi-part request\n              post.setRequestEntity(\n                  new MultipartRequestEntity(\n                    parts,\n                    post.getParams() )\n              );\n              method = post;\n          }\n\n          method = post;\n        }\n        // It is has one stream, it is the post body, put the params in the URL\n        else {\n          String pstr = ClientUtils.toQueryString( params, false );\n          PostMethod post = new PostMethod( url+pstr );\n            \n          // Single stream as body\n          // Using a loop just to get the first one\n          for( ContentStream content : streams ) {\n            post.setRequestEntity( \n              new InputStreamRequestEntity(\n                content.getStream(),\n                content.getContentType()) );\n            break;\n          }\n          method = post;\n        }\n      }\n      else {\n        throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.addRequestHeader( \"User-Agent\", AGENT );\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = getHttpConnection().executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      Reader reader = new InputStreamReader( method.getResponseBodyAsStream(), charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7","date":1198275819,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    try {\n      if( SolrRequest.METHOD.GET == request.getMethod() ) {\n        if( streams != null ) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n        }\n        method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n      }\n      else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n        \n        String url = _baseURL + path;\n        boolean isMultipart = ( streams != null && streams.size() > 1 );\n        \n        if( streams == null || isMultipart ) {\n          // Without streams, just post the parameters\n          PostMethod post = new PostMethod( url );\n\n          Iterator<String> iter = params.getParameterNamesIterator();\n          while( iter.hasNext() ) {\n            String p = iter.next();\n            String[] vals = params.getParams( p );\n            if( vals != null && vals.length > 0 ) {\n              for( String v : vals ) {\n                post.addParameter( p, (v==null)?null:v );\n              }\n            }\n            else {\n              post.addParameter( p, null );\n            }\n          }\n\n          post.getParams().setContentCharset(\"UTF-8\");   \n\n          if( isMultipart ) {\n            int i=0;\n              Part[] parts = new Part[streams.size()];\n              \n              for( ContentStream content : streams ) {\n                final ContentStream c = content;\n                \n                String charSet = null;\n                String transferEncoding = null;\n                parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                  @Override\n                  protected long lengthOfData() throws IOException {\n                    return c.getSize();\n                  }\n\n                  @Override\n                  protected void sendData(OutputStream out) throws IOException {\n                    IOUtils.copy( c.getReader(), out );\n                  }\n                }; \n              }\n              \n              // Set the multi-part request\n              post.setRequestEntity(\n                  new MultipartRequestEntity(\n                    parts,\n                    post.getParams() )\n              );\n              method = post;\n          }\n\n          method = post;\n        }\n        // It is has one stream, it is the post body, put the params in the URL\n        else {\n          String pstr = ClientUtils.toQueryString( params, false );\n          PostMethod post = new PostMethod( url+pstr );\n            \n          // Single stream as body\n          // Using a loop just to get the first one\n          for( ContentStream content : streams ) {\n            post.setRequestEntity( \n              new InputStreamRequestEntity(\n                content.getStream(),\n                content.getContentType()) );\n            break;\n          }\n          method = post;\n        }\n      }\n      else {\n        throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.addRequestHeader( \"User-Agent\", AGENT );\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = getHttpConnection().executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      Reader reader = new InputStreamReader( method.getResponseBodyAsStream(), charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    if( request.getCore() != null ) {\n      path = \"/@\"+request.getCore()+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    try {\n      if( SolrRequest.METHOD.GET == request.getMethod() ) {\n        if( streams != null ) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n        }\n        method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n      }\n      else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n        \n        String url = _baseURL + path;\n        boolean isMultipart = ( streams != null && streams.size() > 1 );\n        \n        if( streams == null || isMultipart ) {\n          // Without streams, just post the parameters\n          PostMethod post = new PostMethod( url );\n\n          Iterator<String> iter = params.getParameterNamesIterator();\n          while( iter.hasNext() ) {\n            String p = iter.next();\n            String[] vals = params.getParams( p );\n            if( vals != null && vals.length > 0 ) {\n              for( String v : vals ) {\n                post.addParameter( p, (v==null)?null:v );\n              }\n            }\n            else {\n              post.addParameter( p, null );\n            }\n          }\n\n          post.getParams().setContentCharset(\"UTF-8\");   \n\n          if( isMultipart ) {\n            int i=0;\n              Part[] parts = new Part[streams.size()];\n              \n              for( ContentStream content : streams ) {\n                final ContentStream c = content;\n                \n                String charSet = null;\n                String transferEncoding = null;\n                parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                  @Override\n                  protected long lengthOfData() throws IOException {\n                    return c.getSize();\n                  }\n\n                  @Override\n                  protected void sendData(OutputStream out) throws IOException {\n                    IOUtils.copy( c.getReader(), out );\n                  }\n                }; \n              }\n              \n              // Set the multi-part request\n              post.setRequestEntity(\n                  new MultipartRequestEntity(\n                    parts,\n                    post.getParams() )\n              );\n              method = post;\n          }\n\n          method = post;\n        }\n        // It is has one stream, it is the post body, put the params in the URL\n        else {\n          String pstr = ClientUtils.toQueryString( params, false );\n          PostMethod post = new PostMethod( url+pstr );\n            \n          // Single stream as body\n          // Using a loop just to get the first one\n          for( ContentStream content : streams ) {\n            post.setRequestEntity( \n              new InputStreamRequestEntity(\n                content.getStream(),\n                content.getContentType()) );\n            break;\n          }\n          method = post;\n        }\n      }\n      else {\n        throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.addRequestHeader( \"User-Agent\", AGENT );\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = getHttpConnection().executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      Reader reader = new InputStreamReader( method.getResponseBodyAsStream(), charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b16090b22bb18cd392efeee6533e38dfc50f94e4","date":1200696418,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      Reader reader = new InputStreamReader( respBody, charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    try {\n      if( SolrRequest.METHOD.GET == request.getMethod() ) {\n        if( streams != null ) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n        }\n        method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n      }\n      else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n        \n        String url = _baseURL + path;\n        boolean isMultipart = ( streams != null && streams.size() > 1 );\n        \n        if( streams == null || isMultipart ) {\n          // Without streams, just post the parameters\n          PostMethod post = new PostMethod( url );\n\n          Iterator<String> iter = params.getParameterNamesIterator();\n          while( iter.hasNext() ) {\n            String p = iter.next();\n            String[] vals = params.getParams( p );\n            if( vals != null && vals.length > 0 ) {\n              for( String v : vals ) {\n                post.addParameter( p, (v==null)?null:v );\n              }\n            }\n            else {\n              post.addParameter( p, null );\n            }\n          }\n\n          post.getParams().setContentCharset(\"UTF-8\");   \n\n          if( isMultipart ) {\n            int i=0;\n              Part[] parts = new Part[streams.size()];\n              \n              for( ContentStream content : streams ) {\n                final ContentStream c = content;\n                \n                String charSet = null;\n                String transferEncoding = null;\n                parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                  @Override\n                  protected long lengthOfData() throws IOException {\n                    return c.getSize();\n                  }\n\n                  @Override\n                  protected void sendData(OutputStream out) throws IOException {\n                    IOUtils.copy( c.getReader(), out );\n                  }\n                }; \n              }\n              \n              // Set the multi-part request\n              post.setRequestEntity(\n                  new MultipartRequestEntity(\n                    parts,\n                    post.getParams() )\n              );\n              method = post;\n          }\n\n          method = post;\n        }\n        // It is has one stream, it is the post body, put the params in the URL\n        else {\n          String pstr = ClientUtils.toQueryString( params, false );\n          PostMethod post = new PostMethod( url+pstr );\n            \n          // Single stream as body\n          // Using a loop just to get the first one\n          for( ContentStream content : streams ) {\n            post.setRequestEntity( \n              new InputStreamRequestEntity(\n                content.getStream(),\n                content.getContentType()) );\n            break;\n          }\n          method = post;\n        }\n      }\n      else {\n        throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.addRequestHeader( \"User-Agent\", AGENT );\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = getHttpConnection().executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      Reader reader = new InputStreamReader( method.getResponseBodyAsStream(), charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f9e70cea495aaf83300e16f5027ed8cb2da59fd","date":1201238296,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return _processor.processResponse(respBody, charset);\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      Reader reader = new InputStreamReader( respBody, charset ); \n      return _processor.processResponse( reader );\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd4fd4f3ce083390e6392c44b17e7437029f0d6b","date":1201280007,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return _processor.processResponse(respBody, charset);\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return _processor.processResponse(respBody, charset);\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41bffa147dec8d55cfa362ef9aca41509819ae04","date":1201997733,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n        \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return _processor.processResponse(respBody, charset);\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    // modify the path for multicore access\n    String core = getDefaultCore();\n    if( request.getCore() != null ) {\n      core= request.getCore();\n    }\n    if( core != null && core.length() > 0 ) {\n      path = \"/\"+core+path;\n    }\n    \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return _processor.processResponse(respBody, charset);\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a12d3c6475f1b99b086e4ca6b9ba34e65081859","date":1204263291,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  /**\n   * Process the request.  If {@link org.apache.solr.client.solrj.SolrRequest#getResponseParser()} is null, then use\n   * {@link #getParser()}\n   * @param request The {@link org.apache.solr.client.solrj.SolrRequest} to process\n   * @return The {@link org.apache.solr.common.util.NamedList} result\n   * @throws SolrServerException\n   * @throws IOException\n   *\n   * @see #request(org.apache.solr.client.solrj.SolrRequest, org.apache.solr.client.solrj.ResponseParser)\n   */\n  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    ResponseParser responseParser = request.getResponseParser();\n    if (responseParser == null) {\n      responseParser = _parser;\n    }\n    return request(request, responseParser);\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    // TODO -- need to set the WRITER TYPE!!!\n    // params.set( SolrParams.WT, wt );\n   \n    HttpMethod method = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = request.getContentStreams();\n    String path = request.getPath();\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n        \n    if( params == null ) {\n      params = new ModifiableSolrParams();\n    }\n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n    \n    int tries = _maxRetries + 1;        \n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n            \n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n            \n            if( streams == null || isMultipart ) {\n              // Without streams, just post the parameters\n              PostMethod post = new PostMethod( url );\n            \n              Iterator<String> iter = params.getParameterNamesIterator();\n              while( iter.hasNext() ) {\n                String p = iter.next();\n                String[] vals = params.getParams( p );\n                if( vals != null && vals.length > 0 ) {\n                  for( String v : vals ) {\n                    post.addParameter( p, (v==null)?null:v );\n                  }\n                }\n                else {\n                  post.addParameter( p, null );\n                }\n              }\n              \n              post.getParams().setContentCharset(\"UTF-8\");   \n\n              if( isMultipart ) {\n                int i=0;\n                Part[] parts = new Part[streams.size()];\n                \n                for( ContentStream content : streams ) {\n                  final ContentStream c = content;\n                  \n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n                    \n                    @Override\n                      protected void sendData(OutputStream out) throws IOException {\n                      IOUtils.copy( c.getReader(), out );\n                    }\n                  }; \n                }\n                \n                // Set the multi-part request\n                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );\n                method = post;\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString( params, false );\n              PostMethod post = new PostMethod( url+pstr );\n              \n              // Single stream as body\n              // Using a loop just to get the first one\n              for( ContentStream content : streams ) {\n                post.setRequestEntity( \n                    new InputStreamRequestEntity( content.getStream(), content.getContentType())\n                );\n                break;\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n    \n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n    \n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n    \n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n      \n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return _processor.processResponse(respBody, charset);\n    } \n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3602d5eab954caecc726ab136ad580ac1ceb917","date":1228676831,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","pathOld":"client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest).mjava","sourceNew":"  /**\n   * Process the request.  If {@link org.apache.solr.client.solrj.SolrRequest#getResponseParser()} is null, then use\n   * {@link #getParser()}\n   * @param request The {@link org.apache.solr.client.solrj.SolrRequest} to process\n   * @return The {@link org.apache.solr.common.util.NamedList} result\n   * @throws SolrServerException\n   * @throws IOException\n   *\n   * @see #request(org.apache.solr.client.solrj.SolrRequest, org.apache.solr.client.solrj.ResponseParser)\n   */\n  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    ResponseParser responseParser = request.getResponseParser();\n    if (responseParser == null) {\n      responseParser = _parser;\n    }\n    return request(request, responseParser);\n  }\n\n","sourceOld":"  /**\n   * Process the request.  If {@link org.apache.solr.client.solrj.SolrRequest#getResponseParser()} is null, then use\n   * {@link #getParser()}\n   * @param request The {@link org.apache.solr.client.solrj.SolrRequest} to process\n   * @return The {@link org.apache.solr.common.util.NamedList} result\n   * @throws SolrServerException\n   * @throws IOException\n   *\n   * @see #request(org.apache.solr.client.solrj.SolrRequest, org.apache.solr.client.solrj.ResponseParser)\n   */\n  @Override\n  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException\n  {\n    ResponseParser responseParser = request.getResponseParser();\n    if (responseParser == null) {\n      responseParser = _parser;\n    }\n    return request(request, responseParser);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e3602d5eab954caecc726ab136ad580ac1ceb917":["0a12d3c6475f1b99b086e4ca6b9ba34e65081859"],"b16090b22bb18cd392efeee6533e38dfc50f94e4":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"0a12d3c6475f1b99b086e4ca6b9ba34e65081859":["41bffa147dec8d55cfa362ef9aca41509819ae04"],"41bffa147dec8d55cfa362ef9aca41509819ae04":["dd4fd4f3ce083390e6392c44b17e7437029f0d6b"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["acdd729ace9db5d0803eea4849ddc3c2ba196127"],"acdd729ace9db5d0803eea4849ddc3c2ba196127":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"dd4fd4f3ce083390e6392c44b17e7437029f0d6b":["4f9e70cea495aaf83300e16f5027ed8cb2da59fd"],"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4f9e70cea495aaf83300e16f5027ed8cb2da59fd":["b16090b22bb18cd392efeee6533e38dfc50f94e4"]},"commit2Childs":{"e3602d5eab954caecc726ab136ad580ac1ceb917":[],"b16090b22bb18cd392efeee6533e38dfc50f94e4":["4f9e70cea495aaf83300e16f5027ed8cb2da59fd"],"0a12d3c6475f1b99b086e4ca6b9ba34e65081859":["e3602d5eab954caecc726ab136ad580ac1ceb917"],"41bffa147dec8d55cfa362ef9aca41509819ae04":["0a12d3c6475f1b99b086e4ca6b9ba34e65081859"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"acdd729ace9db5d0803eea4849ddc3c2ba196127":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["acdd729ace9db5d0803eea4849ddc3c2ba196127"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd4fd4f3ce083390e6392c44b17e7437029f0d6b":["41bffa147dec8d55cfa362ef9aca41509819ae04"],"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7":["b16090b22bb18cd392efeee6533e38dfc50f94e4"],"4f9e70cea495aaf83300e16f5027ed8cb2da59fd":["dd4fd4f3ce083390e6392c44b17e7437029f0d6b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e3602d5eab954caecc726ab136ad580ac1ceb917","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}