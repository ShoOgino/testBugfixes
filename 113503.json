{"path":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest#narrativeMergeTestImplementation(boolean,boolean,boolean,boolean).mjava","commits":[{"id":"4b824bc8e7025a4b66748b3fec82decbbc5c3ca7","date":1571755848,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest#narrativeMergeTestImplementation(boolean,boolean,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * This method implements tests for the <code>TopGroup.merge</code> method\n   * using a narrative approach. Use of a creative narrative may seem unusual\n   * or even silly but the idea behind it is to make it hopefully easier to\n   * reason about the documents and groups and scores in the test whilst testing\n   * several scenario permutations.\n   *\n   * Imagine:\n   *\n   * Each document represents (say) a picture book of an animal.\n   * We are searching for two books and wish to draw a picture of our own, inspired by the books.\n   * We think that large animals are easier to draw and therefore order the books by the featured animal's size.\n   * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.\n   *\n   * Index content:\n   *\n   * The documents are in 2 groups (\"blue\" and \"red\") and there are 4 documents across 2 shards:\n   * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).\n   *\n   * If all documents are present the \"blue whale\" and the \"red squirrel\" documents would be returned\n   * for our drawing since they are the largest animals in their respective groups.\n   *\n   * Test permutations (haveBlueWhale, haveRedAnt, haveBlueDragonfly, haveRedSquirrel) arise because\n   * in the first pass of the search all documents can be present, but\n   * in the second pass of the search some documents could be missing\n   * if they have been deleted 'just so' between the two phases.\n   *\n   * Additionally a <code>haveAnimal == false</code> condition also represents scenarios where a given\n   * group has documents on some but not all shards in the collection.\n   */\n  private void narrativeMergeTestImplementation(\n      boolean haveBlueWhale,\n      boolean haveRedAnt,\n      boolean haveBlueDragonfly,\n      boolean haveRedSquirrel) {\n\n    final String blueGroupValue = \"blue\";\n    final String redGroupValue = \"red\";\n\n    final Integer redAntSize = 1;\n    final Integer blueDragonflySize = 10;\n    final Integer redSquirrelSize = 100;\n    final Integer blueWhaleSize = 1000;\n\n    final float redAntScore = redAntSize;\n    final float blueDragonflyScore = blueDragonflySize;\n    final float redSquirrelScore = redSquirrelSize;\n    final float blueWhaleScore = blueWhaleSize;\n\n    final Sort sort = Sort.RELEVANCE;\n\n    final TopGroups<String> shard1TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueWhale\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueWhaleSize }, 1 /* docId */, blueWhaleScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueWhaleSize });\n\n      final GroupDocs<String> group2 = haveRedAnt\n          ? createSingletonGroupDocs(redGroupValue, new Object[] { redAntSize }, 2 /* docId */, redAntScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(redGroupValue, new Object[] { redAntSize });\n\n      shard1TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveBlueWhale ? blueWhaleScore : (haveRedAnt ? redAntScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> shard2TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueDragonfly\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueDragonflySize }, 3 /* docId */, blueDragonflyScore, 1 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueDragonflySize });\n\n      final GroupDocs<String> group2 = haveRedSquirrel\n      ? createSingletonGroupDocs(redGroupValue, new Object[] { redSquirrelSize }, 4 /* docId */, redSquirrelScore, 1 /* shardIndex */)\n          : createEmptyGroupDocs(redGroupValue, new Object[] { redSquirrelSize });\n\n      shard2TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveRedSquirrel ? redSquirrelScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> mergedTopGroups = TopGroups.<String>merge(\n        combineTopGroups(shard1TopGroups, shard2TopGroups),\n        sort /* groupSort */,\n        sort /* docSort */,\n        0 /* docOffset */,\n        2 /* docTopN */,\n        TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    final int expectedCount =\n        (haveBlueWhale     ? 1 : 0) +\n        (haveRedAnt        ? 1 : 0) +\n        (haveBlueDragonfly ? 1 : 0) +\n        (haveRedSquirrel   ? 1 : 0);\n\n    assertEquals(expectedCount, mergedTopGroups.totalHitCount);\n    assertEquals(expectedCount, mergedTopGroups.totalGroupedHitCount);\n\n    assertEquals(2, mergedTopGroups.groups.length);\n    {\n      assertEquals(blueGroupValue, mergedTopGroups.groups[0].groupValue);\n      final float expectedBlueMaxScore =\n          (haveBlueWhale ? blueWhaleScore : (haveBlueDragonfly ? blueDragonflyScore : Float.MIN_VALUE));\n      checkMaxScore(expectedBlueMaxScore, mergedTopGroups.groups[0].maxScore);\n    }\n    {\n      assertEquals(redGroupValue, mergedTopGroups.groups[1].groupValue);\n      final float expectedRedMaxScore =\n          (haveRedSquirrel ? redSquirrelScore : (haveRedAnt ? redAntScore : Float.MIN_VALUE));\n      checkMaxScore(expectedRedMaxScore, mergedTopGroups.groups[1].maxScore);\n    }\n\n    final float expectedMaxScore =\n        (haveBlueWhale ? blueWhaleScore\n            : (haveRedSquirrel ? redSquirrelScore\n                : (haveBlueDragonfly ? blueDragonflyScore\n                    : (haveRedAnt ? redAntScore\n                        : Float.MIN_VALUE))));\n    checkMaxScore(expectedMaxScore, mergedTopGroups.maxScore);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2eb9dcbcff763b925aeaf51efba4dabd996ec69a","date":1575896984,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest#narrativeMergeTestImplementation(boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest#narrativeMergeTestImplementation(boolean,boolean,boolean,boolean).mjava","sourceNew":"  /*\n   * This method implements tests for the <code>TopGroup.merge</code> method\n   * using a narrative approach. Use of a creative narrative may seem unusual\n   * or even silly but the idea behind it is to make it hopefully easier to\n   * reason about the documents and groups and scores in the test whilst testing\n   * several scenario permutations.\n   *\n   * Imagine:\n   *\n   * Each document represents (say) a picture book of an animal.\n   * We are searching for two books and wish to draw a picture of our own, inspired by the books.\n   * We think that large animals are easier to draw and therefore order the books by the featured animal's size.\n   * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.\n   *\n   * Index content:\n   *\n   * The documents are in 2 groups (\"blue\" and \"red\") and there are 4 documents across 2 shards:\n   * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).\n   *\n   * If all documents are present the \"blue whale\" and the \"red squirrel\" documents would be returned\n   * for our drawing since they are the largest animals in their respective groups.\n   *\n   * Test permutations (haveBlueWhale, haveRedAnt, haveBlueDragonfly, haveRedSquirrel) arise because\n   * in the first pass of the search all documents can be present, but\n   * in the second pass of the search some documents could be missing\n   * if they have been deleted 'just so' between the two phases.\n   *\n   * Additionally a <code>haveAnimal == false</code> condition also represents scenarios where a given\n   * group has documents on some but not all shards in the collection.\n   */\n  private void narrativeMergeTestImplementation(\n      boolean haveBlueWhale,\n      boolean haveRedAnt,\n      boolean haveBlueDragonfly,\n      boolean haveRedSquirrel) {\n\n    final String blueGroupValue = \"blue\";\n    final String redGroupValue = \"red\";\n\n    final Integer redAntSize = 1;\n    final Integer blueDragonflySize = 10;\n    final Integer redSquirrelSize = 100;\n    final Integer blueWhaleSize = 1000;\n\n    final float redAntScore = redAntSize;\n    final float blueDragonflyScore = blueDragonflySize;\n    final float redSquirrelScore = redSquirrelSize;\n    final float blueWhaleScore = blueWhaleSize;\n\n    final Sort sort = Sort.RELEVANCE;\n\n    final TopGroups<String> shard1TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueWhale\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueWhaleSize }, 1 /* docId */, blueWhaleScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueWhaleSize });\n\n      final GroupDocs<String> group2 = haveRedAnt\n          ? createSingletonGroupDocs(redGroupValue, new Object[] { redAntSize }, 2 /* docId */, redAntScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(redGroupValue, new Object[] { redAntSize });\n\n      shard1TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveBlueWhale ? blueWhaleScore : (haveRedAnt ? redAntScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> shard2TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueDragonfly\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueDragonflySize }, 3 /* docId */, blueDragonflyScore, 1 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueDragonflySize });\n\n      final GroupDocs<String> group2 = haveRedSquirrel\n      ? createSingletonGroupDocs(redGroupValue, new Object[] { redSquirrelSize }, 4 /* docId */, redSquirrelScore, 1 /* shardIndex */)\n          : createEmptyGroupDocs(redGroupValue, new Object[] { redSquirrelSize });\n\n      shard2TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveRedSquirrel ? redSquirrelScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> mergedTopGroups = TopGroups.<String>merge(\n        combineTopGroups(shard1TopGroups, shard2TopGroups),\n        sort /* groupSort */,\n        sort /* docSort */,\n        0 /* docOffset */,\n        2 /* docTopN */,\n        TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    final int expectedCount =\n        (haveBlueWhale     ? 1 : 0) +\n        (haveRedAnt        ? 1 : 0) +\n        (haveBlueDragonfly ? 1 : 0) +\n        (haveRedSquirrel   ? 1 : 0);\n\n    assertEquals(expectedCount, mergedTopGroups.totalHitCount);\n    assertEquals(expectedCount, mergedTopGroups.totalGroupedHitCount);\n\n    assertEquals(2, mergedTopGroups.groups.length);\n    {\n      assertEquals(blueGroupValue, mergedTopGroups.groups[0].groupValue);\n      final float expectedBlueMaxScore =\n          (haveBlueWhale ? blueWhaleScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN));\n      checkMaxScore(expectedBlueMaxScore, mergedTopGroups.groups[0].maxScore);\n    }\n    {\n      assertEquals(redGroupValue, mergedTopGroups.groups[1].groupValue);\n      final float expectedRedMaxScore =\n          (haveRedSquirrel ? redSquirrelScore : (haveRedAnt ? redAntScore : Float.NaN));\n      checkMaxScore(expectedRedMaxScore, mergedTopGroups.groups[1].maxScore);\n    }\n\n    final float expectedMaxScore =\n        (haveBlueWhale ? blueWhaleScore\n            : (haveRedSquirrel ? redSquirrelScore\n                : (haveBlueDragonfly ? blueDragonflyScore\n                    : (haveRedAnt ? redAntScore\n                        : Float.NaN))));\n    checkMaxScore(expectedMaxScore, mergedTopGroups.maxScore);\n  }\n\n","sourceOld":"  /*\n   * This method implements tests for the <code>TopGroup.merge</code> method\n   * using a narrative approach. Use of a creative narrative may seem unusual\n   * or even silly but the idea behind it is to make it hopefully easier to\n   * reason about the documents and groups and scores in the test whilst testing\n   * several scenario permutations.\n   *\n   * Imagine:\n   *\n   * Each document represents (say) a picture book of an animal.\n   * We are searching for two books and wish to draw a picture of our own, inspired by the books.\n   * We think that large animals are easier to draw and therefore order the books by the featured animal's size.\n   * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.\n   *\n   * Index content:\n   *\n   * The documents are in 2 groups (\"blue\" and \"red\") and there are 4 documents across 2 shards:\n   * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).\n   *\n   * If all documents are present the \"blue whale\" and the \"red squirrel\" documents would be returned\n   * for our drawing since they are the largest animals in their respective groups.\n   *\n   * Test permutations (haveBlueWhale, haveRedAnt, haveBlueDragonfly, haveRedSquirrel) arise because\n   * in the first pass of the search all documents can be present, but\n   * in the second pass of the search some documents could be missing\n   * if they have been deleted 'just so' between the two phases.\n   *\n   * Additionally a <code>haveAnimal == false</code> condition also represents scenarios where a given\n   * group has documents on some but not all shards in the collection.\n   */\n  private void narrativeMergeTestImplementation(\n      boolean haveBlueWhale,\n      boolean haveRedAnt,\n      boolean haveBlueDragonfly,\n      boolean haveRedSquirrel) {\n\n    final String blueGroupValue = \"blue\";\n    final String redGroupValue = \"red\";\n\n    final Integer redAntSize = 1;\n    final Integer blueDragonflySize = 10;\n    final Integer redSquirrelSize = 100;\n    final Integer blueWhaleSize = 1000;\n\n    final float redAntScore = redAntSize;\n    final float blueDragonflyScore = blueDragonflySize;\n    final float redSquirrelScore = redSquirrelSize;\n    final float blueWhaleScore = blueWhaleSize;\n\n    final Sort sort = Sort.RELEVANCE;\n\n    final TopGroups<String> shard1TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueWhale\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueWhaleSize }, 1 /* docId */, blueWhaleScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueWhaleSize });\n\n      final GroupDocs<String> group2 = haveRedAnt\n          ? createSingletonGroupDocs(redGroupValue, new Object[] { redAntSize }, 2 /* docId */, redAntScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(redGroupValue, new Object[] { redAntSize });\n\n      shard1TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveBlueWhale ? blueWhaleScore : (haveRedAnt ? redAntScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> shard2TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueDragonfly\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueDragonflySize }, 3 /* docId */, blueDragonflyScore, 1 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueDragonflySize });\n\n      final GroupDocs<String> group2 = haveRedSquirrel\n      ? createSingletonGroupDocs(redGroupValue, new Object[] { redSquirrelSize }, 4 /* docId */, redSquirrelScore, 1 /* shardIndex */)\n          : createEmptyGroupDocs(redGroupValue, new Object[] { redSquirrelSize });\n\n      shard2TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveRedSquirrel ? redSquirrelScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> mergedTopGroups = TopGroups.<String>merge(\n        combineTopGroups(shard1TopGroups, shard2TopGroups),\n        sort /* groupSort */,\n        sort /* docSort */,\n        0 /* docOffset */,\n        2 /* docTopN */,\n        TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    final int expectedCount =\n        (haveBlueWhale     ? 1 : 0) +\n        (haveRedAnt        ? 1 : 0) +\n        (haveBlueDragonfly ? 1 : 0) +\n        (haveRedSquirrel   ? 1 : 0);\n\n    assertEquals(expectedCount, mergedTopGroups.totalHitCount);\n    assertEquals(expectedCount, mergedTopGroups.totalGroupedHitCount);\n\n    assertEquals(2, mergedTopGroups.groups.length);\n    {\n      assertEquals(blueGroupValue, mergedTopGroups.groups[0].groupValue);\n      final float expectedBlueMaxScore =\n          (haveBlueWhale ? blueWhaleScore : (haveBlueDragonfly ? blueDragonflyScore : Float.MIN_VALUE));\n      checkMaxScore(expectedBlueMaxScore, mergedTopGroups.groups[0].maxScore);\n    }\n    {\n      assertEquals(redGroupValue, mergedTopGroups.groups[1].groupValue);\n      final float expectedRedMaxScore =\n          (haveRedSquirrel ? redSquirrelScore : (haveRedAnt ? redAntScore : Float.MIN_VALUE));\n      checkMaxScore(expectedRedMaxScore, mergedTopGroups.groups[1].maxScore);\n    }\n\n    final float expectedMaxScore =\n        (haveBlueWhale ? blueWhaleScore\n            : (haveRedSquirrel ? redSquirrelScore\n                : (haveBlueDragonfly ? blueDragonflyScore\n                    : (haveRedAnt ? redAntScore\n                        : Float.MIN_VALUE))));\n    checkMaxScore(expectedMaxScore, mergedTopGroups.maxScore);\n  }\n\n","bugFix":["4b824bc8e7025a4b66748b3fec82decbbc5c3ca7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","date":1575906501,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest#narrativeMergeTestImplementation(boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest#narrativeMergeTestImplementation(boolean,boolean,boolean,boolean).mjava","sourceNew":"  /*\n   * This method implements tests for the <code>TopGroup.merge</code> method\n   * using a narrative approach. Use of a creative narrative may seem unusual\n   * or even silly but the idea behind it is to make it hopefully easier to\n   * reason about the documents and groups and scores in the test whilst testing\n   * several scenario permutations.\n   *\n   * Imagine:\n   *\n   * Each document represents (say) a picture book of an animal.\n   * We are searching for two books and wish to draw a picture of our own, inspired by the books.\n   * We think that large animals are easier to draw and therefore order the books by the featured animal's size.\n   * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.\n   *\n   * Index content:\n   *\n   * The documents are in 2 groups (\"blue\" and \"red\") and there are 4 documents across 2 shards:\n   * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).\n   *\n   * If all documents are present the \"blue whale\" and the \"red squirrel\" documents would be returned\n   * for our drawing since they are the largest animals in their respective groups.\n   *\n   * Test permutations (haveBlueWhale, haveRedAnt, haveBlueDragonfly, haveRedSquirrel) arise because\n   * in the first pass of the search all documents can be present, but\n   * in the second pass of the search some documents could be missing\n   * if they have been deleted 'just so' between the two phases.\n   *\n   * Additionally a <code>haveAnimal == false</code> condition also represents scenarios where a given\n   * group has documents on some but not all shards in the collection.\n   */\n  private void narrativeMergeTestImplementation(\n      boolean haveBlueWhale,\n      boolean haveRedAnt,\n      boolean haveBlueDragonfly,\n      boolean haveRedSquirrel) {\n\n    final String blueGroupValue = \"blue\";\n    final String redGroupValue = \"red\";\n\n    final Integer redAntSize = 1;\n    final Integer blueDragonflySize = 10;\n    final Integer redSquirrelSize = 100;\n    final Integer blueWhaleSize = 1000;\n\n    final float redAntScore = redAntSize;\n    final float blueDragonflyScore = blueDragonflySize;\n    final float redSquirrelScore = redSquirrelSize;\n    final float blueWhaleScore = blueWhaleSize;\n\n    final Sort sort = Sort.RELEVANCE;\n\n    final TopGroups<String> shard1TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueWhale\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueWhaleSize }, 1 /* docId */, blueWhaleScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueWhaleSize });\n\n      final GroupDocs<String> group2 = haveRedAnt\n          ? createSingletonGroupDocs(redGroupValue, new Object[] { redAntSize }, 2 /* docId */, redAntScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(redGroupValue, new Object[] { redAntSize });\n\n      shard1TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveBlueWhale ? blueWhaleScore : (haveRedAnt ? redAntScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> shard2TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueDragonfly\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueDragonflySize }, 3 /* docId */, blueDragonflyScore, 1 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueDragonflySize });\n\n      final GroupDocs<String> group2 = haveRedSquirrel\n      ? createSingletonGroupDocs(redGroupValue, new Object[] { redSquirrelSize }, 4 /* docId */, redSquirrelScore, 1 /* shardIndex */)\n          : createEmptyGroupDocs(redGroupValue, new Object[] { redSquirrelSize });\n\n      shard2TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveRedSquirrel ? redSquirrelScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> mergedTopGroups = TopGroups.<String>merge(\n        combineTopGroups(shard1TopGroups, shard2TopGroups),\n        sort /* groupSort */,\n        sort /* docSort */,\n        0 /* docOffset */,\n        2 /* docTopN */,\n        TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    final int expectedCount =\n        (haveBlueWhale     ? 1 : 0) +\n        (haveRedAnt        ? 1 : 0) +\n        (haveBlueDragonfly ? 1 : 0) +\n        (haveRedSquirrel   ? 1 : 0);\n\n    assertEquals(expectedCount, mergedTopGroups.totalHitCount);\n    assertEquals(expectedCount, mergedTopGroups.totalGroupedHitCount);\n\n    assertEquals(2, mergedTopGroups.groups.length);\n    {\n      assertEquals(blueGroupValue, mergedTopGroups.groups[0].groupValue);\n      final float expectedBlueMaxScore =\n          (haveBlueWhale ? blueWhaleScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN));\n      checkMaxScore(expectedBlueMaxScore, mergedTopGroups.groups[0].maxScore);\n    }\n    {\n      assertEquals(redGroupValue, mergedTopGroups.groups[1].groupValue);\n      final float expectedRedMaxScore =\n          (haveRedSquirrel ? redSquirrelScore : (haveRedAnt ? redAntScore : Float.NaN));\n      checkMaxScore(expectedRedMaxScore, mergedTopGroups.groups[1].maxScore);\n    }\n\n    final float expectedMaxScore =\n        (haveBlueWhale ? blueWhaleScore\n            : (haveRedSquirrel ? redSquirrelScore\n                : (haveBlueDragonfly ? blueDragonflyScore\n                    : (haveRedAnt ? redAntScore\n                        : Float.NaN))));\n    checkMaxScore(expectedMaxScore, mergedTopGroups.maxScore);\n  }\n\n","sourceOld":"  /*\n   * This method implements tests for the <code>TopGroup.merge</code> method\n   * using a narrative approach. Use of a creative narrative may seem unusual\n   * or even silly but the idea behind it is to make it hopefully easier to\n   * reason about the documents and groups and scores in the test whilst testing\n   * several scenario permutations.\n   *\n   * Imagine:\n   *\n   * Each document represents (say) a picture book of an animal.\n   * We are searching for two books and wish to draw a picture of our own, inspired by the books.\n   * We think that large animals are easier to draw and therefore order the books by the featured animal's size.\n   * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.\n   *\n   * Index content:\n   *\n   * The documents are in 2 groups (\"blue\" and \"red\") and there are 4 documents across 2 shards:\n   * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).\n   *\n   * If all documents are present the \"blue whale\" and the \"red squirrel\" documents would be returned\n   * for our drawing since they are the largest animals in their respective groups.\n   *\n   * Test permutations (haveBlueWhale, haveRedAnt, haveBlueDragonfly, haveRedSquirrel) arise because\n   * in the first pass of the search all documents can be present, but\n   * in the second pass of the search some documents could be missing\n   * if they have been deleted 'just so' between the two phases.\n   *\n   * Additionally a <code>haveAnimal == false</code> condition also represents scenarios where a given\n   * group has documents on some but not all shards in the collection.\n   */\n  private void narrativeMergeTestImplementation(\n      boolean haveBlueWhale,\n      boolean haveRedAnt,\n      boolean haveBlueDragonfly,\n      boolean haveRedSquirrel) {\n\n    final String blueGroupValue = \"blue\";\n    final String redGroupValue = \"red\";\n\n    final Integer redAntSize = 1;\n    final Integer blueDragonflySize = 10;\n    final Integer redSquirrelSize = 100;\n    final Integer blueWhaleSize = 1000;\n\n    final float redAntScore = redAntSize;\n    final float blueDragonflyScore = blueDragonflySize;\n    final float redSquirrelScore = redSquirrelSize;\n    final float blueWhaleScore = blueWhaleSize;\n\n    final Sort sort = Sort.RELEVANCE;\n\n    final TopGroups<String> shard1TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueWhale\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueWhaleSize }, 1 /* docId */, blueWhaleScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueWhaleSize });\n\n      final GroupDocs<String> group2 = haveRedAnt\n          ? createSingletonGroupDocs(redGroupValue, new Object[] { redAntSize }, 2 /* docId */, redAntScore, 0 /* shardIndex */)\n              : createEmptyGroupDocs(redGroupValue, new Object[] { redAntSize });\n\n      shard1TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveBlueWhale ? blueWhaleScore : (haveRedAnt ? redAntScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> shard2TopGroups;\n    {\n      final GroupDocs<String> group1 = haveBlueDragonfly\n          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueDragonflySize }, 3 /* docId */, blueDragonflyScore, 1 /* shardIndex */)\n              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueDragonflySize });\n\n      final GroupDocs<String> group2 = haveRedSquirrel\n      ? createSingletonGroupDocs(redGroupValue, new Object[] { redSquirrelSize }, 4 /* docId */, redSquirrelScore, 1 /* shardIndex */)\n          : createEmptyGroupDocs(redGroupValue, new Object[] { redSquirrelSize });\n\n      shard2TopGroups = new TopGroups<String>(\n          sort.getSort() /* groupSort */,\n          sort.getSort() /* withinGroupSort */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,\n          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,\n          combineGroupDocs(group1, group2) /* groups */,\n          (haveRedSquirrel ? redSquirrelScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN)) /* maxScore */);\n    }\n\n    final TopGroups<String> mergedTopGroups = TopGroups.<String>merge(\n        combineTopGroups(shard1TopGroups, shard2TopGroups),\n        sort /* groupSort */,\n        sort /* docSort */,\n        0 /* docOffset */,\n        2 /* docTopN */,\n        TopGroups.ScoreMergeMode.None);\n    assertNotNull(mergedTopGroups);\n\n    final int expectedCount =\n        (haveBlueWhale     ? 1 : 0) +\n        (haveRedAnt        ? 1 : 0) +\n        (haveBlueDragonfly ? 1 : 0) +\n        (haveRedSquirrel   ? 1 : 0);\n\n    assertEquals(expectedCount, mergedTopGroups.totalHitCount);\n    assertEquals(expectedCount, mergedTopGroups.totalGroupedHitCount);\n\n    assertEquals(2, mergedTopGroups.groups.length);\n    {\n      assertEquals(blueGroupValue, mergedTopGroups.groups[0].groupValue);\n      final float expectedBlueMaxScore =\n          (haveBlueWhale ? blueWhaleScore : (haveBlueDragonfly ? blueDragonflyScore : Float.MIN_VALUE));\n      checkMaxScore(expectedBlueMaxScore, mergedTopGroups.groups[0].maxScore);\n    }\n    {\n      assertEquals(redGroupValue, mergedTopGroups.groups[1].groupValue);\n      final float expectedRedMaxScore =\n          (haveRedSquirrel ? redSquirrelScore : (haveRedAnt ? redAntScore : Float.MIN_VALUE));\n      checkMaxScore(expectedRedMaxScore, mergedTopGroups.groups[1].maxScore);\n    }\n\n    final float expectedMaxScore =\n        (haveBlueWhale ? blueWhaleScore\n            : (haveRedSquirrel ? redSquirrelScore\n                : (haveBlueDragonfly ? blueDragonflyScore\n                    : (haveRedAnt ? redAntScore\n                        : Float.MIN_VALUE))));\n    checkMaxScore(expectedMaxScore, mergedTopGroups.maxScore);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df3f594d6024cc3f64b0d0932c5efc80dfbe64bb":["4b824bc8e7025a4b66748b3fec82decbbc5c3ca7","2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b824bc8e7025a4b66748b3fec82decbbc5c3ca7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2eb9dcbcff763b925aeaf51efba4dabd996ec69a":["4b824bc8e7025a4b66748b3fec82decbbc5c3ca7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2eb9dcbcff763b925aeaf51efba4dabd996ec69a"]},"commit2Childs":{"df3f594d6024cc3f64b0d0932c5efc80dfbe64bb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4b824bc8e7025a4b66748b3fec82decbbc5c3ca7"],"4b824bc8e7025a4b66748b3fec82decbbc5c3ca7":["df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"2eb9dcbcff763b925aeaf51efba4dabd996ec69a":["df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}