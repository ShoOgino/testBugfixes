{"path":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = new SegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir,IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(si.name, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1efe3edca215dd9891cb42af283fed96f792ca0","date":1320428891,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = new SegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = new SegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir,IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(si.name, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = new SegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = new SegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = new SegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"319624eb66a10b717d3e66af448543e7dc5c479d","date":1322741556,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    if (format <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n      infos.setGlobalFieldMapVersion(input.readLong());\n    }\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfd7f00f3dbc4c50d336540f063493fc0f7d830f","date":1322850565,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene40/Lucene40SegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene40StoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  // TODO: shove all backwards code to preflex!\n  // this is a little tricky, because of IR.commit(), two options:\n  // 1. PreFlex writes 4.x SIS format, but reads both 3.x and 4.x\n  //    (and maybe RW always only writes the 3.x one? for that to work well,\n  //     we have to move .fnx file to codec too, not too bad but more work).\n  //     or we just have crappier RW testing like today.\n  // 2. PreFlex writes 3.x SIS format, and only reads 3.x\n  //    (in this case we have to move .fnx file to codec as well)\n  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          DefaultStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cfd7f00f3dbc4c50d336540f063493fc0f7d830f":["319624eb66a10b717d3e66af448543e7dc5c479d"],"06584e6e98d592b34e1329b384182f368d2025e8":["f1efe3edca215dd9891cb42af283fed96f792ca0"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["7b91922b55d15444d554721b352861d028eb8278"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["06584e6e98d592b34e1329b384182f368d2025e8"],"319624eb66a10b717d3e66af448543e7dc5c479d":["3cc749c053615f5871f3b95715fe292f34e70a53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cfd7f00f3dbc4c50d336540f063493fc0f7d830f"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["f1efe3edca215dd9891cb42af283fed96f792ca0"],"cfd7f00f3dbc4c50d336540f063493fc0f7d830f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"06584e6e98d592b34e1329b384182f368d2025e8":["3cc749c053615f5871f3b95715fe292f34e70a53"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["06584e6e98d592b34e1329b384182f368d2025e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"3cc749c053615f5871f3b95715fe292f34e70a53":["319624eb66a10b717d3e66af448543e7dc5c479d"],"319624eb66a10b717d3e66af448543e7dc5c479d":["cfd7f00f3dbc4c50d336540f063493fc0f7d830f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}