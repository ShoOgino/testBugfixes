{"path":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","commits":[{"id":"9d22d0f5940f155267b250876fa797ff69e8e6e7","date":1400540695,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + cs);\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + cs);\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11","6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3caf472b0a0fa2bad9079962e59f83162aeec919","date":1400698619,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + cs);\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + cs);\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0a25fce2053175e7165acaaedd21ae5b63530ef","date":1400776425,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9043cd220362869f58e50f635c13c362f8377da","date":1404227796,"type":5,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n      \n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"9d22d0f5940f155267b250876fa797ff69e8e6e7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0a25fce2053175e7165acaaedd21ae5b63530ef":["3caf472b0a0fa2bad9079962e59f83162aeec919"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3caf472b0a0fa2bad9079962e59f83162aeec919"],"f9043cd220362869f58e50f635c13c362f8377da":["c0a25fce2053175e7165acaaedd21ae5b63530ef"],"3caf472b0a0fa2bad9079962e59f83162aeec919":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f9043cd220362869f58e50f635c13c362f8377da"]},"commit2Childs":{"9d22d0f5940f155267b250876fa797ff69e8e6e7":["3caf472b0a0fa2bad9079962e59f83162aeec919"],"c0a25fce2053175e7165acaaedd21ae5b63530ef":["f9043cd220362869f58e50f635c13c362f8377da"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d22d0f5940f155267b250876fa797ff69e8e6e7","b7605579001505896d48b07160075a5c8b8e128e"],"b7605579001505896d48b07160075a5c8b8e128e":[],"3caf472b0a0fa2bad9079962e59f83162aeec919":["c0a25fce2053175e7165acaaedd21ae5b63530ef","b7605579001505896d48b07160075a5c8b8e128e"],"f9043cd220362869f58e50f635c13c362f8377da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}