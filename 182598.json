{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","commits":[{"id":"6e2410e27320f6aaba450cbf500d7822baf642f8","date":1347075066,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree#getMaxLevelForPrecision(Shape,double).mjava","sourceNew":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its furthest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //The diagonal distance should be the same computed from any opposite corner,\n    // and this is the longest distance that might be occurring within the shape.\n    double diagonalDist = ctx.getDistCalc().distance(\n        ctx.makePoint(bbox.getMinX(), bbox.getMinY()), bbox.getMaxX(), bbox.getMaxY());\n    return diagonalDist * 0.5 * distErrPct;\n  }\n\n","sourceOld":"  /**\n   * See {@link org.apache.lucene.spatial.query.SpatialArgs#getDistPrecision()}.\n   * A grid level looked up via {@link #getLevelForDistance(double)} is returned.\n   *\n   * @param precision 0 to 0.5\n   * @return 1 to maxLevels\n   */\n  public int getMaxLevelForPrecision(Shape shape, double precision) {\n    if (precision < 0 || precision > 0.5) {\n      throw new IllegalArgumentException(\"Precision \" + precision + \" must be between [0 to 0.5]\");\n    }\n    if (precision == 0 || shape instanceof Point) {\n      return maxLevels;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //The diagonal distance should be the same computed from any opposite corner,\n    // and this is the longest distance that might be occurring within the shape.\n    double diagonalDist = ctx.getDistCalc().distance(\n        ctx.makePoint(bbox.getMinX(), bbox.getMinY()), bbox.getMaxX(), bbox.getMaxY());\n    return getLevelForDistance(diagonalDist * 0.5 * precision);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c90482bb4315545b796a647ca4b9bbb2c9c31f3","date":1358889844,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","sourceNew":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its closest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //Compute the distance from the center to a corner.  Because the distance\n    // to a bottom corner vs a top corner can vary in a geospatial scenario,\n    // take the closest one (greater precision).\n    Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }\n\n","sourceOld":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its furthest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //The diagonal distance should be the same computed from any opposite corner,\n    // and this is the longest distance that might be occurring within the shape.\n    double diagonalDist = ctx.getDistCalc().distance(\n        ctx.makePoint(bbox.getMinX(), bbox.getMinY()), bbox.getMaxX(), bbox.getMaxY());\n    return diagonalDist * 0.5 * distErrPct;\n  }\n\n","bugFix":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","sourceNew":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its closest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //Compute the distance from the center to a corner.  Because the distance\n    // to a bottom corner vs a top corner can vary in a geospatial scenario,\n    // take the closest one (greater precision).\n    Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }\n\n","sourceOld":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its furthest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //The diagonal distance should be the same computed from any opposite corner,\n    // and this is the longest distance that might be occurring within the shape.\n    double diagonalDist = ctx.getDistCalc().distance(\n        ctx.makePoint(bbox.getMinX(), bbox.getMinY()), bbox.getMaxX(), bbox.getMaxY());\n    return diagonalDist * 0.5 * distErrPct;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","sourceNew":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its closest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //Compute the distance from the center to a corner.  Because the distance\n    // to a bottom corner vs a top corner can vary in a geospatial scenario,\n    // take the closest one (greater precision).\n    Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }\n\n","sourceOld":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its closest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //Compute the distance from the center to a corner.  Because the distance\n    // to a bottom corner vs a top corner can vary in a geospatial scenario,\n    // take the closest one (greater precision).\n    Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialArgs#calcDistanceFromErrPct(Shape,double,SpatialContext).mjava","sourceNew":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its closest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //Compute the distance from the center to a corner.  Because the distance\n    // to a bottom corner vs a top corner can vary in a geospatial scenario,\n    // take the closest one (greater precision).\n    Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }\n\n","sourceOld":"  /**\n   * Computes the distance given a shape and the {@code distErrPct}.  The\n   * algorithm is the fraction of the distance from the center of the query\n   * shape to its closest bounding box corner.\n   *\n   * @param shape Mandatory.\n   * @param distErrPct 0 to 0.5\n   * @param ctx Mandatory\n   * @return A distance (in degrees).\n   */\n  public static double calcDistanceFromErrPct(Shape shape, double distErrPct, SpatialContext ctx) {\n    if (distErrPct < 0 || distErrPct > 0.5) {\n      throw new IllegalArgumentException(\"distErrPct \" + distErrPct + \" must be between [0 to 0.5]\");\n    }\n    if (distErrPct == 0 || shape instanceof Point) {\n      return 0;\n    }\n    Rectangle bbox = shape.getBoundingBox();\n    //Compute the distance from the center to a corner.  Because the distance\n    // to a bottom corner vs a top corner can vary in a geospatial scenario,\n    // take the closest one (greater precision).\n    Point ctr = bbox.getCenter();\n    double y = (ctr.getY() >= 0 ? bbox.getMaxY() : bbox.getMinY());\n    double diagonalDist = ctx.getDistCalc().distance(ctr, bbox.getMaxX(), y);\n    return diagonalDist * distErrPct;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6e2410e27320f6aaba450cbf500d7822baf642f8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"af2638813028b254a88b418ebeafb541afb49653":["7c90482bb4315545b796a647ca4b9bbb2c9c31f3","112d77ac8d3e10a362516ad834c9a11d35c94234"],"7c90482bb4315545b796a647ca4b9bbb2c9c31f3":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["7c90482bb4315545b796a647ca4b9bbb2c9c31f3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["6e2410e27320f6aaba450cbf500d7822baf642f8","7c90482bb4315545b796a647ca4b9bbb2c9c31f3"]},"commit2Childs":{"6e2410e27320f6aaba450cbf500d7822baf642f8":["7c90482bb4315545b796a647ca4b9bbb2c9c31f3","b2d5244a676b83c2d551c3746e8181588ba619e1"],"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c90482bb4315545b796a647ca4b9bbb2c9c31f3":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234","b2d5244a676b83c2d551c3746e8181588ba619e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b2d5244a676b83c2d551c3746e8181588ba619e1":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b2d5244a676b83c2d551c3746e8181588ba619e1"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}