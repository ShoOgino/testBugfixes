{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76","date":1406617066,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.renameFile(taxoPendingFile, taxoSegmentsFile);\n      }\n      \n      indexDir.renameFile(indexPendingFile, indexSegmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy and fsync segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoSegmentsFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexSegmentsFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoSegmentsFile));\n      }\n      indexDir.sync(Collections.singletonList(indexSegmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    IndexReplicationHandler.writeSegmentsGen(taxoSegmentsFile, taxoDir);\n    IndexReplicationHandler.writeSegmentsGen(indexSegmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52d4cfb22484037a9b8e9080e03aeaff60954880","date":1420125313,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.copyFrom(taxoClientDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexDir.copyFrom(indexClientDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.renameFile(taxoPendingFile, taxoSegmentsFile);\n      }\n      \n      indexDir.renameFile(indexPendingFile, indexSegmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoClientDir.copy(taxoDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexClientDir.copy(indexDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.renameFile(taxoPendingFile, taxoSegmentsFile);\n      }\n      \n      indexDir.renameFile(indexPendingFile, indexSegmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"214256b5eeeaba88b8293b37d30460b462b19562","date":1468250146,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.copyFrom(taxoClientDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexDir.copyFrom(indexClientDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.rename(taxoPendingFile, taxoSegmentsFile);\n        taxoDir.syncMetaData();\n      }\n      \n      indexDir.rename(indexPendingFile, indexSegmentsFile);\n      indexDir.syncMetaData();\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.copyFrom(taxoClientDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexDir.copyFrom(indexClientDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.renameFile(taxoPendingFile, taxoSegmentsFile);\n      }\n      \n      indexDir.renameFile(indexPendingFile, indexSegmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexAndTaxonomyReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.copyFrom(taxoClientDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexDir.copyFrom(indexClientDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.rename(taxoPendingFile, taxoSegmentsFile);\n        taxoDir.syncMetaData();\n      }\n      \n      indexDir.rename(indexPendingFile, indexSegmentsFile);\n      indexDir.syncMetaData();\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    Directory taxoClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    Directory indexClientDir = sourceDirectory.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    List<String> taxoFiles = copiedFiles.get(IndexAndTaxonomyRevision.TAXONOMY_SOURCE);\n    List<String> indexFiles = copiedFiles.get(IndexAndTaxonomyRevision.INDEX_SOURCE);\n    String taxoSegmentsFile = IndexReplicationHandler.getSegmentsFile(taxoFiles, true);\n    String indexSegmentsFile = IndexReplicationHandler.getSegmentsFile(indexFiles, false);\n    String taxoPendingFile = taxoSegmentsFile == null ? null : \"pending_\" + taxoSegmentsFile;\n    String indexPendingFile = \"pending_\" + indexSegmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy taxonomy files before index files\n      IndexReplicationHandler.copyFiles(taxoClientDir, taxoDir, taxoFiles);\n      IndexReplicationHandler.copyFiles(indexClientDir, indexDir, indexFiles);\n\n      // fsync all copied files (except segmentsFile)\n      if (!taxoFiles.isEmpty()) {\n        taxoDir.sync(taxoFiles);\n      }\n      indexDir.sync(indexFiles);\n      \n      // now copy, fsync, and rename segmentsFile, taxonomy first because it is ok if a\n      // reader sees a more advanced taxonomy than the index.\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.copyFrom(taxoClientDir, taxoSegmentsFile, taxoPendingFile, IOContext.READONCE);\n      }\n      indexDir.copyFrom(indexClientDir, indexSegmentsFile, indexPendingFile, IOContext.READONCE);\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.sync(Collections.singletonList(taxoPendingFile));\n      }\n      indexDir.sync(Collections.singletonList(indexPendingFile));\n      \n      if (taxoSegmentsFile != null) {\n        taxoDir.renameFile(taxoPendingFile, taxoSegmentsFile);\n      }\n      \n      indexDir.renameFile(indexPendingFile, indexSegmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        if (taxoSegmentsFile != null) {\n          taxoFiles.add(taxoSegmentsFile); // add it back so it gets deleted too\n          taxoFiles.add(taxoPendingFile);\n        }\n        IndexReplicationHandler.cleanupFilesOnFailure(taxoDir, taxoFiles);\n        indexFiles.add(indexSegmentsFile); // add it back so it gets deleted too\n        indexFiles.add(indexPendingFile);\n        IndexReplicationHandler.cleanupFilesOnFailure(indexDir, indexFiles);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    IndexReplicationHandler.cleanupOldIndexFiles(indexDir, indexSegmentsFile, infoStream);\n    IndexReplicationHandler.cleanupOldIndexFiles(taxoDir, taxoSegmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"214256b5eeeaba88b8293b37d30460b462b19562":["52d4cfb22484037a9b8e9080e03aeaff60954880"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"52d4cfb22484037a9b8e9080e03aeaff60954880":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["52d4cfb22484037a9b8e9080e03aeaff60954880","214256b5eeeaba88b8293b37d30460b462b19562"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["214256b5eeeaba88b8293b37d30460b462b19562"]},"commit2Childs":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["52d4cfb22484037a9b8e9080e03aeaff60954880"],"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"214256b5eeeaba88b8293b37d30460b462b19562":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"52d4cfb22484037a9b8e9080e03aeaff60954880":["214256b5eeeaba88b8293b37d30460b462b19562","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}