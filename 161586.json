{"path":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","commits":[{"id":"c69d87d34a81230de56333f52f590caeb6d80667","date":1257848306,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = (String) i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT).setOpenMode(OpenMode.CREATE).setAnalyzer(ana));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT).setOpenMode(OpenMode.CREATE).setAnalyzer(ana));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c69d87d34a81230de56333f52f590caeb6d80667":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1cedb00d2dd44640194401179358a2e3ba6051bf":["c69d87d34a81230de56333f52f590caeb6d80667"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"]},"commit2Childs":{"c69d87d34a81230de56333f52f590caeb6d80667":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c69d87d34a81230de56333f52f590caeb6d80667"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}