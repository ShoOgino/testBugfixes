{"path":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","commits":[{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    NODE_CLIENTS = new ArrayList<SolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(new HttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(new HttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    NODE_CLIENTS = new ArrayList<SolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(new HttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(new HttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(new HttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .setProperties(collectionProperties)\n        .process(CLOUD_CLIENT);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .setProperties(collectionProperties)\n        .process(CLOUD_CLIENT);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorRandomCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .setProperties(collectionProperties)\n        .process(CLOUD_CLIENT);\n\n    cluster.waitForActiveCollection(COLLECTION_NAME, numShards, numShards * repFactor);\n    \n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n    \n    final String configName = \"solrCloudCollectionConfig\";\n    final File configDir = new File(TEST_HOME() + File.separator + \"collection1\" + File.separator + \"conf\");\n\n    final int numShards = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    final int repFactor = TestUtil.nextInt(random(), 2, TEST_NIGHTLY ? 5 : 3);\n    // at least one server won't have any replicas\n    final int numServers = 1 + (numShards * repFactor);\n\n    log.info(\"Configuring cluster: servers={}, shards={}, repfactor={}\", numServers, numShards, repFactor);\n    configureCluster(numServers)\n      .addConfig(configName, configDir.toPath())\n      .configure();\n\n    TestTolerantUpdateProcessorCloud.assertSpinLoopAllJettyAreRunning(cluster);\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-distrib-update-processor-chains.xml\");\n    collectionProperties.put(\"schema\", \"schema15.xml\"); // string id \n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .setProperties(collectionProperties)\n        .process(CLOUD_CLIENT);\n\n    if (NODE_CLIENTS != null) {\n      for (HttpSolrClient client : NODE_CLIENTS) {\n        client.close();\n      }\n    }\n    NODE_CLIENTS = new ArrayList<HttpSolrClient>(numServers);\n    \n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      URL jettyURL = jetty.getBaseUrl();\n      NODE_CLIENTS.add(getHttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n    assertEquals(numServers, NODE_CLIENTS.size());\n    \n    ZkStateReader zkStateReader = CLOUD_CLIENT.getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION_NAME, zkStateReader, true, true, 330);\n    \n  }\n\n","bugFix":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"859081acf00749f5dd462772c571d611d4a4d2db":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["859081acf00749f5dd462772c571d611d4a4d2db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["859081acf00749f5dd462772c571d611d4a4d2db","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"859081acf00749f5dd462772c571d611d4a4d2db":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["859081acf00749f5dd462772c571d611d4a4d2db"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}