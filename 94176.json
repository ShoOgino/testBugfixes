{"path":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","commits":[{"id":"89f15687f60bd49cd3d9de427e85c17fd9397d61","date":1309381327,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","pathOld":"/dev/null","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = indexReader.reopen();\n    if (indexReader != r2) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["233afcf63b8d53faa9a7993e911cc9873b0106d1","78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","pathOld":"/dev/null","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = indexReader.reopen();\n    if (indexReader != r2) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","pathOld":"/dev/null","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = indexReader.reopen();\n    if (indexReader != r2) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a8259c922a83abc544609227a60d48e5ee93e7e","date":1317679620,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = indexReader.reopen();\n    if (indexReader != r2) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["233afcf63b8d53faa9a7993e911cc9873b0106d1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7fea68ff83c1db2f720597dfcea5bee943a35f35","date":1317817445,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    ensureOpen();\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24315bf90acffc79fa6d5fb325f6c1cf9fc9642b","date":1317820981,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    ensureOpen();\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = ordinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    ensureOpen();\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = getOrdinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["78e3613d9274c0d98ca67d976e415c82e9f9cf46"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea469eab8fd0f3032f4fcde1c644a721e8309d3b","date":1320301582,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#refresh().mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyReader#refresh().mjava","sourceNew":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    ensureOpen();\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = ordinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Note that refresh() is synchronized (it is the only synchronized\n  // method in this class) to ensure that it never gets called concurrently\n  // with itself.\n  public synchronized void refresh() throws IOException {\n    ensureOpen();\n    /*\n     * Since refresh() can be a lengthy operation, it is very important that we\n     * avoid locking out all readers for its duration. This is why we don't hold\n     * the indexReaderLock write lock for the entire duration of this method. In\n     * fact, it is enough to hold it only during a single assignment! Other\n     * comments in this method will explain this.\n     */\n\n    // note that the lengthy operation indexReader.reopen() does not\n    // modify the reader, so we can do it without holding a lock. We can\n    // safely read indexReader without holding the write lock, because\n    // no other thread can be writing at this time (this method is the\n    // only possible writer, and it is \"synchronized\" to avoid this case).\n    IndexReader r2 = IndexReader.openIfChanged(indexReader);\n    if (r2 != null) {\n      IndexReader oldreader = indexReader;\n      // we can close the old searcher, but need to synchronize this\n      // so that we don't close it in the middle that another routine\n      // is reading from it.\n      indexReaderLock.writeLock().lock();\n      indexReader = r2;\n      indexReaderLock.writeLock().unlock();\n      // We can close the old reader, but need to be certain that we\n      // don't close it while another method is reading from it.\n      // Luckily, we can be certain of that even without putting the\n      // oldreader.close() in the locked section. The reason is that\n      // after lock() succeeded above, we know that all existing readers\n      // had finished (this is what a read-write lock ensures). New\n      // readers, starting after the unlock() we just did, already got\n      // the new indexReader we set above. So nobody can be possibly\n      // using the old indexReader, and we can close it:\n      oldreader.close();\n\n      // We prefetch some of the arrays to make requests much faster.\n      // Let's refresh these prefetched arrays; This refresh is much\n      // is made more efficient by assuming that it is enough to read\n      // the values for new categories (old categories could not have been\n      // changed or deleted)\n      // Note that this this done without the write lock being held,\n      // which means that it is possible that during a refresh(), a\n      // reader will have some methods (like getOrdinal and getCategory)\n      // return fresh information, while getParent()\n      // (only to be prefetched now) still return older information.\n      // We consider this to be acceptable. The important thing,\n      // however, is that refreshPrefetchArrays() itself writes to\n      // the arrays in a correct manner (see discussion there)\n      parentArray.refresh(indexReader);\n\n      // Remove any INVALID_ORDINAL values from the ordinal cache,\n      // because it is possible those are now answered by the new data!\n      Iterator<Entry<String, Integer>> i = ordinalCache.entrySet().iterator();\n      while (i.hasNext()) {\n        Entry<String, Integer> e = i.next();\n        if (e.getValue().intValue() == INVALID_ORDINAL) {\n          i.remove();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["24315bf90acffc79fa6d5fb325f6c1cf9fc9642b"],"7fea68ff83c1db2f720597dfcea5bee943a35f35":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"24315bf90acffc79fa6d5fb325f6c1cf9fc9642b":["7fea68ff83c1db2f720597dfcea5bee943a35f35"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89f15687f60bd49cd3d9de427e85c17fd9397d61"],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","89f15687f60bd49cd3d9de427e85c17fd9397d61"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"]},"commit2Childs":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["7fea68ff83c1db2f720597dfcea5bee943a35f35"],"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7fea68ff83c1db2f720597dfcea5bee943a35f35":["24315bf90acffc79fa6d5fb325f6c1cf9fc9642b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","89f15687f60bd49cd3d9de427e85c17fd9397d61","817d8435e9135b756f08ce6710ab0baac51bdf88"],"24315bf90acffc79fa6d5fb325f6c1cf9fc9642b":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["8a8259c922a83abc544609227a60d48e5ee93e7e","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}