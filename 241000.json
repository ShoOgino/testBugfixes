{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","commits":[{"id":"106069d345c14ee5c76f0ea76397b02a656f883c","date":1411998064,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    long startMs = System.currentTimeMillis();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        Executors.newFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \"+Math.round(diffMs/1000d)+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    long startMs = System.currentTimeMillis();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        Executors.newFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \"+Math.round(diffMs/1000d)+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    long startMs = System.currentTimeMillis();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \"+Math.round(diffMs/1000d)+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    long startMs = System.currentTimeMillis();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        Executors.newFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \"+Math.round(diffMs/1000d)+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n        timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    long startMs = System.currentTimeMillis();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \"+Math.round(diffMs/1000d)+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d","date":1440987729,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n        timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdownNow();\n    }\n\n    log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n        timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n        timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new DefaultSolrThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n        timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Waiting up to {} secs for {} replicas to apply schema update version {} for collection {}\"\n          , maxWaitSecs, concurrentTasks.size(), schemaZkVersion, collection);\n    }\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core {} version mismatch! Expected {} but got {}\", coreUrl, schemaZkVersion, vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"Core {} was interrupted waiting for schema version {} to propagate to {} replicas for collection {}\"\n            , localCoreNodeName, schemaZkVersion, concurrentTasks.size(), collection);\n      }\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n          timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n    }\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    log.info(\"Waiting up to \"+maxWaitSecs+\" secs for \"+concurrentTasks.size()+\n        \" replicas to apply schema update version \"+schemaZkVersion+\" for collection \"+collection);\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core \"+coreUrl+\" version mismatch! Expected \"+schemaZkVersion+\" but got \"+vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core \"+localCoreNodeName+\" was interrupted waiting for schema version \"+schemaZkVersion+\n          \" to propagate to \"+concurrentTasks.size()+\" replicas for collection \"+collection);\n\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n        timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#waitForSchemaZkVersionAgreement(String,String,int,ZkController,int).mjava","sourceNew":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Waiting up to {} secs for {} replicas to apply schema update version {} for collection {}\"\n          , maxWaitSecs, concurrentTasks.size(), schemaZkVersion, collection);\n    }\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core {} version mismatch! Expected {} but got {}\", coreUrl, schemaZkVersion, vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      log.warn(\"Core {} was interrupted waiting for schema version {} to propagate to {} replicas for collection {}\"\n          , localCoreNodeName, schemaZkVersion, concurrentTasks.size(), collection);\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n          timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n    }\n  }\n\n","sourceOld":"  /**\n   * Block up to a specified maximum time until we see agreement on the schema\n   * version in ZooKeeper across all replicas for a collection.\n   */\n  public static void waitForSchemaZkVersionAgreement(String collection, String localCoreNodeName,\n                                                     int schemaZkVersion, ZkController zkController, int maxWaitSecs)\n  {\n    RTimer timer = new RTimer();\n\n    // get a list of active replica cores to query for the schema zk version (skipping this core of course)\n    List<GetZkSchemaVersionCallable> concurrentTasks = new ArrayList<>();\n    for (String coreUrl : getActiveReplicaCoreUrls(zkController, collection, localCoreNodeName))\n      concurrentTasks.add(new GetZkSchemaVersionCallable(coreUrl, schemaZkVersion));\n    if (concurrentTasks.isEmpty())\n      return; // nothing to wait for ...\n\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Waiting up to {} secs for {} replicas to apply schema update version {} for collection {}\"\n          , maxWaitSecs, concurrentTasks.size(), schemaZkVersion, collection);\n    }\n\n    // use an executor service to invoke schema zk version requests in parallel with a max wait time\n    int poolSize = Math.min(concurrentTasks.size(), 10);\n    ExecutorService parallelExecutor =\n        ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory(\"managedSchemaExecutor\"));\n    try {\n      List<Future<Integer>> results =\n          parallelExecutor.invokeAll(concurrentTasks, maxWaitSecs, TimeUnit.SECONDS);\n\n      // determine whether all replicas have the update\n      List<String> failedList = null; // lazily init'd\n      for (int f=0; f < results.size(); f++) {\n        int vers = -1;\n        Future<Integer> next = results.get(f);\n        if (next.isDone() && !next.isCancelled()) {\n          // looks to have finished, but need to check the version value too\n          try {\n            vers = next.get();\n          } catch (ExecutionException e) {\n            // shouldn't happen since we checked isCancelled\n          }\n        }\n\n        if (vers == -1) {\n          String coreUrl = concurrentTasks.get(f).coreUrl;\n          log.warn(\"Core {} version mismatch! Expected {} but got {}\", coreUrl, schemaZkVersion, vers);\n          if (failedList == null) failedList = new ArrayList<>();\n          failedList.add(coreUrl);\n        }\n      }\n\n      // if any tasks haven't completed within the specified timeout, it's an error\n      if (failedList != null)\n        throw new SolrException(ErrorCode.SERVER_ERROR, failedList.size()+\" out of \"+(concurrentTasks.size() + 1)+\n            \" replicas failed to update their schema to version \"+schemaZkVersion+\" within \"+\n            maxWaitSecs+\" seconds! Failed cores: \"+failedList);\n\n    } catch (InterruptedException ie) {\n      if (log.isWarnEnabled()) {\n        log.warn(\"Core {} was interrupted waiting for schema version {} to propagate to {} replicas for collection {}\"\n            , localCoreNodeName, schemaZkVersion, concurrentTasks.size(), collection);\n      }\n      Thread.currentThread().interrupt();\n    } finally {\n      if (!parallelExecutor.isShutdown())\n        parallelExecutor.shutdown();\n    }\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Took {}ms for {} replicas to apply schema update version {} for collection {}\",\n          timer.getTime(), concurrentTasks.size(), schemaZkVersion, collection);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","106069d345c14ee5c76f0ea76397b02a656f883c"],"575e66bd4b2349209027f6801184da7fc3cba13f":["9df8125ba9193a2e2e285ed92157810b1952a244"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["cb5af3afeddbb803fb785098176e6e177c34261b"],"106069d345c14ee5c76f0ea76397b02a656f883c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"cb5af3afeddbb803fb785098176e6e177c34261b":["106069d345c14ee5c76f0ea76397b02a656f883c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"],"9df8125ba9193a2e2e285ed92157810b1952a244":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9a47902d6207303f5ed3e7aaca62ca33433af66","106069d345c14ee5c76f0ea76397b02a656f883c"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["9df8125ba9193a2e2e285ed92157810b1952a244"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"106069d345c14ee5c76f0ea76397b02a656f883c":["d9a47902d6207303f5ed3e7aaca62ca33433af66","cb5af3afeddbb803fb785098176e6e177c34261b"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d"],"70d61fdc6a5871f80a74c0e2e55bb8a94e9ac59d":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cb5af3afeddbb803fb785098176e6e177c34261b":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"9df8125ba9193a2e2e285ed92157810b1952a244":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d9a47902d6207303f5ed3e7aaca62ca33433af66","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}