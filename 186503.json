{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String]).mjava","commits":[{"id":"9a57adc9bfabbc207ed17740dd86e0a2401ea385","date":1355507623,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Set[String]).mjava","sourceNew":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes) {\n    List<String> coreNames = new ArrayList<String>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<String,Map<String,Integer>>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<String>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Set<String> liveNodes) {\n    List<String> coreNames = new ArrayList<String>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<String,Map<String,Integer>>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<String>(\n        liveNodes.size());\n    for (String nodeName : liveNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / liveNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % liveNodes.size();\n    int numberOfNodesSupposedToRunMinShards = liveNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (numberOfNodesSupposedToRunMaxShards == 0) ? minShardsPerSlicePerNode\n        : (minShardsPerSlicePerNode + 1);\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (liveNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes) {\n    List<String> coreNames = new ArrayList<String>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<String,Map<String,Integer>>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<String>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String]).mjava","sourceNew":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes) {\n    List<String> coreNames = new ArrayList<String>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<String,Map<String,Integer>>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<String>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08b22329006608bd6b95aeba7a59f28092cd7a5e","date":1419362789,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String],boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest#verifySubmitCaptures(List[SubmitCapture],Integer,Integer,Collection[String]).mjava","sourceNew":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes, boolean dontShuffleCreateNodeSet) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    final Map<String,String> coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map = new HashMap<>();\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.put(coreName, shardRequest.shards[0]);\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n        \n        if (dontShuffleCreateNodeSet) {\n          final String expectedNodeName = nodeUrlWithoutProtocolPartForLiveNodes.get((numberOfReplica * (i - 1) + (j - 1)) % nodeUrlWithoutProtocolPartForLiveNodes.size());\n          assertFalse(\"expectedNodeName is null for coreName=\"+coreName, null == expectedNodeName);\n          \n          final String actualNodeName = coreName_TO_nodeUrlWithoutProtocolPartForLiveNodes_map.get(coreName);\n          assertFalse(\"actualNodeName is null for coreName=\"+coreName, null == actualNodeName);\n\n          assertTrue(\"node name mismatch for coreName=\"+coreName+\" ( actual=\"+actualNodeName+\" versus expected=\"+expectedNodeName+\" )\", actualNodeName.equals(expectedNodeName));\n        }\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","sourceOld":"  protected void verifySubmitCaptures(List<SubmitCapture> submitCaptures,\n      Integer numberOfSlices, Integer numberOfReplica, Collection<String> createNodes) {\n    List<String> coreNames = new ArrayList<>();\n    Map<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap = new HashMap<>();\n    List<String> nodeUrlWithoutProtocolPartForLiveNodes = new ArrayList<>(\n        createNodes.size());\n    for (String nodeName : createNodes) {\n      String nodeUrlWithoutProtocolPart = nodeName.replaceAll(\"_\", \"/\");\n      if (nodeUrlWithoutProtocolPart.startsWith(\"http://\")) nodeUrlWithoutProtocolPart = nodeUrlWithoutProtocolPart\n          .substring(7);\n      nodeUrlWithoutProtocolPartForLiveNodes.add(nodeUrlWithoutProtocolPart);\n    }\n    \n    for (SubmitCapture submitCapture : submitCaptures) {\n      ShardRequest shardRequest = submitCapture.shardRequestCapture.getValue();\n      assertEquals(CoreAdminAction.CREATE.toString(),\n          shardRequest.params.get(CoreAdminParams.ACTION));\n      // assertEquals(shardRequest.params, submitCapture.params);\n      String coreName = shardRequest.params.get(CoreAdminParams.NAME);\n      assertFalse(\"Core with name \" + coreName + \" created twice\",\n          coreNames.contains(coreName));\n      coreNames.add(coreName);\n      assertEquals(CONFIG_NAME,\n          shardRequest.params.get(\"collection.configName\"));\n      assertEquals(COLLECTION_NAME,\n          shardRequest.params.get(CoreAdminParams.COLLECTION));\n      assertEquals(numberOfSlices.toString(),\n          shardRequest.params.get(ZkStateReader.NUM_SHARDS_PROP));\n      assertEquals(ADMIN_PATH, shardRequest.params.get(\"qt\"));\n      assertEquals(1, shardRequest.purpose);\n      assertEquals(1, shardRequest.shards.length);\n      assertEquals(submitCapture.nodeUrlsWithoutProtocolPartCapture.getValue(),\n          shardRequest.shards[0]);\n      assertTrue(\"Shard \" + coreName + \" created on wrong node \"\n          + shardRequest.shards[0],\n          nodeUrlWithoutProtocolPartForLiveNodes\n              .contains(shardRequest.shards[0]));\n      assertEquals(shardRequest.shards, shardRequest.actualShards);\n      \n      String sliceName = shardRequest.params.get(CoreAdminParams.SHARD);\n      if (!sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .containsKey(sliceName)) {\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.put(\n            sliceName, new HashMap<String,Integer>());\n      }\n      Map<String,Integer> nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n          .get(sliceName);\n      Integer existingCount;\n      nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n          .put(\n              shardRequest.shards[0],\n              ((existingCount = nodeUrlsWithoutProtocolPartToNumberOfShardsRunningMap\n                  .get(shardRequest.shards[0])) == null) ? 1\n                  : (existingCount + 1));\n    }\n    \n    assertEquals(numberOfSlices * numberOfReplica, coreNames.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      for (int j = 1; j <= numberOfReplica; j++) {\n        String coreName = COLLECTION_NAME + \"_shard\" + i + \"_replica\" + j;\n        assertTrue(\"Shard \" + coreName + \" was not created\",\n            coreNames.contains(coreName));\n      }\n    }\n    \n    assertEquals(numberOfSlices.intValue(),\n        sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.size());\n    for (int i = 1; i <= numberOfSlices; i++) {\n      sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap.keySet()\n          .contains(\"shard\" + i);\n    }\n    int minShardsPerSlicePerNode = numberOfReplica / createNodes.size();\n    int numberOfNodesSupposedToRunMaxShards = numberOfReplica\n        % createNodes.size();\n    int numberOfNodesSupposedToRunMinShards = createNodes.size()\n        - numberOfNodesSupposedToRunMaxShards;\n    int maxShardsPerSlicePerNode = (minShardsPerSlicePerNode + 1);\n    if (numberOfNodesSupposedToRunMaxShards == 0) {\n      numberOfNodesSupposedToRunMaxShards = numberOfNodesSupposedToRunMinShards;\n      maxShardsPerSlicePerNode = minShardsPerSlicePerNode;\n    }\n    boolean diffBetweenMinAndMaxShardsPerSlicePerNode = (maxShardsPerSlicePerNode != minShardsPerSlicePerNode);\n    \n    for (Entry<String,Map<String,Integer>> sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMap\n        .entrySet()) {\n      int numberOfShardsRunning = 0;\n      int numberOfNodesRunningMinShards = 0;\n      int numberOfNodesRunningMaxShards = 0;\n      int numberOfNodesRunningAtLeastOneShard = 0;\n      for (String nodeUrlsWithoutProtocolPart : sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n          .getValue().keySet()) {\n        int numberOfShardsRunningOnThisNode = sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n            .getValue().get(nodeUrlsWithoutProtocolPart);\n        numberOfShardsRunning += numberOfShardsRunningOnThisNode;\n        numberOfNodesRunningAtLeastOneShard++;\n        assertTrue(\n            \"Node \"\n                + nodeUrlsWithoutProtocolPart\n                + \" is running wrong number of shards. Supposed to run \"\n                + minShardsPerSlicePerNode\n                + (diffBetweenMinAndMaxShardsPerSlicePerNode ? (\" or \" + maxShardsPerSlicePerNode)\n                    : \"\"),\n            (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode)\n                || (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode));\n        if (numberOfShardsRunningOnThisNode == minShardsPerSlicePerNode) numberOfNodesRunningMinShards++;\n        if (numberOfShardsRunningOnThisNode == maxShardsPerSlicePerNode) numberOfNodesRunningMaxShards++;\n      }\n      if (minShardsPerSlicePerNode == 0) numberOfNodesRunningMinShards = (createNodes\n          .size() - numberOfNodesRunningAtLeastOneShard);\n      assertEquals(\n          \"Too many shards are running under slice \"\n              + sliceToNodeUrlsWithoutProtocolPartToNumberOfShardsRunningMapMapEntry\n                  .getKey(),\n          numberOfReplica.intValue(), numberOfShardsRunning);\n      assertEquals(numberOfNodesSupposedToRunMinShards,\n          numberOfNodesRunningMinShards);\n      assertEquals(numberOfNodesSupposedToRunMaxShards,\n          numberOfNodesRunningMaxShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"08b22329006608bd6b95aeba7a59f28092cd7a5e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["08b22329006608bd6b95aeba7a59f28092cd7a5e"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["08b22329006608bd6b95aeba7a59f28092cd7a5e"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"08b22329006608bd6b95aeba7a59f28092cd7a5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}