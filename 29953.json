{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","commits":[{"id":"fc9c1463ee15ef7c0d3b9656b69b7a5ba49ac3d4","date":1558992012,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  public static List<Suggester.SuggestionInfo> getSuggestions(AutoScalingConfig autoScalingConf,\n                                                              SolrCloudManager cloudManager, int max, int timeoutInSecs, SolrParams params) {\n    Policy policy = autoScalingConf.getPolicy();\n    Suggestion.Ctx ctx = new Suggestion.Ctx();\n    ctx.endTime = cloudManager.getTimeSource().getTimeNs() + TimeUnit.SECONDS.toNanos(timeoutInSecs);\n    ctx.max = max;\n    ctx.session = policy.createSession(cloudManager);\n    String[] t = params == null ? null : params.getParams(\"type\");\n    List<String> types = t == null? Collections.EMPTY_LIST: Arrays.asList(t);\n\n    if(types.isEmpty() || types.contains(violation.name())) {\n      List<Violation> violations = ctx.session.getViolations();\n      for (Violation violation : violations) {\n        violation.getClause().getThirdTag().varType.getSuggestions(ctx.setViolation(violation));\n        ctx.violation = null;\n      }\n\n      for (Violation current : ctx.session.getViolations()) {\n        for (Violation old : violations) {\n          if (!ctx.needMore()) return ctx.getSuggestions();\n          if (current.equals(old)) {\n            //could not be resolved\n            ctx.suggestions.add(new Suggester.SuggestionInfo(current, null, unresolved_violation));\n            break;\n          }\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(repair.name())) {\n      if (ctx.needMore()) {\n        try {\n          addMissingReplicas(cloudManager, ctx);\n        } catch (IOException e) {\n          log.error(\"Unable to fetch cluster state\", e);\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(improvement.name())) {\n      if (ctx.needMore()) {\n        suggestOptimizations(ctx, Math.min(ctx.max - ctx.getSuggestions().size(), 10));\n      }\n    }\n    return ctx.getSuggestions();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"527adea7ce767368d7317339023e18e39702132e","date":1592163810,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","sourceNew":"  public static List<Suggester.SuggestionInfo> getSuggestions(AutoScalingConfig autoScalingConf,\n                                                              SolrCloudManager cloudManager, int max, int timeoutInSecs, SolrParams params) {\n    Policy policy = autoScalingConf.getPolicy();\n    Suggestion.Ctx ctx = new Suggestion.Ctx();\n    ctx.endTime = cloudManager.getTimeSource().getTimeNs() + TimeUnit.SECONDS.toNanos(timeoutInSecs);\n    ctx.max = max;\n    ctx.session = policy.createSession(cloudManager);\n    String[] t = params == null ? null : params.getParams(\"type\");\n    @SuppressWarnings({\"unchecked\"})\n    List<String> types = t == null? Collections.EMPTY_LIST: Arrays.asList(t);\n\n    if(types.isEmpty() || types.contains(violation.name())) {\n      List<Violation> violations = ctx.session.getViolations();\n      for (Violation violation : violations) {\n        violation.getClause().getThirdTag().varType.getSuggestions(ctx.setViolation(violation));\n        ctx.violation = null;\n      }\n\n      for (Violation current : ctx.session.getViolations()) {\n        for (Violation old : violations) {\n          if (!ctx.needMore()) return ctx.getSuggestions();\n          if (current.equals(old)) {\n            //could not be resolved\n            ctx.suggestions.add(new Suggester.SuggestionInfo(current, null, unresolved_violation));\n            break;\n          }\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(repair.name())) {\n      if (ctx.needMore()) {\n        try {\n          addMissingReplicas(cloudManager, ctx);\n        } catch (IOException e) {\n          log.error(\"Unable to fetch cluster state\", e);\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(improvement.name())) {\n      if (ctx.needMore()) {\n        suggestOptimizations(ctx, Math.min(ctx.max - ctx.getSuggestions().size(), 10));\n      }\n    }\n    return ctx.getSuggestions();\n  }\n\n","sourceOld":"  public static List<Suggester.SuggestionInfo> getSuggestions(AutoScalingConfig autoScalingConf,\n                                                              SolrCloudManager cloudManager, int max, int timeoutInSecs, SolrParams params) {\n    Policy policy = autoScalingConf.getPolicy();\n    Suggestion.Ctx ctx = new Suggestion.Ctx();\n    ctx.endTime = cloudManager.getTimeSource().getTimeNs() + TimeUnit.SECONDS.toNanos(timeoutInSecs);\n    ctx.max = max;\n    ctx.session = policy.createSession(cloudManager);\n    String[] t = params == null ? null : params.getParams(\"type\");\n    List<String> types = t == null? Collections.EMPTY_LIST: Arrays.asList(t);\n\n    if(types.isEmpty() || types.contains(violation.name())) {\n      List<Violation> violations = ctx.session.getViolations();\n      for (Violation violation : violations) {\n        violation.getClause().getThirdTag().varType.getSuggestions(ctx.setViolation(violation));\n        ctx.violation = null;\n      }\n\n      for (Violation current : ctx.session.getViolations()) {\n        for (Violation old : violations) {\n          if (!ctx.needMore()) return ctx.getSuggestions();\n          if (current.equals(old)) {\n            //could not be resolved\n            ctx.suggestions.add(new Suggester.SuggestionInfo(current, null, unresolved_violation));\n            break;\n          }\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(repair.name())) {\n      if (ctx.needMore()) {\n        try {\n          addMissingReplicas(cloudManager, ctx);\n        } catch (IOException e) {\n          log.error(\"Unable to fetch cluster state\", e);\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(improvement.name())) {\n      if (ctx.needMore()) {\n        suggestOptimizations(ctx, Math.min(ctx.max - ctx.getSuggestions().size(), 10));\n      }\n    }\n    return ctx.getSuggestions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3adc4d119a7deba35b2721853853464857d9d0a9","date":1594608068,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","sourceNew":"  public static List<Suggester.SuggestionInfo> getSuggestions(AutoScalingConfig autoScalingConf,\n                                                              SolrCloudManager cloudManager, int max, int timeoutInSecs, SolrParams params) {\n    Policy policy = autoScalingConf.getPolicy();\n    Suggestion.Ctx ctx = new Suggestion.Ctx();\n    ctx.endTime = cloudManager.getTimeSource().getTimeNs() + TimeUnit.SECONDS.toNanos(timeoutInSecs);\n    ctx.max = max;\n    ctx.session = policy.createSession(cloudManager);\n    String[] t = params == null ? null : params.getParams(\"type\");\n    List<String> types = t == null? Collections.emptyList(): Arrays.asList(t);\n\n    if(types.isEmpty() || types.contains(violation.name())) {\n      List<Violation> violations = ctx.session.getViolations();\n      for (Violation violation : violations) {\n        violation.getClause().getThirdTag().varType.getSuggestions(ctx.setViolation(violation));\n        ctx.violation = null;\n      }\n\n      for (Violation current : ctx.session.getViolations()) {\n        for (Violation old : violations) {\n          if (!ctx.needMore()) return ctx.getSuggestions();\n          if (current.equals(old)) {\n            //could not be resolved\n            ctx.suggestions.add(new Suggester.SuggestionInfo(current, null, unresolved_violation));\n            break;\n          }\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(repair.name())) {\n      if (ctx.needMore()) {\n        try {\n          addMissingReplicas(cloudManager, ctx);\n        } catch (IOException e) {\n          log.error(\"Unable to fetch cluster state\", e);\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(improvement.name())) {\n      if (ctx.needMore()) {\n        suggestOptimizations(ctx, Math.min(ctx.max - ctx.getSuggestions().size(), 10));\n      }\n    }\n    return ctx.getSuggestions();\n  }\n\n","sourceOld":"  public static List<Suggester.SuggestionInfo> getSuggestions(AutoScalingConfig autoScalingConf,\n                                                              SolrCloudManager cloudManager, int max, int timeoutInSecs, SolrParams params) {\n    Policy policy = autoScalingConf.getPolicy();\n    Suggestion.Ctx ctx = new Suggestion.Ctx();\n    ctx.endTime = cloudManager.getTimeSource().getTimeNs() + TimeUnit.SECONDS.toNanos(timeoutInSecs);\n    ctx.max = max;\n    ctx.session = policy.createSession(cloudManager);\n    String[] t = params == null ? null : params.getParams(\"type\");\n    @SuppressWarnings({\"unchecked\"})\n    List<String> types = t == null? Collections.EMPTY_LIST: Arrays.asList(t);\n\n    if(types.isEmpty() || types.contains(violation.name())) {\n      List<Violation> violations = ctx.session.getViolations();\n      for (Violation violation : violations) {\n        violation.getClause().getThirdTag().varType.getSuggestions(ctx.setViolation(violation));\n        ctx.violation = null;\n      }\n\n      for (Violation current : ctx.session.getViolations()) {\n        for (Violation old : violations) {\n          if (!ctx.needMore()) return ctx.getSuggestions();\n          if (current.equals(old)) {\n            //could not be resolved\n            ctx.suggestions.add(new Suggester.SuggestionInfo(current, null, unresolved_violation));\n            break;\n          }\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(repair.name())) {\n      if (ctx.needMore()) {\n        try {\n          addMissingReplicas(cloudManager, ctx);\n        } catch (IOException e) {\n          log.error(\"Unable to fetch cluster state\", e);\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(improvement.name())) {\n      if (ctx.needMore()) {\n        suggestOptimizations(ctx, Math.min(ctx.max - ctx.getSuggestions().size(), 10));\n      }\n    }\n    return ctx.getSuggestions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper#getSuggestions(AutoScalingConfig,SolrCloudManager,int,int,SolrParams).mjava","sourceNew":null,"sourceOld":"  public static List<Suggester.SuggestionInfo> getSuggestions(AutoScalingConfig autoScalingConf,\n                                                              SolrCloudManager cloudManager, int max, int timeoutInSecs, SolrParams params) {\n    Policy policy = autoScalingConf.getPolicy();\n    Suggestion.Ctx ctx = new Suggestion.Ctx();\n    ctx.endTime = cloudManager.getTimeSource().getTimeNs() + TimeUnit.SECONDS.toNanos(timeoutInSecs);\n    ctx.max = max;\n    ctx.session = policy.createSession(cloudManager);\n    String[] t = params == null ? null : params.getParams(\"type\");\n    List<String> types = t == null? Collections.emptyList(): Arrays.asList(t);\n\n    if(types.isEmpty() || types.contains(violation.name())) {\n      List<Violation> violations = ctx.session.getViolations();\n      for (Violation violation : violations) {\n        violation.getClause().getThirdTag().varType.getSuggestions(ctx.setViolation(violation));\n        ctx.violation = null;\n      }\n\n      for (Violation current : ctx.session.getViolations()) {\n        for (Violation old : violations) {\n          if (!ctx.needMore()) return ctx.getSuggestions();\n          if (current.equals(old)) {\n            //could not be resolved\n            ctx.suggestions.add(new Suggester.SuggestionInfo(current, null, unresolved_violation));\n            break;\n          }\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(repair.name())) {\n      if (ctx.needMore()) {\n        try {\n          addMissingReplicas(cloudManager, ctx);\n        } catch (IOException e) {\n          log.error(\"Unable to fetch cluster state\", e);\n        }\n      }\n    }\n\n    if(types.isEmpty() || types.contains(improvement.name())) {\n      if (ctx.needMore()) {\n        suggestOptimizations(ctx, Math.min(ctx.max - ctx.getSuggestions().size(), 10));\n      }\n    }\n    return ctx.getSuggestions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["3adc4d119a7deba35b2721853853464857d9d0a9"],"3adc4d119a7deba35b2721853853464857d9d0a9":["527adea7ce767368d7317339023e18e39702132e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"527adea7ce767368d7317339023e18e39702132e":["fc9c1463ee15ef7c0d3b9656b69b7a5ba49ac3d4"],"fc9c1463ee15ef7c0d3b9656b69b7a5ba49ac3d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3adc4d119a7deba35b2721853853464857d9d0a9":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fc9c1463ee15ef7c0d3b9656b69b7a5ba49ac3d4"],"527adea7ce767368d7317339023e18e39702132e":["3adc4d119a7deba35b2721853853464857d9d0a9"],"fc9c1463ee15ef7c0d3b9656b69b7a5ba49ac3d4":["527adea7ce767368d7317339023e18e39702132e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}