{"path":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","commits":[{"id":"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8","date":1195335263,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"/dev/null","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer());\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer());\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                Hits hits = searcher.search(new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))));\n                if (hits.length() > 0) {\n                  hits.doc(0);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].exception != null) {\n            throw threads[i].exception;\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ef4667b2b25d9000658952f122502648fa66c1e6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0018e7a0579df5d3de71d0bd878322a7abef04d9","date":1202242049,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                Hits hits = searcher.search(new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))));\n                if (hits.length() > 0) {\n                  hits.doc(0);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].exception != null) {\n            throw threads[i].exception;\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer());\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer());\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                Hits hits = searcher.search(new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))));\n                if (hits.length() > 0) {\n                  hits.doc(0);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].exception != null) {\n            throw threads[i].exception;\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9be9f2c84d62c91740efdfb6b8bef707c02ff795","date":1211502032,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                Hits hits = searcher.search(new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))));\n                if (hits.length() > 0) {\n                  hits.doc(0);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getId() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                Hits hits = searcher.search(new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))));\n                if (hits.length() > 0) {\n                  hits.doc(0);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].exception != null) {\n            throw threads[i].exception;\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5af07783dbc171e26a694c4f7d735e30c2769faa","date":1211569075,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getId() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                Hits hits = searcher.search(new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))));\n                if (hits.length() > 0) {\n                  hits.doc(0);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getId() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6e445b85e4a7150835d1b071b23748bb55b30d1","date":1212438098,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getId() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6db660b56f04fdb2853d25cdee8ee0d36559a521","date":1233313968,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new RAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cb1066f2afe9450585d0d10063ea4450085236f1","date":1233870820,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = new Random();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              try {\n                synchronized(this) {\n                  wait(1000);\n                }\n              } catch (InterruptedException e) {}\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              try {\n                synchronized(this) {\n                  wait(100);\n                }\n              } catch (InterruptedException e) {}\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      try {\n        wait(15000);\n      } catch(InterruptedException e) {}\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        try {\n          threads[i].join();\n          if (threads[i].error != null) {\n            String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n            fail(msg);\n          }\n        } catch (InterruptedException e) {}\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef4667b2b25d9000658952f122502648fa66c1e6","date":1250345179,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i);\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8d1458a2543cbd30cbfe7929be4dcb5c5251659","date":1254582241,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a046c0c310bc77931fc8441bd920053b607dd14","date":1254584734,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b41b991de69ba7b72d5e90cfcee25699a1a7fc9","date":1256127131,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1326054a8d3aa66382d49decc7f330955c9c6f71","date":1257386139,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90cb6b3f4e5652555b614adc90204287fbebd27c","date":1259494272,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 150;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 10 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 20 ||( i >=50 && i < 70) || i > 90) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(15000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e450c7d50c2fc84c963d0d7ade9d3217d868064d","date":1259932067,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List readers = Collections.synchronizedList(new ArrayList());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set readersToClose = Collections.synchronizedSet(new HashSet());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    Iterator it = readersToClose.iterator();\n    while (it.hasNext()) {\n      ((IndexReader) it.next()).close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    it = readersToClose.iterator();\n    while (it.hasNext()) {\n      assertReaderClosed((IndexReader) it.next(), true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6","date":1265808957,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT));\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT));\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT));\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT));\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.LIMITED);\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexReaderReopen#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = new MockRAMDirectory();\n    final int n = 30;\n\n    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n    for (int i = 0; i < n; i++) {\n      writer.addDocument(createDocument(i, 3));\n    }\n    writer.optimize();\n    writer.close();\n\n    final TestReopen test = new TestReopen() {      \n      @Override\n      protected void modifyIndex(int i) throws IOException {\n        if (i % 3 == 0) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.setNorm(i, \"field1\", 50);\n          modifier.close();\n        } else if (i % 3 == 1) {\n          IndexReader modifier = IndexReader.open(dir, false);\n          modifier.deleteDocument(i % modifier.maxDoc());\n          modifier.close();\n        } else {\n          IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));\n          modifier.addDocument(createDocument(n + i, 6));\n          modifier.close();\n        }\n      }\n\n      @Override\n      protected IndexReader openReader() throws IOException {\n        return IndexReader.open(dir, false);\n      }      \n    };\n    \n    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());\n    IndexReader firstReader = IndexReader.open(dir, false);\n    IndexReader reader = firstReader;\n    final Random rnd = newRandom();\n    \n    ReaderThread[] threads = new ReaderThread[n];\n    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());\n    \n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        IndexReader refreshed = reader.reopen();\n        if (refreshed != reader) {\n          readersToClose.add(reader);\n        }\n        reader = refreshed;\n      }\n      final IndexReader r = reader;\n      \n      final int index = i;    \n      \n      ReaderThreadTask task;\n      \n      if (i < 4 ||( i >=10 && i < 14) || i > 18) {\n        task = new ReaderThreadTask() {\n          \n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              if (index % 2 == 0) {\n                // refresh reader synchronized\n                ReaderCouple c = (refreshReader(r, test, index, true));\n                readersToClose.add(c.newReader);\n                readersToClose.add(c.refreshedReader);\n                readers.add(c);\n                // prevent too many readers\n                break;\n              } else {\n                // not synchronized\n                IndexReader refreshed = r.reopen();\n                \n                \n                IndexSearcher searcher = new IndexSearcher(refreshed);\n                ScoreDoc[] hits = searcher.search(\n                    new TermQuery(new Term(\"field1\", \"a\" + rnd.nextInt(refreshed.maxDoc()))),\n                    null, 1000).scoreDocs;\n                if (hits.length > 0) {\n                  searcher.doc(hits[0].doc);\n                }\n                \n                // r might have changed because this is not a \n                // synchronized method. However we don't want\n                // to make it synchronized to test \n                // thread-safety of IndexReader.close().\n                // That's why we add refreshed also to \n                // readersToClose, because double closing is fine\n                if (refreshed != r) {\n                  refreshed.close();\n                }\n                readersToClose.add(refreshed);\n              }\n              synchronized(this) {\n                wait(1000);\n              }\n            }\n          }\n          \n        };\n      } else {\n        task = new ReaderThreadTask() {\n          @Override\n          public void run() throws Exception {\n            while (!stopped) {\n              int numReaders = readers.size();\n              if (numReaders > 0) {\n                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));\n                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);\n              }\n              \n              synchronized(this) {\n                wait(100);\n              }\n            }\n                        \n          }\n          \n        };\n      }\n      \n      threads[i] = new ReaderThread(task);\n      threads[i].start();\n    }\n    \n    synchronized(this) {\n      wait(1000);\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].stopThread();\n      }\n    }\n    \n    for (int i = 0; i < n; i++) {\n      if (threads[i] != null) {\n        threads[i].join();\n        if (threads[i].error != null) {\n          String msg = \"Error occurred in thread \" + threads[i].getName() + \":\\n\" + threads[i].error.getMessage();\n          fail(msg);\n        }\n      }\n      \n    }\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      readerToClose.close();\n    }\n    \n    firstReader.close();\n    reader.close();\n    \n    for (final IndexReader readerToClose : readersToClose) {\n      assertReaderClosed(readerToClose, true, true);\n    }\n\n    assertReaderClosed(reader, true, true);\n    assertReaderClosed(firstReader, true, true);\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cb1066f2afe9450585d0d10063ea4450085236f1":["6db660b56f04fdb2853d25cdee8ee0d36559a521"],"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"0a046c0c310bc77931fc8441bd920053b607dd14":["ef4667b2b25d9000658952f122502648fa66c1e6","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"0018e7a0579df5d3de71d0bd878322a7abef04d9":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["cb1066f2afe9450585d0d10063ea4450085236f1"],"e6e445b85e4a7150835d1b071b23748bb55b30d1":["5af07783dbc171e26a694c4f7d735e30c2769faa"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["90cb6b3f4e5652555b614adc90204287fbebd27c"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef4667b2b25d9000658952f122502648fa66c1e6":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"6db660b56f04fdb2853d25cdee8ee0d36559a521":["e6e445b85e4a7150835d1b071b23748bb55b30d1"],"9be9f2c84d62c91740efdfb6b8bef707c02ff795":["0018e7a0579df5d3de71d0bd878322a7abef04d9"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["4b41b991de69ba7b72d5e90cfcee25699a1a7fc9"],"90cb6b3f4e5652555b614adc90204287fbebd27c":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["ef4667b2b25d9000658952f122502648fa66c1e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5af07783dbc171e26a694c4f7d735e30c2769faa":["9be9f2c84d62c91740efdfb6b8bef707c02ff795"],"4b41b991de69ba7b72d5e90cfcee25699a1a7fc9":["0a046c0c310bc77931fc8441bd920053b607dd14"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"]},"commit2Childs":{"cb1066f2afe9450585d0d10063ea4450085236f1":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"0a046c0c310bc77931fc8441bd920053b607dd14":["4b41b991de69ba7b72d5e90cfcee25699a1a7fc9"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"0018e7a0579df5d3de71d0bd878322a7abef04d9":["9be9f2c84d62c91740efdfb6b8bef707c02ff795"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["ef4667b2b25d9000658952f122502648fa66c1e6"],"e6e445b85e4a7150835d1b071b23748bb55b30d1":["6db660b56f04fdb2853d25cdee8ee0d36559a521"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["0018e7a0579df5d3de71d0bd878322a7abef04d9"],"ef4667b2b25d9000658952f122502648fa66c1e6":["0a046c0c310bc77931fc8441bd920053b607dd14","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"6db660b56f04fdb2853d25cdee8ee0d36559a521":["cb1066f2afe9450585d0d10063ea4450085236f1"],"9be9f2c84d62c91740efdfb6b8bef707c02ff795":["5af07783dbc171e26a694c4f7d735e30c2769faa"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["90cb6b3f4e5652555b614adc90204287fbebd27c"],"90cb6b3f4e5652555b614adc90204287fbebd27c":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["0a046c0c310bc77931fc8441bd920053b607dd14"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"5af07783dbc171e26a694c4f7d735e30c2769faa":["e6e445b85e4a7150835d1b071b23748bb55b30d1"],"4b41b991de69ba7b72d5e90cfcee25699a1a7fc9":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}