{"path":"lucene/contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","pathOld":"contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      if (VERBOSE) System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (VERBOSE) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (VERBOSE) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              if (VERBOSE) System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n        System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n        float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n        System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n      }\n    }\n    \n    if (!VERBOSE) return;\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      if (VERBOSE) System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (VERBOSE) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (VERBOSE) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              if (VERBOSE) System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n        System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n        float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n        System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n      }\n    }\n    \n    if (!VERBOSE) return;\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aedcfb5ebceafe4a0285436fa86269ed6c926442","date":1271441603,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/memory/src/test/org/apache/lucene/index/memory/MemoryIndexTest#run(String[]).mjava","sourceNew":null,"sourceOld":"  private void run(String[] args) throws Throwable {\n    int k = -1;\n    \n    int iters = 1;\n    if (args.length > ++k) iters = Math.max(1, Integer.parseInt(args[k]));\n    \n    int runs = 1;\n    if (args.length > ++k) runs = Math.max(1, Integer.parseInt(args[k]));\n    \n    String cmd = \"memram\";\n    if (args.length > ++k) cmd = args[k];\n    boolean useMemIndex = cmd.indexOf(\"mem\") >= 0;\n    boolean useRAMIndex = cmd.indexOf(\"ram\") >= 0;\n    \n    String[] queries = { \"term\", \"term*\", \"term~\", \"Apache\", \"Apach~ AND Copy*\" };\n    if (args.length > ++k) {\n      String arg = args[k];\n      if (arg.startsWith(\"@\")) \n        queries = readLines(new File(fileDir, arg.substring(1)));\n      else\n        queries = new String[] { arg };\n    }\n    \n    File[] files = new File[] {new File(\"CHANGES.txt\"), new File(\"LICENSE.txt\") };\n    if (args.length > ++k) {\n      files = new File[args.length - k];\n      for (int i=k; i < args.length; i++) {\n        files[i-k] = new File(args[i]);\n      }\n    }\n    \n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    \n    Analyzer[] analyzers = new Analyzer[] { \n        new SimpleAnalyzer(TEST_VERSION_CURRENT),\n        new StopAnalyzer(TEST_VERSION_CURRENT),\n        new StandardAnalyzer(TEST_VERSION_CURRENT),\n//        new WhitespaceAnalyzer(TEST_VERSION_CURRENT),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n\n    boolean first = true;\n\n    for (int iter=0; iter < iters; iter++) {\n      if (VERBOSE) System.out.println(\"\\n########### iteration=\" + iter);\n      long start = System.currentTimeMillis();            \n      long bytes = 0;\n      \n      for (int anal=0; anal < analyzers.length; anal++) {\n        this.analyzer = analyzers[anal];\n        \n        for (int i=0; i < files.length; i++) {\n          File file = files[i];\n          if (!file.exists() || file.isDirectory()) continue; // ignore\n          bytes += file.length();\n          String text = toString(new FileInputStream(file), null);\n          Document doc = createDocument(text);\n          if (VERBOSE) System.out.println(\"\\n*********** FILE=\" + file);\n          \n          boolean measureIndexing = false; // toggle this to measure query performance\n          MemoryIndex memind = null;\n          IndexSearcher memsearcher = null;\n          if (useMemIndex && !measureIndexing) {\n            memind = createMemoryIndex(doc);\n            memsearcher = memind.createSearcher();\n          }\n              \n          if (first) {\n            IndexSearcher s = memind.createSearcher();\n            TermDocs td = s.getIndexReader().termDocs(null);\n            assertTrue(td.next());\n            assertEquals(0, td.doc());\n            assertEquals(1, td.freq());\n            td.close();\n            s.close();\n            first = false;\n          }\n\n          RAMDirectory ramind = null;\n          IndexSearcher ramsearcher = null;\n          if (useRAMIndex && !measureIndexing) {\n            ramind = createRAMIndex(doc);\n            ramsearcher = new IndexSearcher(ramind);\n          }\n              \n          for (int q=0; q < queries.length; q++) {\n            try {\n              Query query = parseQuery(queries[q]);\n              for (int run=0; run < runs; run++) {\n                float score1 = 0.0f; float score2 = 0.0f;\n                if (useMemIndex && measureIndexing) {\n                  memind = createMemoryIndex(doc);\n                  memsearcher = memind.createSearcher();\n                }\n                if (useMemIndex) score1 = query(memsearcher, query); \n                if (useRAMIndex && measureIndexing) {\n                  ramind = createRAMIndex(doc);\n                  ramsearcher = new IndexSearcher(ramind);\n                }\n                if (useRAMIndex) score2 = query(ramsearcher, query);\n                if (useMemIndex && useRAMIndex) {\n                  if (VERBOSE) System.out.println(\"diff=\"+ (score1-score2) + \", query=\" + queries[q] + \", s1=\" + score1 + \", s2=\" + score2);\n                  if (score1 != score2 || score1 < 0.0f || score2 < 0.0f || score1 > 1.0f || score2 > 1.0f) {\n                    throw new IllegalStateException(\"BUG DETECTED:\" + (i*(q+1)) + \" at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n                  }\n                }\n              }\n\n            } catch (Throwable t) {\n              if (t instanceof OutOfMemoryError) t.printStackTrace();\n              if (VERBOSE) System.out.println(\"Fatal error at query=\" + queries[q] + \", file=\" + file + \", anal=\" + analyzer);\n              throw t;\n            }\n          }\n        }\n      }\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"\\nsecs = \" + ((end-start)/1000.0f));\n        System.out.println(\"queries/sec= \" + \n        (1.0f * runs * queries.length * analyzers.length * files.length \n            / ((end-start)/1000.0f)));\n        float mb = (1.0f * bytes * queries.length * runs) / (1024.0f * 1024.0f);\n        System.out.println(\"MB/sec = \" + (mb / ((end-start)/1000.0f)));\n      }\n    }\n    \n    if (!VERBOSE) return;\n    \n    if (useMemIndex && useRAMIndex) \n      System.out.println(\"No bug found. done.\");\n    else \n      System.out.println(\"Done benchmarking (without checking correctness).\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aedcfb5ebceafe4a0285436fa86269ed6c926442":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aedcfb5ebceafe4a0285436fa86269ed6c926442"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"aedcfb5ebceafe4a0285436fa86269ed6c926442":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["aedcfb5ebceafe4a0285436fa86269ed6c926442"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}