{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","commits":[{"id":"7f3090f7e0cab5b1f5acf12d21f31f00fe74a262","date":1475755647,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final SparseDISI disi;\n      synchronized (data) {\n        disi = new SparseDISI(maxDoc, data, entry.docsWithFieldOffset, entry.numDocsWithField);\n      }\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ca1fe3f1f5edea2339f7e7a31f0754878a72b0e","date":1476167489,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final SparseDISI disi = new SparseDISI(maxDoc, data, entry.docsWithFieldOffset, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final SparseDISI disi;\n      synchronized (data) {\n        disi = new SparseDISI(maxDoc, data, entry.docsWithFieldOffset, entry.numDocsWithField);\n      }\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feec55b6e9aaab41be57a5001b31fa14c3925ae4","date":1476170434,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final SparseDISI disi = new SparseDISI(maxDoc, data, entry.docsWithFieldOffset, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11134e449dabe11d6d0ff6a564d84b82cbe93722","date":1477299083,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public boolean advanceExact(int target) throws IOException {\n          this.doc = target;\n          return true;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public boolean advanceExact(int target) throws IOException {\n          return disi.advanceExact(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2714c85633b642b29871cf5ff8d17d3ba7bfd76","date":1477307753,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public boolean advanceExact(int target) throws IOException {\n          this.doc = target;\n          return true;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public boolean advanceExact(int target) throws IOException {\n          return disi.advanceExact(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2e0630a8cce59f323518336cb9f7de8b6cf6f6c","date":1477471141,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public boolean advanceExact(int target) throws IOException {\n          this.doc = target;\n          return true;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public boolean advanceExact(int target) throws IOException {\n          return disi.advanceExact(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      final LongValues normValues = getNormValues(entry);\n      return new NumericDocValues() {\n\n        int doc = -1;\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(doc);\n        }\n\n        @Override\n        public int docID() {\n          return doc;\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advance(doc + 1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          if (target >= maxDoc) {\n            return doc = NO_MORE_DOCS;\n          }\n          return doc = target;\n        }\n\n        @Override\n        public long cost() {\n          return maxDoc;\n        }\n\n      };\n    } else {\n      // sparse\n      final LongValues normValues = getNormValues(entry);\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      return new NumericDocValues() {\n\n        @Override\n        public int advance(int target) throws IOException {\n          return disi.advance(target);\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return disi.nextDoc();\n        }\n\n        @Override\n        public int docID() {\n          return disi.docID();\n        }\n\n        @Override\n        public long cost() {\n          return entry.numDocsWithField;\n        }\n\n        @Override\n        public long longValue() throws IOException {\n          return normValues.get(disi.index());\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"622a708571e534680618b3c5e0c28ac539a47776","date":1517406892,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexedDISI disi = new IndexedDISI(data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee61e2a803ee5c15d23a4e12245ae640fb60a518","date":1543843830,"type":3,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = disiCacheFactory.createCachedIndexedDISI(\n          disiInput, entry.docsWithFieldOffset + entry.docsWithFieldLength, entry.numDocsWithField, field.name);\n\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7a3d67eabf8fbf6297d7f142aca186593f5bb1c","date":1544534017,"type":3,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = disiCacheFactory.createCachedIndexedDISI(\n          disiInput, entry.docsWithFieldOffset + entry.docsWithFieldLength, entry.numDocsWithField, field.name);\n\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfd70c9571310639a77f0123aea0db41077d9bb6","date":1544538617,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = disiCacheFactory.createCachedIndexedDISI(\n          disiInput, entry.docsWithFieldOffset + entry.docsWithFieldLength, entry.numDocsWithField, field.name);\n\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e17b020972a0d6e8d6823f545571a66646a167","date":1547847724,"type":5,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c89f1ef80a9432f4eabaeda9a1e135cd72e60836","date":1547972642,"type":5,"author":"Tommaso Teofili","isMerge":true,"pathNew":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70NormsProducer#getNorms(FieldInfo).mjava","sourceNew":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public NumericDocValues getNorms(FieldInfo field) throws IOException {\n    final NormsEntry entry = norms.get(field.number);\n    if (entry.docsWithFieldOffset == -2) {\n      // empty\n      return DocValues.emptyNumeric();\n    } else if (entry.docsWithFieldOffset == -1) {\n      // dense\n      if (entry.bytesPerNorm == 0) {\n        return new DenseNormsIterator(maxDoc) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = getDataInput(field, entry);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(doc);\n            }\n          };\n        case 2:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) doc) << 1);\n            }\n          };\n        case 4:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) doc) << 2);\n            }\n          };\n        case 8:\n          return new DenseNormsIterator(maxDoc) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) doc) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    } else {\n      // sparse\n      final IndexInput disiInput = getDisiInput(field, entry);\n      final IndexedDISI disi = new IndexedDISI(disiInput, entry.numDocsWithField);\n      if (entry.bytesPerNorm == 0) {\n        return new SparseNormsIterator(disi) {\n          @Override\n          public long longValue() throws IOException {\n            return entry.normsOffset;\n          }\n        };\n      }\n      final RandomAccessInput slice = data.randomAccessSlice(entry.normsOffset, entry.numDocsWithField * (long) entry.bytesPerNorm);\n      switch (entry.bytesPerNorm) {\n        case 1:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readByte(disi.index());\n            }\n          };\n        case 2:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readShort(((long) disi.index()) << 1);\n            }\n          };\n        case 4:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readInt(((long) disi.index()) << 2);\n            }\n          };\n        case 8:\n          return new SparseNormsIterator(disi) {\n            @Override\n            public long longValue() throws IOException {\n              return slice.readLong(((long) disi.index()) << 3);\n            }\n          };\n        default:\n          // should not happen, we already validate bytesPerNorm in readFields\n          throw new AssertionError();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"03e17b020972a0d6e8d6823f545571a66646a167":["cfd70c9571310639a77f0123aea0db41077d9bb6"],"7f3090f7e0cab5b1f5acf12d21f31f00fe74a262":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cfd70c9571310639a77f0123aea0db41077d9bb6":["ee61e2a803ee5c15d23a4e12245ae640fb60a518","e7a3d67eabf8fbf6297d7f142aca186593f5bb1c"],"feec55b6e9aaab41be57a5001b31fa14c3925ae4":["7ca1fe3f1f5edea2339f7e7a31f0754878a72b0e"],"ee61e2a803ee5c15d23a4e12245ae640fb60a518":["622a708571e534680618b3c5e0c28ac539a47776"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","feec55b6e9aaab41be57a5001b31fa14c3925ae4"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":["cfd70c9571310639a77f0123aea0db41077d9bb6","03e17b020972a0d6e8d6823f545571a66646a167"],"a2e0630a8cce59f323518336cb9f7de8b6cf6f6c":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"7ca1fe3f1f5edea2339f7e7a31f0754878a72b0e":["7f3090f7e0cab5b1f5acf12d21f31f00fe74a262"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["feec55b6e9aaab41be57a5001b31fa14c3925ae4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a2e0630a8cce59f323518336cb9f7de8b6cf6f6c"],"622a708571e534680618b3c5e0c28ac539a47776":["a2e0630a8cce59f323518336cb9f7de8b6cf6f6c"],"e7a3d67eabf8fbf6297d7f142aca186593f5bb1c":["ee61e2a803ee5c15d23a4e12245ae640fb60a518"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["feec55b6e9aaab41be57a5001b31fa14c3925ae4","11134e449dabe11d6d0ff6a564d84b82cbe93722"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["03e17b020972a0d6e8d6823f545571a66646a167"]},"commit2Childs":{"03e17b020972a0d6e8d6823f545571a66646a167":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f3090f7e0cab5b1f5acf12d21f31f00fe74a262":["7ca1fe3f1f5edea2339f7e7a31f0754878a72b0e"],"cfd70c9571310639a77f0123aea0db41077d9bb6":["03e17b020972a0d6e8d6823f545571a66646a167","c89f1ef80a9432f4eabaeda9a1e135cd72e60836"],"feec55b6e9aaab41be57a5001b31fa14c3925ae4":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","11134e449dabe11d6d0ff6a564d84b82cbe93722","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"ee61e2a803ee5c15d23a4e12245ae640fb60a518":["cfd70c9571310639a77f0123aea0db41077d9bb6","e7a3d67eabf8fbf6297d7f142aca186593f5bb1c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":[],"a2e0630a8cce59f323518336cb9f7de8b6cf6f6c":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","622a708571e534680618b3c5e0c28ac539a47776"],"7ca1fe3f1f5edea2339f7e7a31f0754878a72b0e":["feec55b6e9aaab41be57a5001b31fa14c3925ae4"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7f3090f7e0cab5b1f5acf12d21f31f00fe74a262","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"622a708571e534680618b3c5e0c28ac539a47776":["ee61e2a803ee5c15d23a4e12245ae640fb60a518"],"e7a3d67eabf8fbf6297d7f142aca186593f5bb1c":["cfd70c9571310639a77f0123aea0db41077d9bb6"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["a2e0630a8cce59f323518336cb9f7de8b6cf6f6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}