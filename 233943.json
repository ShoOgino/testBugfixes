{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"feb75c13cdf6b27b36407e4b15b35cf3142ab619","date":1310465075,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e22ffe8cc51a892ae103df018822d7873e901c2a","date":1313696790,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19e21d98da803ac6174cb50a880e6289139756ca","date":1323342587,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      log.error(\"Error in constructing the core\", e);\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":["ab20a04a303d3d2a5078076f4633e0482d643cc0","ab20a04a303d3d2a5078076f4633e0482d643cc0","c37beb00356d86126002010a55107df0a3199427"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"efc85580874d26ca9617f9ad61628d56f6859762","date":1323367273,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      log.error(\"Error in constructing the core\", e);\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      log.error(\"Error in constructing the core\", e);\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c37beb00356d86126002010a55107df0a3199427","date":1323786101,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      log.error(\"Error in constructing the core\", e);\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":["19e21d98da803ac6174cb50a880e6289139756ca"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ceb6a6c707ada1df8bde804e25c98668e699a18","date":1323800602,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      log.error(\"Error in constructing the core\", e);\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":["3c8475e39c56b28600d2b496f3e78f7421190f62","3c8475e39c56b28600d2b496f3e78f7421190f62"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getIndexWriterProvider().getDirectoryFactory();\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"221ff19d62d5ff429ffecf8e7f3e01ff93754854","date":1329974551,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e2656623e57ced6c16aae473bab02019c951802","date":1342126181,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n                              e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n                              e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler, SolrCore prev) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // use the (old) writer to open the first searcher\n      RefCounted<IndexWriter> iwRef = null;\n      if (prev != null) {\n        iwRef = prev.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n        if (iwRef != null) {\n          final IndexWriter iw = iwRef.get();\n          newReaderCreator = new Callable<DirectoryReader>() {\n            @Override\n            public DirectoryReader call() throws Exception {\n              return DirectoryReader.open(iw, true);\n            }\n          };\n        }\n      }\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n\n      try {\n        getSearcher(false,false,null,true);\n      } finally {\n        newReaderCreator = null;\n        if (iwRef != null) iwRef.decref();\n      }\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n                              e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n                              e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler, SolrCore prev) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // use the (old) writer to open the first searcher\n      RefCounted<IndexWriter> iwRef = null;\n      if (prev != null) {\n        iwRef = prev.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n        if (iwRef != null) {\n          final IndexWriter iw = iwRef.get();\n          newReaderCreator = new Callable<DirectoryReader>() {\n            @Override\n            public DirectoryReader call() throws Exception {\n              return DirectoryReader.open(iw, true);\n            }\n          };\n        }\n      }\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n\n      try {\n        getSearcher(false,false,null,true);\n      } finally {\n        newReaderCreator = null;\n        if (iwRef != null) iwRef.decref();\n      }\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n                              e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n                              e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":null,"sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, String.valueOf(this.hashCode()), config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codec= initCodec(solrConfig, schema);\n    \n    if (updateHandler == null) {\n      initDirectoryFactory();\n    } else {\n      directoryFactory = updateHandler.getSolrCoreState().getDirectoryFactory();\n      this.isReloaded = true;\n    }\n    \n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (Throwable e) {\n      latch.countDown();//release the latch, otherwise we block trying to do the close.  This should be fine, since counting down on a latch of 0 is still fine\n      //close down the searcher and any other resources, if it exists, as this is not recoverable\n      close();\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9e2656623e57ced6c16aae473bab02019c951802":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"feb75c13cdf6b27b36407e4b15b35cf3142ab619":["c26f00b574427b55127e869b935845554afde1fa"],"4ceb6a6c707ada1df8bde804e25c98668e699a18":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","c37beb00356d86126002010a55107df0a3199427"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["7b91922b55d15444d554721b352861d028eb8278","19e21d98da803ac6174cb50a880e6289139756ca"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c37beb00356d86126002010a55107df0a3199427":["19e21d98da803ac6174cb50a880e6289139756ca"],"7b91922b55d15444d554721b352861d028eb8278":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"19e21d98da803ac6174cb50a880e6289139756ca":["7b91922b55d15444d554721b352861d028eb8278"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","9e2656623e57ced6c16aae473bab02019c951802"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["c37beb00356d86126002010a55107df0a3199427"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["9e2656623e57ced6c16aae473bab02019c951802"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["feb75c13cdf6b27b36407e4b15b35cf3142ab619"],"efc85580874d26ca9617f9ad61628d56f6859762":["7b91922b55d15444d554721b352861d028eb8278","19e21d98da803ac6174cb50a880e6289139756ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"]},"commit2Childs":{"9e2656623e57ced6c16aae473bab02019c951802":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"feb75c13cdf6b27b36407e4b15b35cf3142ab619":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"4ceb6a6c707ada1df8bde804e25c98668e699a18":[],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["9e2656623e57ced6c16aae473bab02019c951802","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["4ceb6a6c707ada1df8bde804e25c98668e699a18"],"c26f00b574427b55127e869b935845554afde1fa":["feb75c13cdf6b27b36407e4b15b35cf3142ab619"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"c37beb00356d86126002010a55107df0a3199427":["4ceb6a6c707ada1df8bde804e25c98668e699a18","7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"7b91922b55d15444d554721b352861d028eb8278":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","19e21d98da803ac6174cb50a880e6289139756ca","efc85580874d26ca9617f9ad61628d56f6859762"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"19e21d98da803ac6174cb50a880e6289139756ca":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","c37beb00356d86126002010a55107df0a3199427","efc85580874d26ca9617f9ad61628d56f6859762"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["221ff19d62d5ff429ffecf8e7f3e01ff93754854","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["7b91922b55d15444d554721b352861d028eb8278"],"efc85580874d26ca9617f9ad61628d56f6859762":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ceb6a6c707ada1df8bde804e25c98668e699a18","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","a258fbb26824fd104ed795e5d9033d2d040049ee","efc85580874d26ca9617f9ad61628d56f6859762","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}