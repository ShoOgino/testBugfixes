{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      false);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      false);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      DocsAndPositionsEnum.FLAG_PAYLOADS);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      false);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      DocsAndPositionsEnum.FLAG_PAYLOADS);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      false);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","sourceNew":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      DocsAndPositionsEnum.FLAG_PAYLOADS);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      false);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1","date":1353511594,"type":4,"author":"Shai Erera","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","sourceNew":null,"sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      DocsAndPositionsEnum.FLAG_PAYLOADS);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/ParentArray#refresh(IndexReader).mjava","sourceNew":null,"sourceOld":"  /**\n   * refreshPrefetch() refreshes the parent array. Initially, it fills the\n   * array from the positions of an appropriate posting list. If called during\n   * a refresh(), when the arrays already exist, only values for new documents\n   * (those beyond the last one in the array) are read from the positions and\n   * added to the arrays (that are appropriately enlarged). We assume (and\n   * this is indeed a correct assumption in our case) that existing categories\n   * are never modified or deleted.\n   */\n  void refresh(IndexReader indexReader) throws IOException {\n    // Note that it is not necessary for us to obtain the read lock.\n    // The reason is that we are only called from refresh() (precluding\n    // another concurrent writer) or from the constructor (when no method\n    // could be running).\n    // The write lock is also not held during the following code, meaning\n    // that reads *can* happen while this code is running. The \"volatile\"\n    // property of the prefetchParentOrdinal and prefetchDepth array\n    // references ensure the correct visibility property of the assignment\n    // but other than that, we do *not* guarantee that a reader will not\n    // use an old version of one of these arrays (or both) while a refresh\n    // is going on. But we find this acceptable - until a refresh has\n    // finished, the reader should not expect to see new information\n    // (and the old information is the same in the old and new versions).\n    int first;\n    int num = indexReader.maxDoc();\n    if (prefetchParentOrdinal==null) {\n      prefetchParentOrdinal = new int[num];\n      // Starting Lucene 2.9, following the change LUCENE-1542, we can\n      // no longer reliably read the parent \"-1\" (see comment in\n      // LuceneTaxonomyWriter.SinglePositionTokenStream). We have no way\n      // to fix this in indexing without breaking backward-compatibility\n      // with existing indexes, so what we'll do instead is just\n      // hard-code the parent of ordinal 0 to be -1, and assume (as is\n      // indeed the case) that no other parent can be -1.\n      if (num>0) {\n        prefetchParentOrdinal[0] = TaxonomyReader.INVALID_ORDINAL;\n      }\n      first = 1;\n    } else {\n      first = prefetchParentOrdinal.length;\n      if (first==num) {\n        return; // nothing to do - no category was added\n      }\n      // In Java 6, we could just do Arrays.copyOf()...\n      int[] newarray = new int[num];\n      System.arraycopy(prefetchParentOrdinal, 0, newarray, 0,\n          prefetchParentOrdinal.length);\n      prefetchParentOrdinal = newarray;\n    }\n\n    // Read the new part of the parents array from the positions:\n    // TODO (Facet): avoid Multi*?\n    Bits liveDocs = MultiFields.getLiveDocs(indexReader);\n    DocsAndPositionsEnum positions = MultiFields.getTermPositionsEnum(indexReader, liveDocs,\n                                                                      Consts.FIELD_PAYLOADS, new BytesRef(Consts.PAYLOAD_PARENT),\n                                                                      DocsAndPositionsEnum.FLAG_PAYLOADS);\n      if ((positions == null || positions.advance(first) == DocIdSetIterator.NO_MORE_DOCS) && first < num) {\n        throw new CorruptIndexException(\"Missing parent data for category \" + first);\n      }\n      for (int i=first; i<num; i++) {\n        // Note that we know positions.doc() >= i (this is an\n        // invariant kept throughout this loop)\n        if (positions.docID()==i) {\n          if (positions.freq() == 0) { // shouldn't happen\n            throw new CorruptIndexException(\n                \"Missing parent data for category \"+i);\n          }\n\n          // TODO (Facet): keep a local (non-volatile) copy of the prefetchParentOrdinal\n          // reference, because access to volatile reference is slower (?).\n          // Note: The positions we get here are one less than the position\n          // increment we added originally, so we get here the right numbers:\n          prefetchParentOrdinal[i] = positions.nextPosition();\n\n          if (positions.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {\n            if ( i+1 < num ) {\n              throw new CorruptIndexException(\n                  \"Missing parent data for category \"+(i+1));\n            }\n            break;\n          }\n        } else { // this shouldn't happen\n        throw new CorruptIndexException(\n            \"Missing parent data for category \"+i);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["322360ac5185a8446d3e0b530b2068bef67cd3d5","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b89678825b68eccaf09e6ab71675fc0b0af1e099","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["b89678825b68eccaf09e6ab71675fc0b0af1e099","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["322360ac5185a8446d3e0b530b2068bef67cd3d5"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["407687e67faf6e1f02a211ca078d8e3eed631027","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}