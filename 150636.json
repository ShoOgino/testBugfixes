{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param coreContainer if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param numShards \n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param coreContainer if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param numShards \n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param coreContainer if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param numShards \n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f97bf7e60e8b1531f7e992482be43dd563dde04e","date":1327594643,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param coreContainer if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param numShards \n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param coreContainer if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param numShards \n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param coreContainer if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param numShards \n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // recovery state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String shardZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, shardZkNodeName,\n                      descriptor.getName());\n                }\n              }\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName, true);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bec832dd3e463a3d19dd7ab614a84b1e719fc2b6","date":1330290166,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName, true);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName, true);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9813dd0748537c429b7c0a9b4723ea1ba496c047","date":1330304954,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName, true);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31fa604286b18a4e8e580658c67fa46cb82b798f","date":1330379030,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                        descriptor.getName());\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                        descriptor.getName());\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = localHost;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context, null);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                      descriptor.getName());\n                  waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5093a9e893633cc091cf2f729d7863671c2b715","date":1339132888,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerStatusQueue = Overseer.getInQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkClient, zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publishAsDown(getBaseUrl(), descriptor, coreZkNodeName,\n                        descriptor.getName());\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerStatusQueue = Overseer.getInQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n\n              ElectionContext context = new OverseerElectionContext(getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerStatusQueue = Overseer.getInQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32d5034e9ef94910c8cd2b01cc3c2be222453d0c","date":1342825337,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              if (descriptors != null) {\n                // before registering as live, make sure everyone is in a\n                // down state\n                for (CoreDescriptor descriptor : descriptors) {\n                  final String coreZkNodeName = getNodeName() + \"_\"\n                      + descriptor.getName();\n                  try {\n                    publish(descriptor, ZkStateReader.DOWN);\n                    waitForLeaderToSeeDownState(descriptor, coreZkNodeName);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"\", e);\n                  }\n                }\n              }\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    init();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938e4fd7b1e4b34da1650edba7471764bbfaefde","date":1344033248,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              \n              ElectionContext context = new OverseerElectionContext(\n                  shardHandler, adminPath,\n                  getNodeName(), zkStateReader);\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adc2388a5005de25370273411bc713d0ff722805","date":1345719157,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc if null, recovery will not be enabled\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              if (cc == null) {\n                shardHandler = new HttpShardHandlerFactory().getShardHandler();\n                adminPath = \"/admin/cores\";\n              } else {\n                shardHandler = cc.getShardHandlerFactory().getShardHandler();\n                adminPath = cc.getAdminPath();\n              }\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    zkClient.getZkClientConnectionStrategy().addDisconnectedListener(new ZkClientConnectionStrategy.DisconnectedListener() {\n      \n      @Override\n      public void disconnected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        // re register all descriptors\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            descriptor.getCloudDescriptor().isLeader = false;\n          }\n        }\n      }\n    });\n    \n    zkClient.getZkClientConnectionStrategy().addConnectedListener(new ZkClientConnectionStrategy.ConnectedListener() {\n      \n      @Override\n      public void connected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n            String leaderUrl;\n            try {\n              leaderUrl = getLeaderProps(cloudDesc.getCollectionName(), cloudDesc.getShardId())\n                  .getCoreUrl();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), descriptor.getName());\n            boolean isLeader = leaderUrl.equals(ourUrl);\n            log.info(\"SolrCore connected to ZooKeeper - we are \" + ourUrl + \" and leader is \" + leaderUrl);\n            cloudDesc.isLeader = isLeader;\n          }\n        }\n      }\n    });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    zkClient.getZkClientConnectionStrategy().addDisconnectedListener(new ZkClientConnectionStrategy.DisconnectedListener() {\n      \n      @Override\n      public void disconnected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        // re register all descriptors\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            descriptor.getCloudDescriptor().isLeader = false;\n          }\n        }\n      }\n    });\n    \n    zkClient.getZkClientConnectionStrategy().addConnectedListener(new ZkClientConnectionStrategy.ConnectedListener() {\n      \n      @Override\n      public void connected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n            String leaderUrl;\n            try {\n              leaderUrl = getLeaderProps(cloudDesc.getCollectionName(), cloudDesc.getShardId())\n                  .getCoreUrl();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), descriptor.getName());\n            boolean isLeader = leaderUrl.equals(ourUrl);\n            log.info(\"SolrCore connected to ZooKeeper - we are \" + ourUrl + \" and leader is \" + leaderUrl);\n            cloudDesc.isLeader = isLeader;\n          }\n        }\n      }\n    });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  register(descriptor.getName(), descriptor, true);\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this(cc, zkServerAddress, zkClientTimeout, zkClientConnectTimeout, localHost, locaHostPort, localHostContext, null, registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    if (localHostContext.contains(\"/\")) {\n      throw new IllegalArgumentException(\"localHostContext (\"\n          + localHostContext + \") should not contain a /\");\n    }\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.localHost = getHostAddress(localHost);\n    this.hostName = getHostNameFromAddress(this.localHost);\n    this.nodeName = this.hostName + ':' + this.localHostPort + '_' + this.localHostContext;\n    this.baseURL = this.localHost + \":\" + this.localHostPort + \"/\" + this.localHostContext;\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout, zkClientConnectTimeout,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          public void command() {\n            try {\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              //Overseer.createClientNodes(zkClient, getNodeName());\n              ShardHandler shardHandler;\n              String adminPath;\n              shardHandler = cc.getShardHandlerFactory().getShardHandler();\n              adminPath = cc.getAdminPath();\n              ZkController.this.overseer = new Overseer(shardHandler, adminPath, zkStateReader);\n              ElectionContext context = new OverseerElectionContext(zkClient, overseer, getNodeName());\n              overseerElector.joinElection(context);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              registerAllCoresAsDown(registerOnReconnect);\n              \n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors  != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it was\n                  // a leader that was expired - as well as what to do about leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Throwable t) {\n                    SolrException.log(log, \"Error registering SolrCore\", t);\n                  }\n                }\n              }\n  \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n\n          }\n\n \n        });\n    \n    zkClient.getZkClientConnectionStrategy().addDisconnectedListener(new ZkClientConnectionStrategy.DisconnectedListener() {\n      \n      @Override\n      public void disconnected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        // re register all descriptors\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            descriptor.getCloudDescriptor().isLeader = false;\n          }\n        }\n      }\n    });\n    \n    zkClient.getZkClientConnectionStrategy().addConnectedListener(new ZkClientConnectionStrategy.ConnectedListener() {\n      \n      @Override\n      public void connected() {\n        List<CoreDescriptor> descriptors = registerOnReconnect.getCurrentDescriptors();\n        if (descriptors  != null) {\n          for (CoreDescriptor descriptor : descriptors) {\n            CloudDescriptor cloudDesc = descriptor.getCloudDescriptor();\n            String leaderUrl;\n            try {\n              leaderUrl = getLeaderProps(cloudDesc.getCollectionName(), cloudDesc.getShardId())\n                  .getCoreUrl();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            String ourUrl = ZkCoreNodeProps.getCoreUrl(getBaseUrl(), descriptor.getName());\n            boolean isLeader = leaderUrl.equals(ourUrl);\n            log.info(\"SolrCore connected to ZooKeeper - we are \" + ourUrl + \" and leader is \" + leaderUrl);\n            cloudDesc.isLeader = isLeader;\n          }\n        }\n      }\n    });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor();\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this(cc, zkServerAddress, zkClientTimeout, zkClientConnectTimeout, localHost, locaHostPort, localHostContext, null, registerOnReconnect);\n  }\n\n","sourceOld":"  /**\n   * @param cc\n   * @param zkServerAddress\n   * @param zkClientTimeout\n   * @param zkClientConnectTimeout\n   * @param localHost\n   * @param locaHostPort\n   * @param localHostContext\n   * @param registerOnReconnect\n   * @throws InterruptedException\n   * @throws TimeoutException\n   * @throws IOException\n   */\n  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this(cc, zkServerAddress, zkClientTimeout, zkClientConnectTimeout, localHost, locaHostPort, localHostContext, null, registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9a98541130dbb2dd570f39bd89ced65760cad80","date":1355032328,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":null,"sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this(cc, zkServerAddress, zkClientTimeout, zkClientConnectTimeout, localHost, locaHostPort, localHostContext, null, registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,CurrentCoreDescriptorProvider).mjava","sourceNew":null,"sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    this(cc, zkServerAddress, zkClientTimeout, zkClientConnectTimeout, localHost, locaHostPort, localHostContext, null, registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"001b25b42373b22a52f399dbf072f1224632e8e6":["d6f074e73200c07d54f242d3880a8da5a35ff97b","adc2388a5005de25370273411bc713d0ff722805"],"adc2388a5005de25370273411bc713d0ff722805":["938e4fd7b1e4b34da1650edba7471764bbfaefde"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a80994db3380cd78c6f65b84515e2e931b6b3da","31fa604286b18a4e8e580658c67fa46cb82b798f"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["3a80994db3380cd78c6f65b84515e2e931b6b3da"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","f97bf7e60e8b1531f7e992482be43dd563dde04e"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["adc2388a5005de25370273411bc713d0ff722805"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["33d0ed80b7b47e34ad3ff033a77544563aba3085","32d5034e9ef94910c8cd2b01cc3c2be222453d0c"],"f9a98541130dbb2dd570f39bd89ced65760cad80":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","32d5034e9ef94910c8cd2b01cc3c2be222453d0c"],"32d5034e9ef94910c8cd2b01cc3c2be222453d0c":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["bec832dd3e463a3d19dd7ab614a84b1e719fc2b6"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","f97bf7e60e8b1531f7e992482be43dd563dde04e"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["a5093a9e893633cc091cf2f729d7863671c2b715"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["32d5034e9ef94910c8cd2b01cc3c2be222453d0c"],"407687e67faf6e1f02a211ca078d8e3eed631027":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","f9a98541130dbb2dd570f39bd89ced65760cad80"],"f97bf7e60e8b1531f7e992482be43dd563dde04e":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"31fa604286b18a4e8e580658c67fa46cb82b798f":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"bec832dd3e463a3d19dd7ab614a84b1e719fc2b6":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["001b25b42373b22a52f399dbf072f1224632e8e6","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a5093a9e893633cc091cf2f729d7863671c2b715","33d0ed80b7b47e34ad3ff033a77544563aba3085"],"a5093a9e893633cc091cf2f729d7863671c2b715":["31fa604286b18a4e8e580658c67fa46cb82b798f"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["f97bf7e60e8b1531f7e992482be43dd563dde04e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f9a98541130dbb2dd570f39bd89ced65760cad80"]},"commit2Childs":{"001b25b42373b22a52f399dbf072f1224632e8e6":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"adc2388a5005de25370273411bc713d0ff722805":["001b25b42373b22a52f399dbf072f1224632e8e6","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6b834dd353486678973f4157b3ba402ac3a7ca88":["bec832dd3e463a3d19dd7ab614a84b1e719fc2b6"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","05a14b2611ead08655a2b2bdc61632eb31316e57"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"f9a98541130dbb2dd570f39bd89ced65760cad80":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"32d5034e9ef94910c8cd2b01cc3c2be222453d0c":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","938e4fd7b1e4b34da1650edba7471764bbfaefde"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["f9a98541130dbb2dd570f39bd89ced65760cad80","407687e67faf6e1f02a211ca078d8e3eed631027"],"9813dd0748537c429b7c0a9b4723ea1ba496c047":["31fa604286b18a4e8e580658c67fa46cb82b798f"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["aba371508186796cc6151d8223a5b4e16d02e26e","32d5034e9ef94910c8cd2b01cc3c2be222453d0c","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"938e4fd7b1e4b34da1650edba7471764bbfaefde":["adc2388a5005de25370273411bc713d0ff722805","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"f97bf7e60e8b1531f7e992482be43dd563dde04e":["fd92b8bcc88e969302510acf77bd6970da3994c4","78a55f24d9b493c2a1cecf79f1d78279062b545b","3a80994db3380cd78c6f65b84515e2e931b6b3da"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"31fa604286b18a4e8e580658c67fa46cb82b798f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a5093a9e893633cc091cf2f729d7863671c2b715"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"bec832dd3e463a3d19dd7ab614a84b1e719fc2b6":["9813dd0748537c429b7c0a9b4723ea1ba496c047"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["001b25b42373b22a52f399dbf072f1224632e8e6"],"a5093a9e893633cc091cf2f729d7863671c2b715":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","f97bf7e60e8b1531f7e992482be43dd563dde04e","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fd92b8bcc88e969302510acf77bd6970da3994c4","78a55f24d9b493c2a1cecf79f1d78279062b545b","407687e67faf6e1f02a211ca078d8e3eed631027","8fd5be977c105554c6a7b68afcdbc511439723ab","05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}