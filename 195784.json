{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","commits":[{"id":"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","date":1522388336,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\"  + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + TestSearchRateAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\"  + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + TestSearchRateAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acfe8d3b837b6b66eaddf114bb99cf9e2257764d","date":1522406637,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\"  + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + TestSearchRateAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\"  + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + TestSearchRateAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108","date":1533256859,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6","date":1536060944,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'preferredOperation':'addreplica'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44dd40f6c2c1465aebf4677bab10f696c7ea18d8","date":1539566013,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    cluster.waitForAllNodes(5);\n\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    waitForState(\"Timed out waiting for collection:\" + collectionName + \" to become active\", collectionName, clusterShape(2, 2));\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":["35a328e6f64355319d0b316956c260b0be251aca","d4efaeae02b3e2e01b01b730016400d1811a31df"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/MetricTriggerIntegrationTest#testMetricTrigger().mjava","sourceNew":null,"sourceOld":"  @Test\n  // commented 4-Sep-2018 @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testMetricTrigger() throws Exception {\n    String collectionName = \"testMetricTrigger\";\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    solrClient.setDefaultCollection(collectionName);\n\n    cluster.waitForActiveCollection(collectionName, 2, 4);\n\n    DocCollection docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    String shardId = \"shard1\";\n    Replica replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    String coreName = replica.getCoreName();\n    String replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    long waitForSeconds = 2 + random().nextInt(5);\n    String registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    String tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"'\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"'\" +\n        \"'shard':'\" + shardId + \"'\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand1 = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'metric_trigger',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute', 'test'],\" +\n        \"'class' : '\" + TestTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand1);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    // start more nodes so that we have at least 4\n    for (int i = cluster.getJettySolrRunners().size(); i < 4; i++) {\n      cluster.startJettySolrRunner();\n    }\n    cluster.waitForAllNodes(10);\n\n    List<SolrInputDocument> docs = new ArrayList<>(500);\n    for (int i = 0; i < 500; i++) {\n      docs.add(new SolrInputDocument(\"id\", String.valueOf(i), \"x_s\", \"x\" + i));\n    }\n    solrClient.add(docs);\n    solrClient.commit();\n\n    boolean await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    CapturedEvent ev = listenerEvents.get(\"srt\").get(0);\n    long now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n\n    // find a new replica and create its metric name\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    replica = docCollection.getSlice(shardId).getReplicas().iterator().next();\n    coreName = replica.getCoreName();\n    replicaName = Utils.parseMetricsReplicaName(collectionName, coreName);\n    registry = SolrCoreMetricManager.createRegistryName(true, collectionName, shardId, replicaName, null);\n    tag = \"metrics:\" + registry + \":INDEX.sizeInBytes\";\n\n    triggerFiredLatch = new CountDownLatch(1);\n    listenerEvents.clear();\n\n    setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'metric_trigger',\" +\n        \"'event' : 'metric',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : true,\" +\n        \"'metric': '\" + tag + \"',\" +\n        \"'above' : 100.0,\" +\n        \"'collection': '\" + collectionName + \"',\" +\n        \"'shard':'\" + shardId + \"',\" +\n        \"'preferredOperation':'addreplica',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name':'test','class':'\" + MetricAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    await = triggerFiredLatch.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    // wait for listener to capture the SUCCEEDED stage\n    Thread.sleep(2000);\n    assertEquals(listenerEvents.toString(), 4, listenerEvents.get(\"srt\").size());\n    ev = listenerEvents.get(\"srt\").get(0);\n    now = timeSource.getTimeNs();\n    // verify waitFor\n    assertTrue(TimeUnit.SECONDS.convert(waitForSeconds, TimeUnit.NANOSECONDS) - WAIT_FOR_DELTA_NANOS <= now - ev.event.getEventTime());\n    assertEquals(collectionName, ev.event.getProperties().get(\"collection\"));\n    docCollection = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    assertEquals(5, docCollection.getReplicas().size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["89948af0461fead48f44ba8fb7866f107ce83f22"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4"],"89948af0461fead48f44ba8fb7866f107ce83f22":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["89948af0461fead48f44ba8fb7866f107ce83f22"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"f7f315cd0d0955ce9ca691cc8e2796af69c4b9b6":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"89948af0461fead48f44ba8fb7866f107ce83f22":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}