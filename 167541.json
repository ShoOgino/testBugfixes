{"path":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","commits":[{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    final Directory dir = writer.getDirectory();\n    MergeSpecification spec;\n    \n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      int numSegments = infos.size();\n      while(numSegments > 0) {\n        final SegmentInfo info = infos.info(--numSegments);\n        if (segmentsToOptimize.contains(info)) {\n          numSegments++;\n          break;\n        }\n      }\n\n      if (numSegments > 0) {\n\n        spec = new MergeSpecification();\n        while (numSegments > 0) {\n        \n          final int first;\n          if (numSegments > mergeFactor)\n            first = numSegments-mergeFactor;\n          else\n            first = 0;\n\n          if (numSegments > 1 || !isOptimized(writer, infos.info(0)))\n            spec.add(new OneMerge(infos.range(first, numSegments), useCompoundFile));\n\n          numSegments -= mergeFactor;\n        }\n\n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a1f29c9b1051488fd5fa7d56c98db5f4388408","date":1196281221,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","sourceNew":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n    \n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      int numSegments = infos.size();\n      while(numSegments > 0) {\n        final SegmentInfo info = infos.info(--numSegments);\n        if (segmentsToOptimize.contains(info)) {\n          numSegments++;\n          break;\n        }\n      }\n\n      if (numSegments > 0) {\n\n        spec = new MergeSpecification();\n        while (numSegments > 0) {\n        \n          final int first;\n          if (numSegments > mergeFactor)\n            first = numSegments-mergeFactor;\n          else\n            first = 0;\n\n          if (numSegments > 1 || !isOptimized(writer, infos.info(0)))\n            spec.add(new OneMerge(infos.range(first, numSegments), useCompoundFile));\n\n          numSegments -= mergeFactor;\n        }\n\n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","sourceOld":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    final Directory dir = writer.getDirectory();\n    MergeSpecification spec;\n    \n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      int numSegments = infos.size();\n      while(numSegments > 0) {\n        final SegmentInfo info = infos.info(--numSegments);\n        if (segmentsToOptimize.contains(info)) {\n          numSegments++;\n          break;\n        }\n      }\n\n      if (numSegments > 0) {\n\n        spec = new MergeSpecification();\n        while (numSegments > 0) {\n        \n          final int first;\n          if (numSegments > mergeFactor)\n            first = numSegments-mergeFactor;\n          else\n            first = 0;\n\n          if (numSegments > 1 || !isOptimized(writer, infos.info(0)))\n            spec.add(new OneMerge(infos.range(first, numSegments), useCompoundFile));\n\n          numSegments -= mergeFactor;\n        }\n\n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52e9359ec09a0ce311e6ce95805998bebc7f7fd0","date":1196417385,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","sourceNew":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(writer, infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","sourceOld":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n    \n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      int numSegments = infos.size();\n      while(numSegments > 0) {\n        final SegmentInfo info = infos.info(--numSegments);\n        if (segmentsToOptimize.contains(info)) {\n          numSegments++;\n          break;\n        }\n      }\n\n      if (numSegments > 0) {\n\n        spec = new MergeSpecification();\n        while (numSegments > 0) {\n        \n          final int first;\n          if (numSegments > mergeFactor)\n            first = numSegments-mergeFactor;\n          else\n            first = 0;\n\n          if (numSegments > 1 || !isOptimized(writer, infos.info(0)))\n            spec.add(new OneMerge(infos.range(first, numSegments), useCompoundFile));\n\n          numSegments -= mergeFactor;\n        }\n\n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13eaef7d286f35b5c850a1c2eb7b337679aa6453","date":1249118545,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,int,Set).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMergesForOptimize(SegmentInfos,IndexWriter,int,Set).mjava","sourceNew":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos,\n      int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","sourceOld":"  /** Returns the merges necessary to optimize the index.\n   *  This merge policy defines \"optimized\" to mean only one\n   *  segment in the index, where that segment has no\n   *  deletions pending nor separate norms, and it is in\n   *  compound file format if the current useCompoundFile\n   *  setting is true.  This method returns multiple merges\n   *  (mergeFactor at a time) so the {@link MergeScheduler}\n   *  in use may make use of concurrency. */\n  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {\n    MergeSpecification spec;\n\n    assert maxNumSegments > 0;\n\n    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {\n\n      // Find the newest (rightmost) segment that needs to\n      // be optimized (other segments may have been flushed\n      // since optimize started):\n      int last = infos.size();\n      while(last > 0) {\n        final SegmentInfo info = infos.info(--last);\n        if (segmentsToOptimize.contains(info)) {\n          last++;\n          break;\n        }\n      }\n\n      if (last > 0) {\n\n        spec = new MergeSpecification();\n\n        // First, enroll all \"full\" merges (size\n        // mergeFactor) to potentially be run concurrently:\n        while (last - maxNumSegments + 1 >= mergeFactor) {\n          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));\n          last -= mergeFactor;\n        }\n\n        // Only if there are no full merges pending do we\n        // add a final partial (< mergeFactor segments) merge:\n        if (0 == spec.merges.size()) {\n          if (maxNumSegments == 1) {\n\n            // Since we must optimize down to 1 segment, the\n            // choice is simple:\n            if (last > 1 || !isOptimized(writer, infos.info(0)))\n              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));\n          } else if (last > maxNumSegments) {\n\n            // Take care to pick a partial merge that is\n            // least cost, but does not make the index too\n            // lopsided.  If we always just picked the\n            // partial tail then we could produce a highly\n            // lopsided index over time:\n\n            // We must merge this many segments to leave\n            // maxNumSegments in the index (from when\n            // optimize was first kicked off):\n            final int finalMergeSize = last - maxNumSegments + 1;\n\n            // Consider all possible starting points:\n            long bestSize = 0;\n            int bestStart = 0;\n\n            for(int i=0;i<last-finalMergeSize+1;i++) {\n              long sumSize = 0;\n              for(int j=0;j<finalMergeSize;j++)\n                sumSize += size(infos.info(j+i));\n              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {\n                bestStart = i;\n                bestSize = sumSize;\n              }\n            }\n\n            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));\n          }\n        }\n        \n      } else\n        spec = null;\n    } else\n      spec = null;\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"52e9359ec09a0ce311e6ce95805998bebc7f7fd0":["b6a1f29c9b1051488fd5fa7d56c98db5f4388408"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["52e9359ec09a0ce311e6ce95805998bebc7f7fd0"],"b6a1f29c9b1051488fd5fa7d56c98db5f4388408":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"]},"commit2Childs":{"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["b6a1f29c9b1051488fd5fa7d56c98db5f4388408"],"52e9359ec09a0ce311e6ce95805998bebc7f7fd0":["13eaef7d286f35b5c850a1c2eb7b337679aa6453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"13eaef7d286f35b5c850a1c2eb7b337679aa6453":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b6a1f29c9b1051488fd5fa7d56c98db5f4388408":["52e9359ec09a0ce311e6ce95805998bebc7f7fd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}