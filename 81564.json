{"path":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","commits":[{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO), scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f703b580a38c8a12d78077283f2372b6f65312a0","date":1566551787,"type":3,"author":"Julie Tibshirani","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      double hitDistance = SloppyMath.haversinMeters(hit.distanceSortKey);\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hitDistance)});\n    }\n    return new TopFieldDocs(new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO), scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO), scoreDocs, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene86PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      double hitDistance = SloppyMath.haversinMeters(hit.distanceSortKey);\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hitDistance)});\n    }\n    return new TopFieldDocs(new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO), scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      double hitDistance = SloppyMath.haversinMeters(hit.distanceSortKey);\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hitDistance)});\n    }\n    return new TopFieldDocs(new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO), scoreDocs, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"88b0212386fe531136816706dc37dc49b9dbf7dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["f703b580a38c8a12d78077283f2372b6f65312a0"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"f703b580a38c8a12d78077283f2372b6f65312a0":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"]},"commit2Childs":{"88b0212386fe531136816706dc37dc49b9dbf7dc":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["f703b580a38c8a12d78077283f2372b6f65312a0"],"f703b580a38c8a12d78077283f2372b6f65312a0":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}