{"path":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","commits":[{"id":"464f6dced2dddb86ebb65fba95eb05169c1b2f7e","date":1372221866,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6220c823b73c9a8987debfba6a43b4b9dd10d0c","date":1374867434,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      //TODO Spatial4j 0.4 will have a direct constant\n      double multiplier = DistanceUtils.degrees2Dist(1, DistanceUtils.EARTH_MEAN_RADIUS_KM);\n      return strategy.makeDistanceValueSource(queryPoint, multiplier);\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      //TODO Spatial4j 0.4 will have a direct constant\n      double multiplier = DistanceUtils.degrees2Dist(1, DistanceUtils.EARTH_MEAN_RADIUS_KM);\n      return strategy.makeDistanceValueSource(queryPoint, multiplier);\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003","date":1390592414,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, DistanceUtils.DEG_TO_KM);\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      //TODO Spatial4j 0.4 will have a direct constant\n      double multiplier = DistanceUtils.degrees2Dist(1, DistanceUtils.EARTH_MEAN_RADIUS_KM);\n      return strategy.makeDistanceValueSource(queryPoint, multiplier);\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"167133992e7b384ce97f83ddb1dd2ddd09daf7aa","date":1420315776,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      if (distanceUnits == DistanceUnits.BACKCOMPAT)\n        distanceUnits = DistanceUnits.KILOMETERS;\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, DistanceUtils.DEG_TO_KM);\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"733eaf468f18297b1bcc51031353bdfdd1913bdf","date":1456928540,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      if (distanceUnits == DistanceUnits.BACKCOMPAT)\n        distanceUnits = DistanceUnits.KILOMETERS;\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      if (distanceUnits == DistanceUnits.BACKCOMPAT)\n        distanceUnits = DistanceUnits.KILOMETERS;\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32b9119890a8e82252b6cc341ac491d18fa1e49b","date":1498575219,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98f11c416d30e556e0004a9a84960702d12d35b1","date":1498628359,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit());\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d15ac50990498008d740f839a52fb37469515598","date":1566598728,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources;\n    try {\n      sources = fp.parseValueSourceList();\n    } catch (SolrException e) {\n      if (e.getMessage().equals(\"A ValueSource isn't directly available from this field. \" +\n          \"Instead try a query using the distance as the score.\")) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"geodist() does not support field names in its arguments \" +\n            \"when stated fields are solr.LatLonPointSpatialField spatial type, requires sfield param instead\");\n      }\n      else {\n        throw e;\n      }\n    }\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources = fp.parseValueSourceList();\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"254ec3078340f6312bb97bed5b76742a18079ec8","date":1600658388,"type":3,"author":"Tom Edge","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/function/distance/GeoDistValueSourceParser#parse(FunctionQParser).mjava","sourceNew":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: return fields as FieldNameValueSource from parser to support AbstractSpatialFieldType as geodist argument\n    List<ValueSource> sources = transformFieldSources(fp, fp.parseValueSourceList(FLAG_DEFAULT | FLAG_CONSUME_DELIMITER | FLAG_USE_FIELDNAME_SOURCE));\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    SpatialStrategyMultiValueSource spatialStrategyMultiValueSource = findSpatialStrategyMultiValueSource(mv1, mv2);\n    if (spatialStrategyMultiValueSource != null) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = spatialStrategyMultiValueSource.strategy;\n      DistanceUnits distanceUnits = spatialStrategyMultiValueSource.distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","sourceOld":"  @Override\n  public ValueSource parse(FunctionQParser fp) throws SyntaxError {\n    // TODO: dispatch through SpatialQueryable in the future?\n\n    //note: parseValueSourceList can't handle a field reference to an AbstractSpatialFieldType,\n    // so those fields are expressly handled via sfield=\n    List<ValueSource> sources;\n    try {\n      sources = fp.parseValueSourceList();\n    } catch (SolrException e) {\n      if (e.getMessage().equals(\"A ValueSource isn't directly available from this field. \" +\n          \"Instead try a query using the distance as the score.\")) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"geodist() does not support field names in its arguments \" +\n            \"when stated fields are solr.LatLonPointSpatialField spatial type, requires sfield param instead\");\n      }\n      else {\n        throw e;\n      }\n    }\n\n    // \"m\" is a multi-value source, \"x\" is a single-value source\n    // allow (m,m) (m,x,x) (x,x,m) (x,x,x,x)\n    // if not enough points are present, \"pt\" will be checked first, followed by \"sfield\".\n\n    MultiValueSource mv1 = null;\n    MultiValueSource mv2 = null;\n\n    if (sources.size() == 0) {\n      // nothing to do now\n    } else if (sources.size() == 1) {\n      ValueSource vs = sources.get(0);\n      if (!(vs instanceof MultiValueSource)) {\n        throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n      }\n      mv1 = (MultiValueSource)vs;\n    } else if (sources.size() == 2) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n\n      if (vs1 instanceof MultiValueSource && vs2 instanceof MultiValueSource) {\n        mv1 = (MultiValueSource)vs1;\n        mv2 = (MultiValueSource)vs2;\n      } else {\n        mv1 = makeMV(sources, sources);\n      }\n    } else if (sources.size()==3) {\n      ValueSource vs1 = sources.get(0);\n      ValueSource vs2 = sources.get(1);\n      if (vs1 instanceof MultiValueSource) {     // (m,x,x)\n        mv1 = (MultiValueSource)vs1;\n        mv2 = makeMV(sources.subList(1, 3), sources);\n      } else {                                   // (x,x,m)\n        mv1 = makeMV(sources.subList(0, 2), sources);\n        vs1 = sources.get(2);\n        if (!(vs1 instanceof MultiValueSource)) {\n          throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n        }\n        mv2 = (MultiValueSource)vs1;\n      }\n    } else if (sources.size()==4) {\n      mv1 = makeMV(sources.subList(0, 2), sources);\n      mv2 = makeMV(sources.subList(2, 4), sources);\n    } else if (sources.size() > 4) {\n      throw new SyntaxError(\"geodist - invalid parameters:\" + sources);\n    }\n\n    if (mv1 == null) {\n      mv1 = parsePoint(fp);\n      mv2 = parseSfield(fp);\n    } else if (mv2 == null) {\n      mv2 = parsePoint(fp);\n      if (mv2 == null)\n        mv2 = parseSfield(fp);\n    }\n\n    if (mv1 == null || mv2 == null) {\n      throw new SyntaxError(\"geodist - not enough parameters:\" + sources);\n    }\n\n    // We have all the parameters at this point, now check if one of the points is constant\n    double[] constants;//latLon\n    constants = getConstants(mv1);\n    MultiValueSource other = mv2;\n    if (constants == null) {\n      constants = getConstants(mv2);\n      other = mv1;\n    }\n\n    // At this point we dispatch to one of:\n    // * SpatialStrategy.makeDistanceValueSource\n    // * HaversineConstFunction\n    // * HaversineFunction\n\n    // sfield can only be in mv2, according to the logic above\n    if (mv2 instanceof SpatialStrategyMultiValueSource) {\n      if (constants == null)\n        throw new SyntaxError(\"When using AbstractSpatialFieldType (e.g. RPT not LatLonType),\" +\n            \" the point must be supplied as constants\");\n      // note: uses Haversine by default but can be changed via distCalc=...\n      SpatialStrategy strategy = ((SpatialStrategyMultiValueSource) mv2).strategy;\n      DistanceUnits distanceUnits = ((SpatialStrategyMultiValueSource) mv2).distanceUnits;\n      Point queryPoint = strategy.getSpatialContext().makePoint(constants[1], constants[0]);\n      return ValueSource.fromDoubleValuesSource(strategy.makeDistanceValueSource(queryPoint, distanceUnits.multiplierFromDegreesToThisUnit()));\n    }\n\n    if (constants != null && other instanceof VectorValueSource) {\n      return new HaversineConstFunction(constants[0], constants[1], (VectorValueSource)other);\n    }\n\n    return new HaversineFunction(mv1, mv2, DistanceUtils.EARTH_MEAN_RADIUS_KM, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a6220c823b73c9a8987debfba6a43b4b9dd10d0c"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","464f6dced2dddb86ebb65fba95eb05169c1b2f7e"],"a6220c823b73c9a8987debfba6a43b4b9dd10d0c":["464f6dced2dddb86ebb65fba95eb05169c1b2f7e"],"28288370235ed02234a64753cdbf0c6ec096304a":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","32b9119890a8e82252b6cc341ac491d18fa1e49b"],"464f6dced2dddb86ebb65fba95eb05169c1b2f7e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"32b9119890a8e82252b6cc341ac491d18fa1e49b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["a6220c823b73c9a8987debfba6a43b4b9dd10d0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["167133992e7b384ce97f83ddb1dd2ddd09daf7aa","733eaf468f18297b1bcc51031353bdfdd1913bdf"],"167133992e7b384ce97f83ddb1dd2ddd09daf7aa":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"733eaf468f18297b1bcc51031353bdfdd1913bdf":["167133992e7b384ce97f83ddb1dd2ddd09daf7aa"],"254ec3078340f6312bb97bed5b76742a18079ec8":["d15ac50990498008d740f839a52fb37469515598"],"d15ac50990498008d740f839a52fb37469515598":["28288370235ed02234a64753cdbf0c6ec096304a"],"98f11c416d30e556e0004a9a84960702d12d35b1":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","32b9119890a8e82252b6cc341ac491d18fa1e49b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["254ec3078340f6312bb97bed5b76742a18079ec8"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"a6220c823b73c9a8987debfba6a43b4b9dd10d0c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"28288370235ed02234a64753cdbf0c6ec096304a":["d15ac50990498008d740f839a52fb37469515598"],"464f6dced2dddb86ebb65fba95eb05169c1b2f7e":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a6220c823b73c9a8987debfba6a43b4b9dd10d0c"],"32b9119890a8e82252b6cc341ac491d18fa1e49b":["28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","464f6dced2dddb86ebb65fba95eb05169c1b2f7e"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["167133992e7b384ce97f83ddb1dd2ddd09daf7aa"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["28288370235ed02234a64753cdbf0c6ec096304a","32b9119890a8e82252b6cc341ac491d18fa1e49b","98f11c416d30e556e0004a9a84960702d12d35b1"],"167133992e7b384ce97f83ddb1dd2ddd09daf7aa":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","733eaf468f18297b1bcc51031353bdfdd1913bdf"],"733eaf468f18297b1bcc51031353bdfdd1913bdf":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"254ec3078340f6312bb97bed5b76742a18079ec8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d15ac50990498008d740f839a52fb37469515598":["254ec3078340f6312bb97bed5b76742a18079ec8"],"98f11c416d30e556e0004a9a84960702d12d35b1":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","98f11c416d30e556e0004a9a84960702d12d35b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}