{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","commits":[{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,int).mjava","sourceNew":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);;\n\n        String routerName = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerName);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","sourceOld":"      private ClusterState createCollection(ClusterState state, String collectionName, int numShards) {\n        log.info(\"Create collection {} with numShards {}\", collectionName, numShards);\n\n        DocRouter router = DocRouter.DEFAULT;\n        List<DocRouter.Range> ranges = router.partitionRange(numShards, router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);\n\n          Map<String,Object> sliceProps = new LinkedHashMap<String,Object>(1);\n          sliceProps.put(Slice.RANGE, ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = defaultCollectionProps();\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":1,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,int).mjava","sourceNew":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);;\n\n        String routerName = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerName);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","sourceOld":"      private ClusterState createCollection(ClusterState state, String collectionName, int numShards) {\n        log.info(\"Create collection {} with numShards {}\", collectionName, numShards);\n\n        DocRouter router = DocRouter.DEFAULT;\n        List<DocRouter.Range> ranges = router.partitionRange(numShards, router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);\n\n          Map<String,Object> sliceProps = new LinkedHashMap<String,Object>(1);\n          sliceProps.put(Slice.RANGE, ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = defaultCollectionProps();\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e187a371a1d09379bb452c2c13a7b9221525dff8","date":1379517004,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);;\n\n//        String routerName = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        DocRouter router = DocRouter.getDocRouter(message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME));\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, DocRouter.getRouterSpec(message));\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","sourceOld":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);;\n\n        String routerName = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerName);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":["9eafdca347a58310b9b997a3154436991e98999b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9eafdca347a58310b9b997a3154436991e98999b","date":1380716528,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","sourceOld":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);;\n\n//        String routerName = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        DocRouter router = DocRouter.getDocRouter(message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME));\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, DocRouter.getRouterSpec(message));\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":["1eeda7e62e149f90eee8895af874c74efa7d4852","e187a371a1d09379bb452c2c13a7b9221525dff8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc841231667f1f315bae6799c068f9aad6543967","date":1381415189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","sourceOld":"      private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40dce2b6d4360eb09fa16fb6c40a18b25507ed73","date":1383035822,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70","date":1386334715,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n//        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n//        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n//        newCollections.put(collectionName, newCollection);\n          return state.copyWith(singletonMap(newCollection.getName(), newCollection));\n//        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n//        return newClusterState;\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n//        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n//        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n//        newCollections.put(collectionName, newCollection);\n          return state.copyWith(singletonMap(newCollection.getName(), newCollection));\n//        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n//        return newClusterState;\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n        newCollections.put(collectionName, newCollection);\n        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n//        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n//        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n//        newCollections.put(collectionName, newCollection);\n          return state.copyWith(singletonMap(newCollection.getName(), newCollection));\n//        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n//        return newClusterState;\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n//        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<String,Slice>();\n//        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<String, Object>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<String,Object>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n//        newCollections.put(collectionName, newCollection);\n          return state.copyWith(singletonMap(newCollection.getName(), newCollection));\n//        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n//        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n        isClusterStateModified = true;\n        log.info(\"_extern {} {}\", collectionName, newCollection.isExternal());\n        if (newCollection.isExternal()) {\n          updateNodes.put(ZkStateReader.getCollectionPath(collectionName),\n              new ClusterState(-1, Collections.<String>emptySet(), singletonMap(newCollection.getName(), newCollection), state.getStateReader()));\n          return state;\n        }\n\n        return newState(state, singletonMap(newCollection.getName(), newCollection));\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n//        Map<String, DocCollection> newCollections = new LinkedHashMap<String,DocCollection>();\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n//        newCollections.putAll(state.getCollectionStates());\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n        /*}\n        for (int i = 0; i < numShards; i++) {\n          final String sliceName = \"shard\" + (i+1);*/\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n\n//        newCollections.put(collectionName, newCollection);\n          return state.copyWith(singletonMap(newCollection.getName(), newCollection));\n//        ClusterState newClusterState = new ClusterState(state.getLiveNodes(), newCollections);\n//        return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n        return newState(state, singletonMap(newCollection.getName(), newCollection));\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n        isClusterStateModified = true;\n        log.info(\"_extern {} {}\", collectionName, newCollection.isExternal());\n        if (newCollection.isExternal()) {\n          updateNodes.put(ZkStateReader.getCollectionPath(collectionName),\n              new ClusterState(-1, Collections.<String>emptySet(), singletonMap(newCollection.getName(), newCollection), state.getStateReader()));\n          return state;\n        }\n\n        return newState(state, singletonMap(newCollection.getName(), newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n      if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n      String znode = message.getInt(DocCollection.STATE_FORMAT, 1) == 1 ? null : ZkStateReader.getCollectionPath(collectionName);\n      DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router , -1,znode);\n      isClusterStateModified = true;\n      log.info(\"state version {} {}\", collectionName, newCollection.getStateFormat());\n      if (newCollection.getStateFormat() > 1) {\n        updateNodes.put(ZkStateReader.getCollectionPath(collectionName),\n            new ClusterState(-1, Collections.<String>emptySet(), singletonMap(newCollection.getName(), newCollection), state.getStateReader()));\n        return state;\n      }\n      return newState(state, singletonMap(newCollection.getName(), newCollection));\n    }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n        return newState(state, singletonMap(newCollection.getName(), newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n        return newState(state, singletonMap(newCollection.getName(), newCollection));\n      }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n      if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n      String znode = message.getInt(DocCollection.STATE_FORMAT, 1) == 1 ? null : ZkStateReader.getCollectionPath(collectionName);\n      DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router , -1,znode);\n      isClusterStateModified = true;\n      log.info(\"state version {} {}\", collectionName, newCollection.getStateFormat());\n      if (newCollection.getStateFormat() > 1) {\n        updateNodes.put(ZkStateReader.getCollectionPath(collectionName),\n            new ClusterState(-1, Collections.<String>emptySet(), singletonMap(newCollection.getName(), newCollection), state.getStateReader()));\n        return state;\n      }\n      return newState(state, singletonMap(newCollection.getName(), newCollection));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n      if (message.getStr(\"fromApi\") == null) {\n        collectionProps.put(\"autoCreated\", \"true\");\n      }\n      \n      String znode = message.getInt(DocCollection.STATE_FORMAT, 1) == 1 ? null\n          : ZkStateReader.getCollectionPath(collectionName);\n      \n      DocCollection newCollection = new DocCollection(collectionName,\n          newSlices, collectionProps, router, -1, znode);\n      \n      isClusterStateModified = true;\n      \n      log.info(\"state version {} {}\", collectionName, newCollection.getStateFormat());\n      \n      return newState(state, singletonMap(newCollection.getName(), newCollection));\n    }\n\n","sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n        if(message.getStr(\"fromApi\") == null) collectionProps.put(\"autoCreated\",\"true\");\n        DocCollection newCollection = new DocCollection(collectionName, newSlices, collectionProps, router);\n        return newState(state, singletonMap(newCollection.getName(), newCollection));\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#createCollection(ClusterState,String,List[String],ZkNodeProps).mjava","sourceNew":null,"sourceOld":"    private ClusterState createCollection(ClusterState state, String collectionName, List<String> shards , ZkNodeProps message) {\n        log.info(\"Create collection {} with shards {}\", collectionName, shards);\n\n        Map<String, Object> routerSpec = DocRouter.getRouterSpec(message);\n        String routerName = routerSpec.get(\"name\") == null ? DocRouter.DEFAULT_NAME : (String) routerSpec.get(\"name\");\n        DocRouter router = DocRouter.getDocRouter(routerName);\n\n        List<DocRouter.Range> ranges = router.partitionRange(shards.size(), router.fullRange());\n\n\n\n        Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n        for (int i = 0; i < shards.size(); i++) {\n          String sliceName = shards.get(i);\n\n          Map<String, Object> sliceProps = new LinkedHashMap<>(1);\n          sliceProps.put(Slice.RANGE, ranges == null? null: ranges.get(i));\n\n          newSlices.put(sliceName, new Slice(sliceName, null, sliceProps));\n        }\n\n        // TODO: fill in with collection properties read from the /collections/<collectionName> node\n        Map<String,Object> collectionProps = new HashMap<>();\n\n        for (Entry<String, Object> e : OverseerCollectionProcessor.COLL_PROPS.entrySet()) {\n          Object val = message.get(e.getKey());\n          if(val == null){\n            val = OverseerCollectionProcessor.COLL_PROPS.get(e.getKey());\n          }\n          if(val != null) collectionProps.put(e.getKey(),val);\n        }\n        collectionProps.put(DocCollection.DOC_ROUTER, routerSpec);\n\n      if (message.getStr(\"fromApi\") == null) {\n        collectionProps.put(\"autoCreated\", \"true\");\n      }\n      \n      String znode = message.getInt(DocCollection.STATE_FORMAT, 1) == 1 ? null\n          : ZkStateReader.getCollectionPath(collectionName);\n      \n      DocCollection newCollection = new DocCollection(collectionName,\n          newSlices, collectionProps, router, -1, znode);\n      \n      isClusterStateModified = true;\n      \n      log.info(\"state version {} {}\", collectionName, newCollection.getStateFormat());\n      \n      return newState(state, singletonMap(newCollection.getName(), newCollection));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1eeda7e62e149f90eee8895af874c74efa7d4852"],"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"9eafdca347a58310b9b997a3154436991e98999b":["e187a371a1d09379bb452c2c13a7b9221525dff8"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"bc841231667f1f315bae6799c068f9aad6543967":["9eafdca347a58310b9b997a3154436991e98999b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e187a371a1d09379bb452c2c13a7b9221525dff8":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73","ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["bc841231667f1f315bae6799c068f9aad6543967"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"9eafdca347a58310b9b997a3154436991e98999b":["bc841231667f1f315bae6799c068f9aad6543967"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","e187a371a1d09379bb452c2c13a7b9221525dff8"],"9279b175e5e66258442d2123a50f052219a9cc1b":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"bc841231667f1f315bae6799c068f9aad6543967":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","1eeda7e62e149f90eee8895af874c74efa7d4852"],"e187a371a1d09379bb452c2c13a7b9221525dff8":["9eafdca347a58310b9b997a3154436991e98999b"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["ce7cfca1a733d2ed1f7089b339faf006bdcc7b70","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}