{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","commits":[{"id":"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a","date":1524514741,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","pathOld":"/dev/null","sourceNew":"  private void calculateColdOps(List<TriggerEvent.Op> ops,\n                                ClusterState clusterState,\n                                Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                                Map<String, Double> coldNodes,\n                                Map<String, Double> coldCollections,\n                                Map<String, Map<String, Double>> coldShards,\n                                List<ReplicaInfo> coldReplicas) {\n    // COLD COLLECTIONS\n    // Probably can't do anything reasonable about whole cold collections\n    // because they may be needed even if not used.\n\n    // COLD SHARDS:\n    // Cold shards mean that there are too many replicas per shard - but it also\n    // means that all replicas in these shards are cold too, so we can simply\n    // address this by deleting cold replicas\n\n    // COLD REPLICAS:\n    // Remove cold replicas but only when there's at least a minimum number of searchable\n    // replicas still available (additional non-searchable replicas may exist, too)\n    // NOTE: do this before adding ops for DELETENODE because we don't want to attempt\n    // deleting replicas that have been already moved elsewhere\n    Map<String, Map<String, List<ReplicaInfo>>> byCollectionByShard = new HashMap<>();\n    coldReplicas.forEach(ri -> {\n      byCollectionByShard.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n          .computeIfAbsent(ri.getShard(), s -> new ArrayList<>())\n          .add(ri);\n    });\n    byCollectionByShard.forEach((coll, shards) -> {\n      shards.forEach((shard, replicas) -> {\n        // only delete if there's at least minRF searchable replicas left\n        int rf = searchableReplicationFactors.get(coll).get(shard).get();\n        // we only really need a leader and we may be allowed to remove other replicas\n        int minRF = 1;\n        // but check the official RF and don't go below that\n        Integer RF = clusterState.getCollection(coll).getReplicationFactor();\n        if (RF != null) {\n          minRF = RF;\n        }\n        // unless minReplicas is set explicitly\n        if (minReplicas != null) {\n          minRF = minReplicas;\n        }\n        if (minRF < 1) {\n          minRF = 1;\n        }\n        if (rf > minRF) {\n          // delete at most maxOps replicas at a time\n          AtomicInteger limit = new AtomicInteger(Math.min(maxOps, rf - minRF));\n          replicas.forEach(ri -> {\n            if (limit.get() == 0) {\n              return;\n            }\n            // don't delete a leader\n            if (ri.getBool(ZkStateReader.LEADER_PROP, false)) {\n              return;\n            }\n            TriggerEvent.Op op = new TriggerEvent.Op(belowOp,\n                Suggester.Hint.COLL_SHARD, new Pair<>(ri.getCollection(), ri.getShard()));\n            op.addHint(Suggester.Hint.REPLICA, ri.getName());\n            ops.add(op);\n            limit.decrementAndGet();\n          });\n        }\n      });\n    });\n\n    // COLD NODES:\n    // Unlike the case of hot nodes, if a node is cold then any monitored\n    // collections / shards / replicas located on that node are cold, too.\n    // HOWEVER, we check only non-pull replicas and only from selected collections / shards,\n    // so deleting a cold node is dangerous because it may interfere with these\n    // non-monitored resources - this is the reason the default belowNodeOp is null / ignored.\n    //\n    // Also, note that due to the way activity is measured only nodes that contain any\n    // monitored resources are considered - there may be cold nodes in the cluster that don't\n    // belong to the monitored collections and they will be ignored.\n    if (belowNodeOp != null) {\n      coldNodes.forEach((node, rate) -> {\n        ops.add(new TriggerEvent.Op(belowNodeOp, Suggester.Hint.SRC_NODE, node));\n      });\n    }\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],Set[String],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/SearchRateTrigger#calculateColdOps(List[TriggerEvent.Op],ClusterState,Map[String,Map[String,AtomicInteger]],Map[String,Double],Map[String,Double],Map[String,Map[String,Double]],List[ReplicaInfo]).mjava","sourceNew":"  private void calculateColdOps(List<TriggerEvent.Op> ops,\n                                Set<String> violations,\n                                ClusterState clusterState,\n                                Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                                Map<String, Double> coldNodes,\n                                Map<String, Double> coldCollections,\n                                Map<String, Map<String, Double>> coldShards,\n                                List<ReplicaInfo> coldReplicas) {\n    // COLD COLLECTIONS\n    // Probably can't do anything reasonable about whole cold collections\n    // because they may be needed even if not used.\n\n    // COLD SHARDS & COLD REPLICAS:\n    // We remove cold replicas only from cold shards, otherwise we are susceptible to uneven\n    // replica routing (which is beyond our control).\n    // If we removed replicas from non-cold shards we could accidentally bring that shard into\n    // the hot range, which would result in adding replica, and that replica could again stay cold due to\n    // the same routing issue, which then would lead to removing that replica, etc, etc...\n\n    // Remove cold replicas but only when there's at least a minimum number of searchable\n    // replicas still available (additional non-searchable replicas may exist, too)\n    // NOTE: do this before adding ops for DELETENODE because we don't want to attempt\n    // deleting replicas that have been already moved elsewhere\n    Map<String, Map<String, List<ReplicaInfo>>> byCollectionByShard = new HashMap<>();\n    coldReplicas.forEach(ri -> {\n      byCollectionByShard.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n          .computeIfAbsent(ri.getShard(), s -> new ArrayList<>())\n          .add(ri);\n    });\n    coldShards.forEach((coll, perShard) -> {\n      perShard.forEach((shard, rate) -> {\n        List<ReplicaInfo> replicas = byCollectionByShard\n            .getOrDefault(coll, Collections.emptyMap())\n            .getOrDefault(shard, Collections.emptyList());\n        if (replicas.isEmpty()) {\n          return;\n        }\n        // only delete if there's at least minRF searchable replicas left\n        int rf = searchableReplicationFactors.get(coll).get(shard).get();\n        // assume first that we only really need a leader and we may be\n        // allowed to remove other replicas\n        int minRF = 1;\n        // but check the official RF and don't go below that\n        Integer RF = clusterState.getCollection(coll).getReplicationFactor();\n        if (RF != null) {\n          minRF = RF;\n        }\n        // unless minReplicas is set explicitly\n        if (minReplicas != null) {\n          minRF = minReplicas;\n        }\n        if (minRF < 1) {\n          minRF = 1;\n        }\n        if (rf > minRF) {\n          // delete at most maxOps replicas at a time\n          AtomicInteger limit = new AtomicInteger(Math.min(maxOps, rf - minRF));\n          replicas.forEach(ri -> {\n            if (limit.get() == 0) {\n              return;\n            }\n            // don't delete a leader\n            if (ri.getBool(ZkStateReader.LEADER_PROP, false)) {\n              return;\n            }\n            TriggerEvent.Op op = new TriggerEvent.Op(belowOp,\n                Suggester.Hint.COLL_SHARD, new Pair<>(ri.getCollection(), ri.getShard()));\n            op.addHint(Suggester.Hint.REPLICA, ri.getName());\n            ops.add(op);\n            violations.add(COLD_SHARDS);\n            limit.decrementAndGet();\n          });\n        }\n      });\n    });\n\n    // COLD NODES:\n    // Unlike the case of hot nodes, if a node is cold then any monitored\n    // collections / shards / replicas located on that node are cold, too.\n    // HOWEVER, we check only replicas from selected collections / shards,\n    // so deleting a cold node is dangerous because it may interfere with these\n    // non-monitored resources - this is the reason the default belowNodeOp is null / ignored.\n    //\n    // Also, note that due to the way activity is measured only nodes that contain any\n    // monitored resources are considered - there may be cold nodes in the cluster that don't\n    // belong to the monitored collections and they will be ignored.\n    if (belowNodeOp != null) {\n      coldNodes.forEach((node, rate) -> {\n        ops.add(new TriggerEvent.Op(belowNodeOp, Suggester.Hint.SRC_NODE, node));\n        violations.add(COLD_NODES);\n      });\n    }\n\n\n  }\n\n","sourceOld":"  private void calculateColdOps(List<TriggerEvent.Op> ops,\n                                ClusterState clusterState,\n                                Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,\n                                Map<String, Double> coldNodes,\n                                Map<String, Double> coldCollections,\n                                Map<String, Map<String, Double>> coldShards,\n                                List<ReplicaInfo> coldReplicas) {\n    // COLD COLLECTIONS\n    // Probably can't do anything reasonable about whole cold collections\n    // because they may be needed even if not used.\n\n    // COLD SHARDS:\n    // Cold shards mean that there are too many replicas per shard - but it also\n    // means that all replicas in these shards are cold too, so we can simply\n    // address this by deleting cold replicas\n\n    // COLD REPLICAS:\n    // Remove cold replicas but only when there's at least a minimum number of searchable\n    // replicas still available (additional non-searchable replicas may exist, too)\n    // NOTE: do this before adding ops for DELETENODE because we don't want to attempt\n    // deleting replicas that have been already moved elsewhere\n    Map<String, Map<String, List<ReplicaInfo>>> byCollectionByShard = new HashMap<>();\n    coldReplicas.forEach(ri -> {\n      byCollectionByShard.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())\n          .computeIfAbsent(ri.getShard(), s -> new ArrayList<>())\n          .add(ri);\n    });\n    byCollectionByShard.forEach((coll, shards) -> {\n      shards.forEach((shard, replicas) -> {\n        // only delete if there's at least minRF searchable replicas left\n        int rf = searchableReplicationFactors.get(coll).get(shard).get();\n        // we only really need a leader and we may be allowed to remove other replicas\n        int minRF = 1;\n        // but check the official RF and don't go below that\n        Integer RF = clusterState.getCollection(coll).getReplicationFactor();\n        if (RF != null) {\n          minRF = RF;\n        }\n        // unless minReplicas is set explicitly\n        if (minReplicas != null) {\n          minRF = minReplicas;\n        }\n        if (minRF < 1) {\n          minRF = 1;\n        }\n        if (rf > minRF) {\n          // delete at most maxOps replicas at a time\n          AtomicInteger limit = new AtomicInteger(Math.min(maxOps, rf - minRF));\n          replicas.forEach(ri -> {\n            if (limit.get() == 0) {\n              return;\n            }\n            // don't delete a leader\n            if (ri.getBool(ZkStateReader.LEADER_PROP, false)) {\n              return;\n            }\n            TriggerEvent.Op op = new TriggerEvent.Op(belowOp,\n                Suggester.Hint.COLL_SHARD, new Pair<>(ri.getCollection(), ri.getShard()));\n            op.addHint(Suggester.Hint.REPLICA, ri.getName());\n            ops.add(op);\n            limit.decrementAndGet();\n          });\n        }\n      });\n    });\n\n    // COLD NODES:\n    // Unlike the case of hot nodes, if a node is cold then any monitored\n    // collections / shards / replicas located on that node are cold, too.\n    // HOWEVER, we check only non-pull replicas and only from selected collections / shards,\n    // so deleting a cold node is dangerous because it may interfere with these\n    // non-monitored resources - this is the reason the default belowNodeOp is null / ignored.\n    //\n    // Also, note that due to the way activity is measured only nodes that contain any\n    // monitored resources are considered - there may be cold nodes in the cluster that don't\n    // belong to the monitored collections and they will be ignored.\n    if (belowNodeOp != null) {\n      coldNodes.forEach((node, rate) -> {\n        ops.add(new TriggerEvent.Op(belowNodeOp, Suggester.Hint.SRC_NODE, node));\n      });\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"]},"commit2Childs":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}