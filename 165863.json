{"path":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","commits":[{"id":"1807cf7ff48453a48bc28608f557e16b6a1f7fa8","date":1464474872,"type":1,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d07e72ae82c4a8060ef4ab6f67af62bbf556c252","date":1464596663,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da8a02bef7458089240404614139b53c9f875ec7","date":1464597207,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7","date":1490708104,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(altText.substring(0, alternateFieldLen - len)) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57df4f31144a04dc0e8382aed10ebfa82ef71a4d","date":1490873945,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(altText.substring(0, alternateFieldLen - len)) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a9aeb4a98b03660f065aa31f6b3f2251a12b613","date":1581405488,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(SolrDocument,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(SolrDocument doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    List<String> listFields = getFieldValues(doc, alternateField, Integer.MAX_VALUE, Integer.MAX_VALUE, req);\n    if (listFields.isEmpty()) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      listFields = getFieldValues(doc, fieldName, Integer.MAX_VALUE, Integer.MAX_VALUE, req);\n      if (listFields.isEmpty()) {\n        return null;\n      }\n    }\n\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(altText.substring(0, alternateFieldLen - len)) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(altText.substring(0, alternateFieldLen - len)) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da8a02bef7458089240404614139b53c9f875ec7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d07e72ae82c4a8060ef4ab6f67af62bbf556c252"],"1807cf7ff48453a48bc28608f557e16b6a1f7fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d07e72ae82c4a8060ef4ab6f67af62bbf556c252":["1807cf7ff48453a48bc28608f557e16b6a1f7fa8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57df4f31144a04dc0e8382aed10ebfa82ef71a4d":["d07e72ae82c4a8060ef4ab6f67af62bbf556c252"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d07e72ae82c4a8060ef4ab6f67af62bbf556c252"],"2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7":["d07e72ae82c4a8060ef4ab6f67af62bbf556c252"],"1a9aeb4a98b03660f065aa31f6b3f2251a12b613":["2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d07e72ae82c4a8060ef4ab6f67af62bbf556c252"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1a9aeb4a98b03660f065aa31f6b3f2251a12b613"]},"commit2Childs":{"da8a02bef7458089240404614139b53c9f875ec7":[],"1807cf7ff48453a48bc28608f557e16b6a1f7fa8":["d07e72ae82c4a8060ef4ab6f67af62bbf556c252"],"d07e72ae82c4a8060ef4ab6f67af62bbf556c252":["da8a02bef7458089240404614139b53c9f875ec7","57df4f31144a04dc0e8382aed10ebfa82ef71a4d","5b8ee93140fd0efef7e101786e3ed5160a700b5f","2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["da8a02bef7458089240404614139b53c9f875ec7","1807cf7ff48453a48bc28608f557e16b6a1f7fa8","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"57df4f31144a04dc0e8382aed10ebfa82ef71a4d":[],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":[],"2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7":["1a9aeb4a98b03660f065aa31f6b3f2251a12b613"],"1a9aeb4a98b03660f065aa31f6b3f2251a12b613":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["da8a02bef7458089240404614139b53c9f875ec7","57df4f31144a04dc0e8382aed10ebfa82ef71a4d","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}