{"path":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","commits":[{"id":"849083f8095b1ffaff05a66e0b1e024617b9968d","date":1536291524,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (preemptiveCreationExecutor == null) {\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb","date":1543645563,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","sourceNew":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!executorRunning) {\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (preemptiveCreationExecutor == null) {\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff8a68c1177ac430ec03832a6e1c969b8a5b902","date":1543786480,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","sourceNew":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (preemptiveCreationExecutor == null) {\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!executorRunning) {\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6","date":1547236077,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","sourceNew":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.info(\"EXECUTING preemptive creation for {}\", timeRoutedAlias.getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (preemptiveCreationExecutor == null) {\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":5,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#createCollectionsIfRequired(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessor#createCollectionsIfRequired(Instant,AddUpdateCommand).mjava","sourceNew":"  @Override\n  public String createCollectionsIfRequired(AddUpdateCommand cmd) {\n    SolrQueryRequest req = cmd.getReq();\n    SolrCore core = req.getCore();\n    CoreContainer coreContainer = core.getCoreContainer();\n    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();\n    final Instant docTimestamp =\n        parseRouteKey(cmd.getSolrInputDocument().getFieldValue(getRouteField()));\n\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd, candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.debug(\"Executing preemptive creation for {}\", getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create any required collections and return the name of the collection to which the current document should be sent.\n   *\n   * @param docTimestamp the date for the document taken from the field specified in the TRA config\n   * @param cmd The initial calculated destination collection.\n   * @return The name of the proper destination collection for the document which may or may not be a\n   *         newly created collection\n   */\n  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {\n    // Even though it is possible that multiple requests hit this code in the 1-2 sec that\n    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number\n    // of client connections. This in mind, we only guard against spamming the overseer within a batch of\n    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most\n    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants\n    // probably don't write to the same alias. As such, we have deferred any solution to the \"many clients causing\n    // collection creation simultaneously\" problem until such time as someone actually has that problem in a\n    // real world use case that isn't just an anti-pattern.\n    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());\n    String candidateCollectionName = candidateCollectionDesc.getValue();\n    try {\n      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {\n        case SYNCHRONOUS:\n          // This next line blocks until all collections required by the current document have been created\n          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);\n        case ASYNC_PREEMPTIVE:\n          if (!preemptiveCreateOnceAlready) {\n            log.info(\"EXECUTING preemptive creation for {}\", timeRoutedAlias.getAliasName());\n            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()\n            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc\n            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed\n            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of\n            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2\n            // instead of collection n+1.\n            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();\n\n            // This line does not block and the document can be added immediately\n            preemptiveAsync(() -> createNextCollection(mostRecentCollName));\n          }\n          return candidateCollectionName;\n        case NONE:\n          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.\n        default:\n          throw unknownCreateType();\n      }\n      // do nothing if creationType == NONE\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"849083f8095b1ffaff05a66e0b1e024617b9968d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"5ff8a68c1177ac430ec03832a6e1c969b8a5b902":["98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["5ff8a68c1177ac430ec03832a6e1c969b8a5b902"],"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b627755385655c7cd3fb296f17593658805cf4d5"]},"commit2Childs":{"849083f8095b1ffaff05a66e0b1e024617b9968d":["98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["849083f8095b1ffaff05a66e0b1e024617b9968d"],"b627755385655c7cd3fb296f17593658805cf4d5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ff8a68c1177ac430ec03832a6e1c969b8a5b902":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["b627755385655c7cd3fb296f17593658805cf4d5"],"98b0091cfdf4ea4fd1e69c120a6dd42cefb7afeb":["5ff8a68c1177ac430ec03832a6e1c969b8a5b902"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}