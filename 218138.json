{"path":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","commits":[{"id":"e1eb6b3ce884c0b9e064e112da158013ec33cd91","date":1402692077,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db84ab77f343feb0bdb7f34a8e69054309b3457c","date":1408137380,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      if (c == Class.class) {\n        // prevent inspection of Class' fields, throws SecurityException in Java 9!\n        continue; \n      }\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4383b91725e5b335d0a9d5f24b122b813dddd0cc","date":1442106431,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      if (c == Class.class) {\n        // prevent inspection of Class' fields, throws SecurityException in Java 9!\n        continue; \n      }\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            final PrivilegedAction<Field> act = () -> { f.setAccessible(true); return f; };\n            referenceFields.add(AccessController.doPrivileged(act));\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      if (c == Class.class) {\n        // prevent inspection of Class' fields, throws SecurityException in Java 9!\n        continue; \n      }\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            f.setAccessible(true);\n            referenceFields.add(f);\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aebe8d5e20ab1cc228524e49817ff2d0cb3de1e3","date":1442108737,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              f.setAccessible(true);\n              referenceFields.add(f);\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    ClassCache cachedInfo;\n    long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n    final ArrayList<Field> referenceFields = new ArrayList<>(32);\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n      if (c == Class.class) {\n        // prevent inspection of Class' fields, throws SecurityException in Java 9!\n        continue; \n      }\n      final Field[] fields = c.getDeclaredFields();\n      for (final Field f : fields) {\n        if (!Modifier.isStatic(f.getModifiers())) {\n          shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n\n          if (!f.getType().isPrimitive()) {\n            final PrivilegedAction<Field> act = () -> { f.setAccessible(true); return f; };\n            referenceFields.add(AccessController.doPrivileged(act));\n          }\n        }\n      }\n    }\n\n    cachedInfo = new ClassCache(\n        RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n        referenceFields.toArray(new Field[referenceFields.size()]));\n    return cachedInfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"772af34227438013872590cf48fd0a96c4057704","date":1482972983,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                if (\"java.lang.reflect.InaccessibleObjectException\".equals(re.getClass().getName())) {\n                  // LUCENE-7595: this is Java 9, which prevents access to fields in foreign modules\n                } else {\n                  throw re;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              f.setAccessible(true);\n              referenceFields.add(f);\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                if (\"java.lang.reflect.InaccessibleObjectException\".equals(re.getClass().getName())) {\n                  // LUCENE-7595: this is Java 9, which prevents access to fields in foreign modules\n                } else {\n                  throw re;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              f.setAccessible(true);\n              referenceFields.add(f);\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0509386580032996a559871d20e73d0ab67a5be","date":1547724210,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                throw new RuntimeException(String.format(Locale.ROOT,\n                    \"Can't access field %s of class %s for RAM estimation.\",\n                    f.toString(),\n                    c.getName()), re);\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                if (\"java.lang.reflect.InaccessibleObjectException\".equals(re.getClass().getName())) {\n                  // LUCENE-7595: this is Java 9, which prevents access to fields in foreign modules\n                } else {\n                  throw re;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","bugFix":null,"bugIntro":["015fe54423e69e4d1c2fe80205f847d915d36413"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"015fe54423e69e4d1c2fe80205f847d915d36413","date":1547726736,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                if (\"java.lang.reflect.InaccessibleObjectException\".equals(re.getClass().getName())) {\n                  // LUCENE-7595: this is Java 9, which prevents access to fields in foreign modules\n                } else {\n                  throw re;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                throw new RuntimeException(String.format(Locale.ROOT,\n                    \"Can't access field %s of class %s for RAM estimation.\",\n                    f.toString(),\n                    c.getName()), re);\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","bugFix":["e0509386580032996a559871d20e73d0ab67a5be"],"bugIntro":["8913cb9a44846cb65e41bee682ba0372f1636056"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8913cb9a44846cb65e41bee682ba0372f1636056","date":1547808953,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#createCacheEntry(Class[#]).mjava","sourceNew":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                throw new RuntimeException(String.format(Locale.ROOT,\n                    \"Can't access field '%s' of class '%s' for RAM estimation.\",\n                    f.getName(),\n                    clazz.getName()), re);\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","sourceOld":"  /**\n   * Create a cached information about shallow size and reference fields for \n   * a given class.\n   */\n  @SuppressForbidden(reason = \"We need to access private fields of measured objects.\")\n  private static ClassCache createCacheEntry(final Class<?> clazz) {\n    return AccessController.doPrivileged((PrivilegedAction<ClassCache>) () -> {\n      ClassCache cachedInfo;\n      long shallowInstanceSize = RamUsageEstimator.NUM_BYTES_OBJECT_HEADER;\n      final ArrayList<Field> referenceFields = new ArrayList<>(32);\n      for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        if (c == Class.class) {\n          // prevent inspection of Class' fields, throws SecurityException in Java 9!\n          continue; \n        }\n        final Field[] fields = c.getDeclaredFields();\n        for (final Field f : fields) {\n          if (!Modifier.isStatic(f.getModifiers())) {\n            shallowInstanceSize = RamUsageEstimator.adjustForField(shallowInstanceSize, f);\n  \n            if (!f.getType().isPrimitive()) {\n              try {\n                f.setAccessible(true);\n                referenceFields.add(f);\n              } catch (RuntimeException re) {\n                if (\"java.lang.reflect.InaccessibleObjectException\".equals(re.getClass().getName())) {\n                  // LUCENE-7595: this is Java 9, which prevents access to fields in foreign modules\n                } else {\n                  throw re;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n      cachedInfo = new ClassCache(\n          RamUsageEstimator.alignObjectSize(shallowInstanceSize), \n          referenceFields.toArray(new Field[referenceFields.size()]));\n      return cachedInfo;\n    });\n  }\n\n","bugFix":["015fe54423e69e4d1c2fe80205f847d915d36413"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aebe8d5e20ab1cc228524e49817ff2d0cb3de1e3":["4383b91725e5b335d0a9d5f24b122b813dddd0cc"],"db84ab77f343feb0bdb7f34a8e69054309b3457c":["e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"8913cb9a44846cb65e41bee682ba0372f1636056":["015fe54423e69e4d1c2fe80205f847d915d36413"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4383b91725e5b335d0a9d5f24b122b813dddd0cc":["db84ab77f343feb0bdb7f34a8e69054309b3457c"],"772af34227438013872590cf48fd0a96c4057704":["aebe8d5e20ab1cc228524e49817ff2d0cb3de1e3"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"015fe54423e69e4d1c2fe80205f847d915d36413":["e0509386580032996a559871d20e73d0ab67a5be"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e0509386580032996a559871d20e73d0ab67a5be":["772af34227438013872590cf48fd0a96c4057704"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8913cb9a44846cb65e41bee682ba0372f1636056"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["aebe8d5e20ab1cc228524e49817ff2d0cb3de1e3","772af34227438013872590cf48fd0a96c4057704"]},"commit2Childs":{"aebe8d5e20ab1cc228524e49817ff2d0cb3de1e3":["772af34227438013872590cf48fd0a96c4057704","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"db84ab77f343feb0bdb7f34a8e69054309b3457c":["4383b91725e5b335d0a9d5f24b122b813dddd0cc"],"8913cb9a44846cb65e41bee682ba0372f1636056":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"4383b91725e5b335d0a9d5f24b122b813dddd0cc":["aebe8d5e20ab1cc228524e49817ff2d0cb3de1e3"],"772af34227438013872590cf48fd0a96c4057704":["e0509386580032996a559871d20e73d0ab67a5be","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["db84ab77f343feb0bdb7f34a8e69054309b3457c","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"015fe54423e69e4d1c2fe80205f847d915d36413":["8913cb9a44846cb65e41bee682ba0372f1636056"],"e0509386580032996a559871d20e73d0ab67a5be":["015fe54423e69e4d1c2fe80205f847d915d36413"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}