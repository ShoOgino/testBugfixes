{"path":"solr/core/src/test/org/apache/solr/search/TestCaffeineCache#testSetLimits().mjava","commits":[{"id":"87f0484c38f986062889ed50f3bf3bd462848c26","date":1570108628,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestCaffeineCache#testSetLimits().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSetLimits() throws Exception {\n    AtomicReference<CountDownLatch> removed = new AtomicReference<>(new CountDownLatch(2));\n    List<RemovalCause> removalCauses = new ArrayList<>();\n    List<String> removedKeys = new ArrayList<>();\n    Set<String> allKeys = new HashSet<>();\n    CaffeineCache<String, Accountable> cache = new CaffeineCache<>() {\n      @Override\n      public Accountable put(String key, Accountable val) {\n        allKeys.add(key);\n        return super.put(key, val);\n      }\n\n      @Override\n      public void onRemoval(String key, Accountable value, RemovalCause cause) {\n        super.onRemoval(key, value, cause);\n        removalCauses.add(cause);\n        removedKeys.add(key);\n        removed.get().countDown();\n      }\n    };\n    Map<String, String> params = new HashMap<>();\n    params.put(\"size\", \"5\");\n    cache.init(params, null, new NoOpRegenerator());\n\n    for (int i = 0; i < 5; i++) {\n      cache.put(\"foo-\" + i, new Accountable() {\n        @Override\n        public long ramBytesUsed() {\n          return 1024 * 1024;\n        }\n      });\n    }\n    assertEquals(5, cache.size());\n    // no evictions yet\n    assertEquals(2, removed.get().getCount());\n\n    cache.put(\"abc1\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 1;\n      }\n    });\n    cache.put(\"abc2\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 2;\n      }\n    });\n    boolean await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(5, cache.size());\n    assertEquals(2, cache.get(\"abc2\").ramBytesUsed());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    removed.set(new CountDownLatch(2));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by item count\n    cache.setMaxSize(3);\n    cache.put(\"abc3\",  new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 3;\n      }\n    });\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(3, cache.size());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    // at least one item has to go\n    removed.set(new CountDownLatch(1));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by ram size\n    cache.setMaxRamMB(1);\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n    // check total size of remaining items\n    long total = 0;\n    for (String key : allKeys) {\n      Accountable a = cache.get(key);\n      assertNotNull(\"missing value for key \" + key, a);\n      total += a.ramBytesUsed();\n    }\n    assertTrue(\"total ram bytes should be greater than 0\", total > 0);\n    assertTrue(\"total ram bytes exceeded limit\", total < 1024 * 1024);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestCaffeineCache#testSetLimits().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSetLimits() throws Exception {\n    AtomicReference<CountDownLatch> removed = new AtomicReference<>(new CountDownLatch(2));\n    List<RemovalCause> removalCauses = new ArrayList<>();\n    List<String> removedKeys = new ArrayList<>();\n    Set<String> allKeys = new HashSet<>();\n    CaffeineCache<String, Accountable> cache = new CaffeineCache<>() {\n      @Override\n      public Accountable put(String key, Accountable val) {\n        allKeys.add(key);\n        return super.put(key, val);\n      }\n\n      @Override\n      public void onRemoval(String key, Accountable value, RemovalCause cause) {\n        super.onRemoval(key, value, cause);\n        removalCauses.add(cause);\n        removedKeys.add(key);\n        removed.get().countDown();\n      }\n    };\n    Map<String, String> params = new HashMap<>();\n    params.put(\"size\", \"5\");\n    cache.init(params, null, new NoOpRegenerator());\n\n    for (int i = 0; i < 5; i++) {\n      cache.put(\"foo-\" + i, new Accountable() {\n        @Override\n        public long ramBytesUsed() {\n          return 1024 * 1024;\n        }\n      });\n    }\n    assertEquals(5, cache.size());\n    // no evictions yet\n    assertEquals(2, removed.get().getCount());\n\n    cache.put(\"abc1\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 1;\n      }\n    });\n    cache.put(\"abc2\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 2;\n      }\n    });\n    boolean await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(5, cache.size());\n    assertEquals(2, cache.get(\"abc2\").ramBytesUsed());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    removed.set(new CountDownLatch(2));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by item count\n    cache.setMaxSize(3);\n    cache.put(\"abc3\",  new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 3;\n      }\n    });\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(3, cache.size());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    // at least one item has to go\n    removed.set(new CountDownLatch(1));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by ram size\n    cache.setMaxRamMB(1);\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n    // check total size of remaining items\n    long total = 0;\n    for (String key : allKeys) {\n      Accountable a = cache.get(key);\n      assertNotNull(\"missing value for key \" + key, a);\n      total += a.ramBytesUsed();\n    }\n    assertTrue(\"total ram bytes should be greater than 0\", total > 0);\n    assertTrue(\"total ram bytes exceeded limit\", total < 1024 * 1024);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","date":1571411704,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestCaffeineCache#testSetLimits().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestCaffeineCache#testSetLimits().mjava","sourceNew":"  @Test\n  public void testSetLimits() throws Exception {\n    AtomicReference<CountDownLatch> removed = new AtomicReference<>(new CountDownLatch(2));\n    List<RemovalCause> removalCauses = new ArrayList<>();\n    List<String> removedKeys = new ArrayList<>();\n    Set<String> allKeys = new HashSet<>();\n    CaffeineCache<String, Accountable> cache = new CaffeineCache<>() {\n      @Override\n      public Accountable put(String key, Accountable val) {\n        allKeys.add(key);\n        return super.put(key, val);\n      }\n\n      @Override\n      public void onRemoval(String key, Accountable value, RemovalCause cause) {\n        super.onRemoval(key, value, cause);\n        removalCauses.add(cause);\n        removedKeys.add(key);\n        removed.get().countDown();\n      }\n    };\n    Map<String, String> params = new HashMap<>();\n    params.put(\"size\", \"5\");\n    cache.init(params, null, new NoOpRegenerator());\n\n    for (int i = 0; i < 5; i++) {\n      cache.put(\"foo-\" + i, new Accountable() {\n        @Override\n        public long ramBytesUsed() {\n          return 1024 * 1024;\n        }\n      });\n    }\n    assertEquals(5, cache.size());\n    // no evictions yet\n    assertEquals(2, removed.get().getCount());\n\n    cache.put(\"abc1\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 1;\n      }\n    });\n    cache.put(\"abc2\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 2;\n      }\n    });\n    boolean await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(5, cache.size());\n    assertEquals(2, cache.get(\"abc2\").ramBytesUsed());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    removed.set(new CountDownLatch(2));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by item count\n    cache.setMaxSize(3);\n    cache.put(\"abc3\",  new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 3;\n      }\n    });\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(3, cache.size());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    // at least one item has to go\n    removed.set(new CountDownLatch(1));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by ram size\n    cache.setMaxRamMB(1);\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n    // check total size of remaining items\n    long total = 0;\n    for (String key : allKeys) {\n      Accountable a = cache.get(key);\n      assertNotNull(\"missing value for key \" + key, a);\n      total += a.ramBytesUsed();\n    }\n    assertTrue(\"total ram bytes should be greater than 0\", total > 0);\n    assertTrue(\"total ram bytes exceeded limit\", total < 1024 * 1024);\n    cache.close();\n  }\n\n","sourceOld":"  @Test\n  public void testSetLimits() throws Exception {\n    AtomicReference<CountDownLatch> removed = new AtomicReference<>(new CountDownLatch(2));\n    List<RemovalCause> removalCauses = new ArrayList<>();\n    List<String> removedKeys = new ArrayList<>();\n    Set<String> allKeys = new HashSet<>();\n    CaffeineCache<String, Accountable> cache = new CaffeineCache<>() {\n      @Override\n      public Accountable put(String key, Accountable val) {\n        allKeys.add(key);\n        return super.put(key, val);\n      }\n\n      @Override\n      public void onRemoval(String key, Accountable value, RemovalCause cause) {\n        super.onRemoval(key, value, cause);\n        removalCauses.add(cause);\n        removedKeys.add(key);\n        removed.get().countDown();\n      }\n    };\n    Map<String, String> params = new HashMap<>();\n    params.put(\"size\", \"5\");\n    cache.init(params, null, new NoOpRegenerator());\n\n    for (int i = 0; i < 5; i++) {\n      cache.put(\"foo-\" + i, new Accountable() {\n        @Override\n        public long ramBytesUsed() {\n          return 1024 * 1024;\n        }\n      });\n    }\n    assertEquals(5, cache.size());\n    // no evictions yet\n    assertEquals(2, removed.get().getCount());\n\n    cache.put(\"abc1\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 1;\n      }\n    });\n    cache.put(\"abc2\", new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 2;\n      }\n    });\n    boolean await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(5, cache.size());\n    assertEquals(2, cache.get(\"abc2\").ramBytesUsed());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    removed.set(new CountDownLatch(2));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by item count\n    cache.setMaxSize(3);\n    cache.put(\"abc3\",  new Accountable() {\n      @Override\n      public long ramBytesUsed() {\n        return 3;\n      }\n    });\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    assertEquals(3, cache.size());\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n\n    // at least one item has to go\n    removed.set(new CountDownLatch(1));\n    removalCauses.clear();\n    removedKeys.clear();\n    // trim down by ram size\n    cache.setMaxRamMB(1);\n    await = removed.get().await(30, TimeUnit.SECONDS);\n    assertTrue(\"did not evict entries in in time\", await);\n    for (String key : removedKeys) {\n      assertNull(\"key \" + key + \" still present!\", cache.get(key));\n      allKeys.remove(key);\n    }\n    for (RemovalCause cause : removalCauses) {\n      assertEquals(RemovalCause.SIZE, cause);\n    }\n    // check total size of remaining items\n    long total = 0;\n    for (String key : allKeys) {\n      Accountable a = cache.get(key);\n      assertNotNull(\"missing value for key \" + key, a);\n      total += a.ramBytesUsed();\n    }\n    assertTrue(\"total ram bytes should be greater than 0\", total > 0);\n    assertTrue(\"total ram bytes exceeded limit\", total < 1024 * 1024);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["87f0484c38f986062889ed50f3bf3bd462848c26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"87f0484c38f986062889ed50f3bf3bd462848c26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","87f0484c38f986062889ed50f3bf3bd462848c26"]},"commit2Childs":{"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["87f0484c38f986062889ed50f3bf3bd462848c26","b0b597c65628ca9e73913a07e81691f8229bae35"],"87f0484c38f986062889ed50f3bf3bd462848c26":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}