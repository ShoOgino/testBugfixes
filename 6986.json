{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","commits":[{"id":"7266c313bb3b4fbcde3dcc82556182e1fae90080","date":1400183760,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          compiledAutomaton.lightAutomaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          compiledAutomaton.automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          compiledAutomaton.lightAutomaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          compiledAutomaton.automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitions.length-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          currentFrame.curTransitionMax = currentFrame.transitions[currentFrame.transitionIndex].getMax();\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    //if (DEBUG) {\n    //  System.out.println(\"\\nintEnum.next seg=\" + fr.parent.segment);\n    //  System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix + \" trans: \" + currentFrame.transition + \" useAutoPrefix=\" + useAutoPrefixTerm);\n    //}\n\n    nextTerm:\n    while (true) {\n\n      boolean isSubBlock;\n\n      if (useAutoPrefixTerm) {\n\n        assert currentFrame.isAutoPrefixTerm;\n        useAutoPrefixTerm = false;\n        currentFrame.termState.isRealTerm = true;\n\n        //if (DEBUG) {\n        //  System.out.println(\"    now scan beyond auto-prefix term=\" + brToString(term) + \" floorSuffixLeadEnd=\" + Integer.toHexString(currentFrame.floorSuffixLeadEnd));\n        //}\n        // If we last returned an auto-prefix term, we must now skip all\n        // actual terms sharing that prefix.  At most, that skipping\n        // requires popping one frame, but it can also require simply\n        // scanning ahead within the current frame.  This scanning will\n        // skip sub-blocks that contain many terms, which is why the\n        // optimization \"works\":\n        int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n        if (floorSuffixLeadEnd == -1) {\n          // An ordinary prefix, e.g. foo*\n          int prefix = currentFrame.prefix;\n          int suffix = currentFrame.suffix;\n          //if (DEBUG) System.out.println(\"    prefix=\" + prefix + \" suffix=\" + suffix);\n          if (suffix == 0) {\n            //if (DEBUG) System.out.println(\"    pop frame & nextTerm\");\n\n            // Easy case: the prefix term's suffix is the empty string,\n            // meaning the prefix corresponds to all terms in the\n            // current block, so we just pop this entire block:\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            continue nextTerm;\n          } else {\n\n            // Just next() until we hit an entry that doesn't share this\n            // prefix.  The first next should be a sub-block sharing the\n            // same prefix, because if there are enough terms matching a\n            // given prefix to warrant an auto-prefix term, then there\n            // must also be enough to make a sub-block (assuming\n            // minItemsInPrefix > minItemsInBlock):\n            scanPrefix:\n            while (true) {\n              //if (DEBUG) System.out.println(\"    scan next\");\n              if (currentFrame.nextEnt == currentFrame.entCount) {\n                if (currentFrame.isLastInFloor == false) {\n                  currentFrame.loadNextFloorBlock();\n                } else if (currentFrame.ord == 0) {\n                  //if (DEBUG) System.out.println(\"  return null0\");\n                  return null;\n                } else {\n                  // Pop frame, which also means we've moved beyond this\n                  // auto-prefix term:\n                  //if (DEBUG) System.out.println(\"  pop; nextTerm\");\n                  currentFrame = stack[currentFrame.ord-1];\n                  continue nextTerm;\n                }\n              }\n              isSubBlock = currentFrame.next();\n              //if (DEBUG) {\n              //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);\n              //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);\n              //  suffixBytes.length = currentFrame.suffix;\n              //  System.out.println(\"      currentFrame.suffix=\" + brToString(suffixBytes));\n              //}\n              for(int i=0;i<suffix;i++) {\n                if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n                  //if (DEBUG) System.out.println(\"      done; now stop scan\");\n                  break scanPrefix;\n                }\n              }\n            }\n          }\n        } else {\n          // Floor'd auto-prefix term; in this case we must skip all\n          // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n          // which the automaton accepted (fooa* through foom*), and\n          // floorSuffixLeadEnd is m, so we must now scan to foon:\n          int prefix = currentFrame.prefix;\n          int suffix = currentFrame.suffix;\n\n          if (currentFrame.floorSuffixLeadStart == -1) {\n            suffix++;\n          }\n\n          //if (DEBUG) System.out.println(\"      prefix=\" + prefix + \" suffix=\" + suffix);\n\n          if (suffix == 0) {\n\n            //if (DEBUG) System.out.println(\"  pop frame\");\n\n            // This means current frame is fooa*, so we have to first\n            // pop the current frame, then scan in parent frame:\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n\n            // Current (parent) frame is now foo*, so now we just scan\n            // until the lead suffix byte is > floorSuffixLeadEnd\n            //assert currentFrame.prefix == prefix-1;\n            //prefix = currentFrame.prefix;\n\n            // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n            // its first term = floor prefix term 41[7-9], popping to block 4*:\n            prefix = currentFrame.prefix;\n\n            suffix = term.length - currentFrame.prefix;\n          } else {\n            // No need to pop; just scan in currentFrame:\n          }\n\n          //if (DEBUG) System.out.println(\"    start scan: prefix=\" + prefix + \" suffix=\" + suffix);\n\n          // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n          scanFloor:\n          while (true) {\n            //if (DEBUG) System.out.println(\"      scan next\");\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (currentFrame.isLastInFloor == false) {\n                //if (DEBUG) System.out.println(\"      next floor block\");\n                currentFrame.loadNextFloorBlock();\n              } else if (currentFrame.ord == 0) {\n                //if (DEBUG) System.out.println(\"  return null\");\n                return null;\n              } else {\n                // Pop frame, which also means we've moved beyond this\n                // auto-prefix term:\n                currentFrame = stack[currentFrame.ord-1];\n                //if (DEBUG) System.out.println(\"      pop, now curFrame.prefix=\" + currentFrame.prefix);\n                continue nextTerm;\n              }\n            }\n            isSubBlock = currentFrame.next();\n            //if (DEBUG) {\n            //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);\n            //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);\n            //  suffixBytes.length = currentFrame.suffix;\n            //  System.out.println(\"      currentFrame.suffix=\" + brToString(suffixBytes));\n            //}\n            for(int i=0;i<suffix-1;i++) {\n              if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n                //if (DEBUG) System.out.println(\"      done; now stop scan\");\n                break scanFloor;\n              }\n            }\n            //if (DEBUG) {\n            //  if (currentFrame.suffix >= suffix) {\n            //    System.out.println(\"      cmp label=\" + Integer.toHexString(currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]) + \" vs \" + floorSuffixLeadEnd);\n            //  }\n            //}\n            if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n              // Done scanning: we are now on the first term after all\n              // terms matched by this auto-prefix term\n              //if (DEBUG) System.out.println(\"      done; now stop scan\");\n              break;\n            }\n          }\n        }\n      } else {\n        // Pop finished frames\n        while (currentFrame.nextEnt == currentFrame.entCount) {\n          if (!currentFrame.isLastInFloor) {\n            //if (DEBUG) System.out.println(\"    next-floor-block: trans: \" + currentFrame.transition);\n            // Advance to next floor block\n            currentFrame.loadNextFloorBlock();\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix);\n            break;\n          } else {\n            //if (DEBUG) System.out.println(\"  pop frame\");\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            final long lastFP = currentFrame.fpOrig;\n            currentFrame = stack[currentFrame.ord-1];\n            assert currentFrame.lastSubFP == lastFP;\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix);\n          }\n        }\n\n        isSubBlock = currentFrame.next();\n      }\n\n      //if (DEBUG) {\n      //  final BytesRef suffixRef = new BytesRef();\n      //  suffixRef.bytes = currentFrame.suffixBytes;\n      //  suffixRef.offset = currentFrame.startBytePos;\n      //  suffixRef.length = currentFrame.suffix;\n      //  System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      //}\n\n      if (currentFrame.suffix != 0) {\n        // Advance where we are in the automaton to match what terms\n        // dict next'd to:\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        //if (DEBUG) {\n        //  System.out.println(\"    move automaton to label=\" + label + \" vs curMax=\" + currentFrame.curTransitionMax);\n        // }\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans\");\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans\");\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (commonSuffix != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < commonSuffix.length) {\n          // No match\n          //if (DEBUG) System.out.println(\"      skip: common suffix length\");\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n        final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n        assert commonSuffix.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              //if (DEBUG) System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = commonSuffix.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            //if (DEBUG) System.out.println(\"      skip: common suffix mismatch\");\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // TODO: for first iter of this loop can't we just use the current trans?  we already advanced it and confirmed it matches lead\n      // byte of the suffix\n\n      // See if the term suffix matches the automaton:\n      int state = currentFrame.state;\n      int lastState = currentFrame.lastState;\n      //if (DEBUG) {\n      //  System.out.println(\"  a state=\" + state + \" curFrame.suffix.len=\" + currentFrame.suffix + \" curFrame.prefix=\" + currentFrame.prefix);\n      // }\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        lastState = state;\n        //if (DEBUG) System.out.println(\"    step label=\" + (char) (currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff));\n        state = runAutomaton.step(state, currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    after suffix: state=\" + state + \" lastState=\" + lastState);\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentFrame.lastState = lastState;\n        //xif (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                //if (DEBUG) System.out.println(\"      state is accept\");\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          //if (DEBUG) System.out.println(\"  useAutoPrefixTerm=\" + useAutoPrefixTerm);\n\n          if (useAutoPrefixTerm) {\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            //if (DEBUG) System.out.println(\"  return auto prefix term: \" + brToString(term));\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state);\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        //if (DEBUG) System.out.println(\"      return term=\" + brToString(term));\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          compiledAutomaton.automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n\n    //if (DEBUG) {\n    //  System.out.println(\"\\nintEnum.next seg=\" + fr.parent.segment);\n    //  System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix + \" trans: \" + currentFrame.transition + \" useAutoPrefix=\" + useAutoPrefixTerm);\n    //}\n\n    nextTerm:\n    while (true) {\n\n      boolean isSubBlock;\n\n      if (useAutoPrefixTerm) {\n\n        assert currentFrame.isAutoPrefixTerm;\n        useAutoPrefixTerm = false;\n        currentFrame.termState.isRealTerm = true;\n\n        //if (DEBUG) {\n        //  System.out.println(\"    now scan beyond auto-prefix term=\" + brToString(term) + \" floorSuffixLeadEnd=\" + Integer.toHexString(currentFrame.floorSuffixLeadEnd));\n        //}\n        // If we last returned an auto-prefix term, we must now skip all\n        // actual terms sharing that prefix.  At most, that skipping\n        // requires popping one frame, but it can also require simply\n        // scanning ahead within the current frame.  This scanning will\n        // skip sub-blocks that contain many terms, which is why the\n        // optimization \"works\":\n        int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n        if (floorSuffixLeadEnd == -1) {\n          // An ordinary prefix, e.g. foo*\n          int prefix = currentFrame.prefix;\n          int suffix = currentFrame.suffix;\n          //if (DEBUG) System.out.println(\"    prefix=\" + prefix + \" suffix=\" + suffix);\n          if (suffix == 0) {\n            //if (DEBUG) System.out.println(\"    pop frame & nextTerm\");\n\n            // Easy case: the prefix term's suffix is the empty string,\n            // meaning the prefix corresponds to all terms in the\n            // current block, so we just pop this entire block:\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            continue nextTerm;\n          } else {\n\n            // Just next() until we hit an entry that doesn't share this\n            // prefix.  The first next should be a sub-block sharing the\n            // same prefix, because if there are enough terms matching a\n            // given prefix to warrant an auto-prefix term, then there\n            // must also be enough to make a sub-block (assuming\n            // minItemsInPrefix > minItemsInBlock):\n            scanPrefix:\n            while (true) {\n              //if (DEBUG) System.out.println(\"    scan next\");\n              if (currentFrame.nextEnt == currentFrame.entCount) {\n                if (currentFrame.isLastInFloor == false) {\n                  currentFrame.loadNextFloorBlock();\n                } else if (currentFrame.ord == 0) {\n                  //if (DEBUG) System.out.println(\"  return null0\");\n                  return null;\n                } else {\n                  // Pop frame, which also means we've moved beyond this\n                  // auto-prefix term:\n                  //if (DEBUG) System.out.println(\"  pop; nextTerm\");\n                  currentFrame = stack[currentFrame.ord-1];\n                  continue nextTerm;\n                }\n              }\n              isSubBlock = currentFrame.next();\n              //if (DEBUG) {\n              //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);\n              //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);\n              //  suffixBytes.length = currentFrame.suffix;\n              //  System.out.println(\"      currentFrame.suffix=\" + brToString(suffixBytes));\n              //}\n              for(int i=0;i<suffix;i++) {\n                if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n                  //if (DEBUG) System.out.println(\"      done; now stop scan\");\n                  break scanPrefix;\n                }\n              }\n            }\n          }\n        } else {\n          // Floor'd auto-prefix term; in this case we must skip all\n          // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n          // which the automaton accepted (fooa* through foom*), and\n          // floorSuffixLeadEnd is m, so we must now scan to foon:\n          int prefix = currentFrame.prefix;\n          int suffix = currentFrame.suffix;\n\n          if (currentFrame.floorSuffixLeadStart == -1) {\n            suffix++;\n          }\n\n          //if (DEBUG) System.out.println(\"      prefix=\" + prefix + \" suffix=\" + suffix);\n\n          if (suffix == 0) {\n\n            //if (DEBUG) System.out.println(\"  pop frame\");\n\n            // This means current frame is fooa*, so we have to first\n            // pop the current frame, then scan in parent frame:\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n\n            // Current (parent) frame is now foo*, so now we just scan\n            // until the lead suffix byte is > floorSuffixLeadEnd\n            //assert currentFrame.prefix == prefix-1;\n            //prefix = currentFrame.prefix;\n\n            // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n            // its first term = floor prefix term 41[7-9], popping to block 4*:\n            prefix = currentFrame.prefix;\n\n            suffix = term.length - currentFrame.prefix;\n          } else {\n            // No need to pop; just scan in currentFrame:\n          }\n\n          //if (DEBUG) System.out.println(\"    start scan: prefix=\" + prefix + \" suffix=\" + suffix);\n\n          // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n          scanFloor:\n          while (true) {\n            //if (DEBUG) System.out.println(\"      scan next\");\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (currentFrame.isLastInFloor == false) {\n                //if (DEBUG) System.out.println(\"      next floor block\");\n                currentFrame.loadNextFloorBlock();\n              } else if (currentFrame.ord == 0) {\n                //if (DEBUG) System.out.println(\"  return null\");\n                return null;\n              } else {\n                // Pop frame, which also means we've moved beyond this\n                // auto-prefix term:\n                currentFrame = stack[currentFrame.ord-1];\n                //if (DEBUG) System.out.println(\"      pop, now curFrame.prefix=\" + currentFrame.prefix);\n                continue nextTerm;\n              }\n            }\n            isSubBlock = currentFrame.next();\n            //if (DEBUG) {\n            //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);\n            //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);\n            //  suffixBytes.length = currentFrame.suffix;\n            //  System.out.println(\"      currentFrame.suffix=\" + brToString(suffixBytes));\n            //}\n            for(int i=0;i<suffix-1;i++) {\n              if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n                //if (DEBUG) System.out.println(\"      done; now stop scan\");\n                break scanFloor;\n              }\n            }\n            //if (DEBUG) {\n            //  if (currentFrame.suffix >= suffix) {\n            //    System.out.println(\"      cmp label=\" + Integer.toHexString(currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]) + \" vs \" + floorSuffixLeadEnd);\n            //  }\n            //}\n            if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n              // Done scanning: we are now on the first term after all\n              // terms matched by this auto-prefix term\n              //if (DEBUG) System.out.println(\"      done; now stop scan\");\n              break;\n            }\n          }\n        }\n      } else {\n        // Pop finished frames\n        while (currentFrame.nextEnt == currentFrame.entCount) {\n          if (!currentFrame.isLastInFloor) {\n            //if (DEBUG) System.out.println(\"    next-floor-block: trans: \" + currentFrame.transition);\n            // Advance to next floor block\n            currentFrame.loadNextFloorBlock();\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix);\n            break;\n          } else {\n            //if (DEBUG) System.out.println(\"  pop frame\");\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            final long lastFP = currentFrame.fpOrig;\n            currentFrame = stack[currentFrame.ord-1];\n            assert currentFrame.lastSubFP == lastFP;\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix);\n          }\n        }\n\n        isSubBlock = currentFrame.next();\n      }\n\n      //if (DEBUG) {\n      //  final BytesRef suffixRef = new BytesRef();\n      //  suffixRef.bytes = currentFrame.suffixBytes;\n      //  suffixRef.offset = currentFrame.startBytePos;\n      //  suffixRef.length = currentFrame.suffix;\n      //  System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      //}\n\n      if (currentFrame.suffix != 0) {\n        // Advance where we are in the automaton to match what terms\n        // dict next'd to:\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        //if (DEBUG) {\n        //  System.out.println(\"    move automaton to label=\" + label + \" vs curMax=\" + currentFrame.curTransitionMax);\n        // }\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans\");\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans\");\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (commonSuffix != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < commonSuffix.length) {\n          // No match\n          //if (DEBUG) System.out.println(\"      skip: common suffix length\");\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n        final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n        assert commonSuffix.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              //if (DEBUG) System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = commonSuffix.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            //if (DEBUG) System.out.println(\"      skip: common suffix mismatch\");\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // TODO: for first iter of this loop can't we just use the current trans?  we already advanced it and confirmed it matches lead\n      // byte of the suffix\n\n      // See if the term suffix matches the automaton:\n      int state = currentFrame.state;\n      int lastState = currentFrame.lastState;\n      //if (DEBUG) {\n      //  System.out.println(\"  a state=\" + state + \" curFrame.suffix.len=\" + currentFrame.suffix + \" curFrame.prefix=\" + currentFrame.prefix);\n      // }\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        lastState = state;\n        //if (DEBUG) System.out.println(\"    step label=\" + (char) (currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff));\n        state = runAutomaton.step(state, currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    after suffix: state=\" + state + \" lastState=\" + lastState);\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentFrame.lastState = lastState;\n        //xif (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                //if (DEBUG) System.out.println(\"      state is accept\");\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          //if (DEBUG) System.out.println(\"  useAutoPrefixTerm=\" + useAutoPrefixTerm);\n\n          if (useAutoPrefixTerm) {\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            //if (DEBUG) System.out.println(\"  return auto prefix term: \" + brToString(term));\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state);\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        //if (DEBUG) System.out.println(\"      return term=\" + brToString(term));\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nintEnum.next seg=\" + segment);\n    //   System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n    // }\n\n    nextTerm:\n    while(true) {\n      // Pop finished frames\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        if (!currentFrame.isLastInFloor) {\n          //if (DEBUG) System.out.println(\"    next-floor-block\");\n          currentFrame.loadNextFloorBlock();\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        } else {\n          //if (DEBUG) System.out.println(\"  pop frame\");\n          if (currentFrame.ord == 0) {\n            return null;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert currentFrame.lastSubFP == lastFP;\n          //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n        }\n      }\n\n      final boolean isSubBlock = currentFrame.next();\n      // if (DEBUG) {\n      //   final BytesRef suffixRef = new BytesRef();\n      //   suffixRef.bytes = currentFrame.suffixBytes;\n      //   suffixRef.offset = currentFrame.startBytePos;\n      //   suffixRef.length = currentFrame.suffix;\n      //   System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      // }\n\n      if (currentFrame.suffix != 0) {\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Stop processing this frame -- no further\n            // matches are possible because we've moved\n            // beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]));\n\n            // sneaky!  forces a pop above\n            currentFrame.isLastInFloor = true;\n            currentFrame.nextEnt = currentFrame.entCount;\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          compiledAutomaton.automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans=\" + currentFrame.transitions[currentFrame.transitionIndex]);\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (compiledAutomaton.commonSuffixRef != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < compiledAutomaton.commonSuffixRef.length) {\n          // No match\n          // if (DEBUG) {\n          //   System.out.println(\"      skip: common suffix length\");\n          // }\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = compiledAutomaton.commonSuffixRef.bytes;\n\n        final int lenInPrefix = compiledAutomaton.commonSuffixRef.length - currentFrame.suffix;\n        assert compiledAutomaton.commonSuffixRef.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              // if (DEBUG) {\n              //   System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              // }\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - compiledAutomaton.commonSuffixRef.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = compiledAutomaton.commonSuffixRef.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            // if (DEBUG) {\n            //   System.out.println(\"      skip: common suffix mismatch\");\n            // }\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // See if the term prefix matches the automaton:\n      int state = currentFrame.state;\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        state = runAutomaton.step(state,  currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state + \"; return term=\" + brToString(term));\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#next().mjava","sourceNew":"  @Override\n  public BytesRef next() throws IOException {\n    try {\n      return _next();\n    } catch (NoMoreTermsException eoi) {\n      // Provoke NPE if we are (illegally!) called again:\n      currentFrame = null;\n      return null;\n    }\n  }\n\n","sourceOld":"  @Override\n  public BytesRef next() throws IOException {\n\n    //if (DEBUG) {\n    //  System.out.println(\"\\nintEnum.next seg=\" + fr.parent.segment);\n    //  System.out.println(\"  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix + \" trans: \" + currentFrame.transition + \" useAutoPrefix=\" + useAutoPrefixTerm);\n    //}\n\n    nextTerm:\n    while (true) {\n\n      boolean isSubBlock;\n\n      if (useAutoPrefixTerm) {\n\n        assert currentFrame.isAutoPrefixTerm;\n        useAutoPrefixTerm = false;\n        currentFrame.termState.isRealTerm = true;\n\n        //if (DEBUG) {\n        //  System.out.println(\"    now scan beyond auto-prefix term=\" + brToString(term) + \" floorSuffixLeadEnd=\" + Integer.toHexString(currentFrame.floorSuffixLeadEnd));\n        //}\n        // If we last returned an auto-prefix term, we must now skip all\n        // actual terms sharing that prefix.  At most, that skipping\n        // requires popping one frame, but it can also require simply\n        // scanning ahead within the current frame.  This scanning will\n        // skip sub-blocks that contain many terms, which is why the\n        // optimization \"works\":\n        int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n        if (floorSuffixLeadEnd == -1) {\n          // An ordinary prefix, e.g. foo*\n          int prefix = currentFrame.prefix;\n          int suffix = currentFrame.suffix;\n          //if (DEBUG) System.out.println(\"    prefix=\" + prefix + \" suffix=\" + suffix);\n          if (suffix == 0) {\n            //if (DEBUG) System.out.println(\"    pop frame & nextTerm\");\n\n            // Easy case: the prefix term's suffix is the empty string,\n            // meaning the prefix corresponds to all terms in the\n            // current block, so we just pop this entire block:\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            continue nextTerm;\n          } else {\n\n            // Just next() until we hit an entry that doesn't share this\n            // prefix.  The first next should be a sub-block sharing the\n            // same prefix, because if there are enough terms matching a\n            // given prefix to warrant an auto-prefix term, then there\n            // must also be enough to make a sub-block (assuming\n            // minItemsInPrefix > minItemsInBlock):\n            scanPrefix:\n            while (true) {\n              //if (DEBUG) System.out.println(\"    scan next\");\n              if (currentFrame.nextEnt == currentFrame.entCount) {\n                if (currentFrame.isLastInFloor == false) {\n                  currentFrame.loadNextFloorBlock();\n                } else if (currentFrame.ord == 0) {\n                  //if (DEBUG) System.out.println(\"  return null0\");\n                  return null;\n                } else {\n                  // Pop frame, which also means we've moved beyond this\n                  // auto-prefix term:\n                  //if (DEBUG) System.out.println(\"  pop; nextTerm\");\n                  currentFrame = stack[currentFrame.ord-1];\n                  continue nextTerm;\n                }\n              }\n              isSubBlock = currentFrame.next();\n              //if (DEBUG) {\n              //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);\n              //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);\n              //  suffixBytes.length = currentFrame.suffix;\n              //  System.out.println(\"      currentFrame.suffix=\" + brToString(suffixBytes));\n              //}\n              for(int i=0;i<suffix;i++) {\n                if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n                  //if (DEBUG) System.out.println(\"      done; now stop scan\");\n                  break scanPrefix;\n                }\n              }\n            }\n          }\n        } else {\n          // Floor'd auto-prefix term; in this case we must skip all\n          // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n          // which the automaton accepted (fooa* through foom*), and\n          // floorSuffixLeadEnd is m, so we must now scan to foon:\n          int prefix = currentFrame.prefix;\n          int suffix = currentFrame.suffix;\n\n          if (currentFrame.floorSuffixLeadStart == -1) {\n            suffix++;\n          }\n\n          //if (DEBUG) System.out.println(\"      prefix=\" + prefix + \" suffix=\" + suffix);\n\n          if (suffix == 0) {\n\n            //if (DEBUG) System.out.println(\"  pop frame\");\n\n            // This means current frame is fooa*, so we have to first\n            // pop the current frame, then scan in parent frame:\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n\n            // Current (parent) frame is now foo*, so now we just scan\n            // until the lead suffix byte is > floorSuffixLeadEnd\n            //assert currentFrame.prefix == prefix-1;\n            //prefix = currentFrame.prefix;\n\n            // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n            // its first term = floor prefix term 41[7-9], popping to block 4*:\n            prefix = currentFrame.prefix;\n\n            suffix = term.length - currentFrame.prefix;\n          } else {\n            // No need to pop; just scan in currentFrame:\n          }\n\n          //if (DEBUG) System.out.println(\"    start scan: prefix=\" + prefix + \" suffix=\" + suffix);\n\n          // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n          scanFloor:\n          while (true) {\n            //if (DEBUG) System.out.println(\"      scan next\");\n            if (currentFrame.nextEnt == currentFrame.entCount) {\n              if (currentFrame.isLastInFloor == false) {\n                //if (DEBUG) System.out.println(\"      next floor block\");\n                currentFrame.loadNextFloorBlock();\n              } else if (currentFrame.ord == 0) {\n                //if (DEBUG) System.out.println(\"  return null\");\n                return null;\n              } else {\n                // Pop frame, which also means we've moved beyond this\n                // auto-prefix term:\n                currentFrame = stack[currentFrame.ord-1];\n                //if (DEBUG) System.out.println(\"      pop, now curFrame.prefix=\" + currentFrame.prefix);\n                continue nextTerm;\n              }\n            }\n            isSubBlock = currentFrame.next();\n            //if (DEBUG) {\n            //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);\n            //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);\n            //  suffixBytes.length = currentFrame.suffix;\n            //  System.out.println(\"      currentFrame.suffix=\" + brToString(suffixBytes));\n            //}\n            for(int i=0;i<suffix-1;i++) {\n              if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n                //if (DEBUG) System.out.println(\"      done; now stop scan\");\n                break scanFloor;\n              }\n            }\n            //if (DEBUG) {\n            //  if (currentFrame.suffix >= suffix) {\n            //    System.out.println(\"      cmp label=\" + Integer.toHexString(currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]) + \" vs \" + floorSuffixLeadEnd);\n            //  }\n            //}\n            if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n              // Done scanning: we are now on the first term after all\n              // terms matched by this auto-prefix term\n              //if (DEBUG) System.out.println(\"      done; now stop scan\");\n              break;\n            }\n          }\n        }\n      } else {\n        // Pop finished frames\n        while (currentFrame.nextEnt == currentFrame.entCount) {\n          if (!currentFrame.isLastInFloor) {\n            //if (DEBUG) System.out.println(\"    next-floor-block: trans: \" + currentFrame.transition);\n            // Advance to next floor block\n            currentFrame.loadNextFloorBlock();\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix);\n            break;\n          } else {\n            //if (DEBUG) System.out.println(\"  pop frame\");\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            final long lastFP = currentFrame.fpOrig;\n            currentFrame = stack[currentFrame.ord-1];\n            assert currentFrame.lastSubFP == lastFP;\n            //if (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" outputPrefix=\" + currentFrame.outputPrefix);\n          }\n        }\n\n        isSubBlock = currentFrame.next();\n      }\n\n      //if (DEBUG) {\n      //  final BytesRef suffixRef = new BytesRef();\n      //  suffixRef.bytes = currentFrame.suffixBytes;\n      //  suffixRef.offset = currentFrame.startBytePos;\n      //  suffixRef.length = currentFrame.suffix;\n      //  System.out.println(\"    \" + (isSubBlock ? \"sub-block\" : \"term\") + \" \" + currentFrame.nextEnt + \" (of \" + currentFrame.entCount + \") suffix=\" + brToString(suffixRef));\n      //}\n\n      if (currentFrame.suffix != 0) {\n        // Advance where we are in the automaton to match what terms\n        // dict next'd to:\n        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;\n        //if (DEBUG) {\n        //  System.out.println(\"    move automaton to label=\" + label + \" vs curMax=\" + currentFrame.curTransitionMax);\n        // }\n        while (label > currentFrame.curTransitionMax) {\n          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {\n            // Pop this frame: no further matches are possible because\n            // we've moved beyond what the max transition will allow\n            //if (DEBUG) System.out.println(\"      break: trans\");\n            if (currentFrame.ord == 0) {\n              //if (DEBUG) System.out.println(\"  return null\");\n              return null;\n            }\n            currentFrame = stack[currentFrame.ord-1];\n            continue nextTerm;\n          }\n          currentFrame.transitionIndex++;\n          automaton.getNextTransition(currentFrame.transition);\n          currentFrame.curTransitionMax = currentFrame.transition.max;\n          //if (DEBUG) System.out.println(\"      next trans\");\n        }\n      }\n\n      // First test the common suffix, if set:\n      if (commonSuffix != null && !isSubBlock) {\n        final int termLen = currentFrame.prefix + currentFrame.suffix;\n        if (termLen < commonSuffix.length) {\n          // No match\n          //if (DEBUG) System.out.println(\"      skip: common suffix length\");\n          continue nextTerm;\n        }\n\n        final byte[] suffixBytes = currentFrame.suffixBytes;\n        final byte[] commonSuffixBytes = commonSuffix.bytes;\n\n        final int lenInPrefix = commonSuffix.length - currentFrame.suffix;\n        assert commonSuffix.offset == 0;\n        int suffixBytesPos;\n        int commonSuffixBytesPos = 0;\n\n        if (lenInPrefix > 0) {\n          // A prefix of the common suffix overlaps with\n          // the suffix of the block prefix so we first\n          // test whether the prefix part matches:\n          final byte[] termBytes = term.bytes;\n          int termBytesPos = currentFrame.prefix - lenInPrefix;\n          assert termBytesPos >= 0;\n          final int termBytesPosEnd = currentFrame.prefix;\n          while (termBytesPos < termBytesPosEnd) {\n            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n              //if (DEBUG) System.out.println(\"      skip: common suffix mismatch (in prefix)\");\n              continue nextTerm;\n            }\n          }\n          suffixBytesPos = currentFrame.startBytePos;\n        } else {\n          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;\n        }\n\n        // Test overlapping suffix part:\n        final int commonSuffixBytesPosEnd = commonSuffix.length;\n        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {\n          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {\n            //if (DEBUG) System.out.println(\"      skip: common suffix mismatch\");\n            continue nextTerm;\n          }\n        }\n      }\n\n      // TODO: maybe we should do the same linear test\n      // that AutomatonTermsEnum does, so that if we\n      // reach a part of the automaton where .* is\n      // \"temporarily\" accepted, we just blindly .next()\n      // until the limit\n\n      // TODO: for first iter of this loop can't we just use the current trans?  we already advanced it and confirmed it matches lead\n      // byte of the suffix\n\n      // See if the term suffix matches the automaton:\n      int state = currentFrame.state;\n      int lastState = currentFrame.lastState;\n      //if (DEBUG) {\n      //  System.out.println(\"  a state=\" + state + \" curFrame.suffix.len=\" + currentFrame.suffix + \" curFrame.prefix=\" + currentFrame.prefix);\n      // }\n      for (int idx=0;idx<currentFrame.suffix;idx++) {\n        lastState = state;\n        //if (DEBUG) System.out.println(\"    step label=\" + (char) (currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff));\n        state = runAutomaton.step(state, currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);\n        if (state == -1) {\n          // No match\n          //System.out.println(\"    no s=\" + state);\n          continue nextTerm;\n        } else {\n          //System.out.println(\"    c s=\" + state);\n        }\n      }\n\n      //if (DEBUG) System.out.println(\"    after suffix: state=\" + state + \" lastState=\" + lastState);\n\n      if (isSubBlock) {\n        // Match!  Recurse:\n        //if (DEBUG) System.out.println(\"      sub-block match to state=\" + state + \"; recurse fp=\" + currentFrame.lastSubFP);\n        copyTerm();\n        currentFrame = pushFrame(state);\n        currentFrame.lastState = lastState;\n        //xif (DEBUG) System.out.println(\"\\n  frame ord=\" + currentFrame.ord + \" prefix=\" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + \" state=\" + currentFrame.state + \" lastInFloor?=\" + currentFrame.isLastInFloor + \" fp=\" + currentFrame.fp + \" trans=\" + (currentFrame.transitions.length == 0 ? \"n/a\" : currentFrame.transitions[currentFrame.transitionIndex]) + \" outputPrefix=\" + currentFrame.outputPrefix);\n      } else if (currentFrame.isAutoPrefixTerm) {\n        // We are on an auto-prefix term, meaning this term was compiled\n        // at indexing time, matching all terms sharing this prefix (or,\n        // a floor'd subset of them if that count was too high).  A\n        // prefix term represents a range of terms, so we now need to\n        // test whether, from the current state in the automaton, it\n        // accepts all terms in that range.  As long as it does, we can\n        // use this term and then later skip ahead past all terms in\n        // this range:\n        if (allowAutoPrefixTerms) {\n\n          if (currentFrame.floorSuffixLeadEnd == -1) {\n            // Simple prefix case\n            useAutoPrefixTerm = state == sinkState;\n          } else {\n            if (currentFrame.floorSuffixLeadStart == -1) {\n              // Must also accept the empty string in this case\n              if (automaton.isAccept(state)) {\n                //if (DEBUG) System.out.println(\"      state is accept\");\n                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);\n              }\n            } else {\n              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);\n            }\n          }\n\n          //if (DEBUG) System.out.println(\"  useAutoPrefixTerm=\" + useAutoPrefixTerm);\n\n          if (useAutoPrefixTerm) {\n            copyTerm();\n            currentFrame.termState.isRealTerm = false;\n            //if (DEBUG) System.out.println(\"  return auto prefix term: \" + brToString(term));\n            return term;\n          } else {\n            // We move onto the next term\n          }\n        } else {\n          // We are not allowed to use auto-prefix terms, so we just skip it\n        }\n      } else if (runAutomaton.isAccept(state)) {\n        copyTerm();\n        //if (DEBUG) System.out.println(\"      term match to state=\" + state);\n        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: \"saveStartTerm=\" + savedStartTerm.utf8ToString() + \" term=\" + term.utf8ToString();\n        //if (DEBUG) System.out.println(\"      return term=\" + brToString(term));\n        return term;\n      } else {\n        //System.out.println(\"    no s=\" + state);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7266c313bb3b4fbcde3dcc82556182e1fae90080"],"59db5e5f780185e0155d296a323e440a6ecfd3b6":["3e8715d826e588419327562287d5d6a8040d63d6"],"7266c313bb3b4fbcde3dcc82556182e1fae90080":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"d2638f781be724518ff6c2263d14a48cf6e68017":["5c84485629d80d203608e8975a1139de9933cc38","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["4d637064d608752565d4f9f41b2497dfdfdde50e","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59db5e5f780185e0155d296a323e440a6ecfd3b6"]},"commit2Childs":{"4d637064d608752565d4f9f41b2497dfdfdde50e":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"59db5e5f780185e0155d296a323e440a6ecfd3b6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7266c313bb3b4fbcde3dcc82556182e1fae90080":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d637064d608752565d4f9f41b2497dfdfdde50e","7266c313bb3b4fbcde3dcc82556182e1fae90080"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["59db5e5f780185e0155d296a323e440a6ecfd3b6","d2638f781be724518ff6c2263d14a48cf6e68017"],"5c84485629d80d203608e8975a1139de9933cc38":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}