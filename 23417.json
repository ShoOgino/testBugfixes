{"path":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","commits":[{"id":"e2ffda7a1ecb465d19f368d81bd4737bcf4fd087","date":1024963531,"type":0,"author":"Brian Goetz","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"/dev/null","sourceNew":"  public void testDateRange() throws Exception {\n    assertQueryEquals(\"[ 1/1/02 TO 1/4/02]\", null, \n                      \"[\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"]\");\n    assertQueryEquals(\"{  1/1/02    1/4/02   }\", null, \n                      \"{\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"}\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5742a13bc31248b37eec58aaf19da9d165a48d82","date":1026669113,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"    public void testDateRange() throws Exception {\n\tassertQueryEquals(\"[ 1/1/02 TO 1/4/02]\", null,\n\t    \"[\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"]\");\n\tassertQueryEquals(\"{  1/1/02    1/4/02   }\", null,\n\t    \"{\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"}\");\n    }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    assertQueryEquals(\"[ 1/1/02 TO 1/4/02]\", null, \n                      \"[\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"]\");\n    assertQueryEquals(\"{  1/1/02    1/4/02   }\", null, \n                      \"{\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"}\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d281db9007b19360dddcee9ecd7cfcabde1ca54e","date":1045340167,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"    public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4); \n\tassertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n\t    \"[\" + getDate(startDate) + \"-\" + getDate(endDate) + \"]\");\n\tassertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n\t    \"{\" + getDate(startDate) + \"-\" + getDate(endDate) + \"}\");\n    }\n\n","sourceOld":"    public void testDateRange() throws Exception {\n\tassertQueryEquals(\"[ 1/1/02 TO 1/4/02]\", null,\n\t    \"[\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"]\");\n\tassertQueryEquals(\"{  1/1/02    1/4/02   }\", null,\n\t    \"{\" + getDate(\"1/1/02\") + \"-\" + getDate(\"1/4/02\") + \"}\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfb889456f00316d23950a3c6efea95b78a799eb","date":1046573221,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"    public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n\tassertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n\t    \"[\" + getDate(startDate) + \"-\" + getDate(endDate) + \"]\");\n\tassertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n\t    \"{\" + getDate(startDate) + \"-\" + getDate(endDate) + \"}\");\n    }\n\n","sourceOld":"    public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4); \n\tassertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n\t    \"[\" + getDate(startDate) + \"-\" + getDate(endDate) + \"]\");\n\tassertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n\t    \"{\" + getDate(startDate) + \"-\" + getDate(endDate) + \"}\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a946a1d011debaca507664c0571ac25f38c62eae","date":1051580040,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"    public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n\tassertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n\t    \"[\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"]\");\n\tassertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n\t    \"{\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"}\");\n    }\n\n","sourceOld":"    public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n\tassertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n\t    \"[\" + getDate(startDate) + \"-\" + getDate(endDate) + \"]\");\n\tassertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n\t    \"{\" + getDate(startDate) + \"-\" + getDate(endDate) + \"}\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"105b8c63d8ae43de76f14005b62a5657a4b8d9ce","date":1064896862,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    assertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n                      \"[\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"]\");\n    assertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n                      \"{\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"}\");\n  }\n\n","sourceOld":"    public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n\tassertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n\t    \"[\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"]\");\n\tassertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n\t    \"{\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"}\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce48e56956c287f0fdb295c2c2f5b7c68ae8798b","date":1138567903,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = Calendar.getInstance();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    assertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n                      \"[\" + getDate(startDate) + \" TO \" + DateField.dateToString(endDateExpected.getTime()) + \"]\");\n    assertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n                      \"{\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"}\");\n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    assertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n                      \"[\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"]\");\n    assertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n                      \"{\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"}\");\n  }\n\n","bugFix":null,"bugIntro":["d6c356d9e7be4ba949f083ecd3fb65231bc64008"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd9159d2966a77ae7e472d435eb5c9c5cad7f820","date":1168286571,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = Calendar.getInstance();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = Calendar.getInstance();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    assertQueryEquals(\"[ \" + startDate + \" TO \" + endDate + \"]\", null,\n                      \"[\" + getDate(startDate) + \" TO \" + DateField.dateToString(endDateExpected.getTime()) + \"]\");\n    assertQueryEquals(\"{  \" + startDate + \"    \" + endDate + \"   }\", null,\n                      \"{\" + getDate(startDate) + \" TO \" + getDate(endDate) + \"}\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6c356d9e7be4ba949f083ecd3fb65231bc64008","date":1251182916,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = Calendar.getInstance();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":["ce48e56956c287f0fdb295c2c2f5b7c68ae8798b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8d1458a2543cbd30cbfe7929be4dcb5c5251659","date":1254582241,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":null,"sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a046c0c310bc77931fc8441bd920053b607dd14","date":1254584734,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":null,"sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"174ced3f382f37c6b4eab123325bfea03b47af5e","date":1254607278,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"/dev/null","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ee76d213d935c68932ca13b55fa0a8a32bf6af1a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba1116b3450a9c1642c89445d131b37344055245","date":1256329517,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, \"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(\"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"64a84446b679daf1e25d901bf647686ade7fc1f0","date":1260811919,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, \"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, \"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe0932c1d340f83fb0a611e5829b3046a1cc1152","date":1264946739,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, \"field\", new SimpleAnalyzer(Version.LUCENE_CURRENT));\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, \"field\", new SimpleAnalyzer());\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6","date":1265808957,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, \"field\", new SimpleAnalyzer(TEST_VERSION_CURRENT));\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, \"field\", new SimpleAnalyzer(Version.LUCENE_CURRENT));\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","pathOld":"src/test/org/apache/lucene/queryParser/TestQueryParser#testDateRange().mjava","sourceNew":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, \"field\", new SimpleAnalyzer(TEST_VERSION_CURRENT));\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","sourceOld":"  public void testDateRange() throws Exception {\n    String startDate = getLocalizedDate(2002, 1, 1);\n    String endDate = getLocalizedDate(2002, 1, 4);\n    Calendar endDateExpected = new GregorianCalendar();\n    endDateExpected.clear();\n    endDateExpected.set(2002, 1, 4, 23, 59, 59);\n    endDateExpected.set(Calendar.MILLISECOND, 999);\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, \"field\", new SimpleAnalyzer(TEST_VERSION_CURRENT));\n    \n    // Don't set any date resolution and verify if DateField is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set a field specific date resolution\n    qp.setDateResolution(monthField, DateTools.Resolution.MONTH);\n    \n    // DateField should still be used for defaultField\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n                               endDateExpected.getTime(), null);\n    \n    // set default date resolution to MILLISECOND \n    qp.setDateResolution(DateTools.Resolution.MILLISECOND);\n    \n    // set second field specific date resolution    \n    qp.setDateResolution(hourField, DateTools.Resolution.HOUR);\n\n    // for this field no field specific date resolution has been set,\n    // so verify if the default resolution is used\n    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);\n\n    // verify if field specific date resolutions are used for these two fields\n    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.MONTH);\n\n    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, \n            endDateExpected.getTime(), DateTools.Resolution.HOUR);  \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"64a84446b679daf1e25d901bf647686ade7fc1f0":["ba1116b3450a9c1642c89445d131b37344055245"],"ce48e56956c287f0fdb295c2c2f5b7c68ae8798b":["105b8c63d8ae43de76f14005b62a5657a4b8d9ce"],"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["fe0932c1d340f83fb0a611e5829b3046a1cc1152"],"0a046c0c310bc77931fc8441bd920053b607dd14":["d6c356d9e7be4ba949f083ecd3fb65231bc64008","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"e2ffda7a1ecb465d19f368d81bd4737bcf4fd087":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d281db9007b19360dddcee9ecd7cfcabde1ca54e":["5742a13bc31248b37eec58aaf19da9d165a48d82"],"ba1116b3450a9c1642c89445d131b37344055245":["174ced3f382f37c6b4eab123325bfea03b47af5e"],"174ced3f382f37c6b4eab123325bfea03b47af5e":["0a046c0c310bc77931fc8441bd920053b607dd14"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["d6c356d9e7be4ba949f083ecd3fb65231bc64008"],"fe0932c1d340f83fb0a611e5829b3046a1cc1152":["64a84446b679daf1e25d901bf647686ade7fc1f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6c356d9e7be4ba949f083ecd3fb65231bc64008":["bd9159d2966a77ae7e472d435eb5c9c5cad7f820"],"a946a1d011debaca507664c0571ac25f38c62eae":["bfb889456f00316d23950a3c6efea95b78a799eb"],"bd9159d2966a77ae7e472d435eb5c9c5cad7f820":["ce48e56956c287f0fdb295c2c2f5b7c68ae8798b"],"105b8c63d8ae43de76f14005b62a5657a4b8d9ce":["a946a1d011debaca507664c0571ac25f38c62eae"],"bfb889456f00316d23950a3c6efea95b78a799eb":["d281db9007b19360dddcee9ecd7cfcabde1ca54e"],"5742a13bc31248b37eec58aaf19da9d165a48d82":["e2ffda7a1ecb465d19f368d81bd4737bcf4fd087"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"]},"commit2Childs":{"64a84446b679daf1e25d901bf647686ade7fc1f0":["fe0932c1d340f83fb0a611e5829b3046a1cc1152"],"ce48e56956c287f0fdb295c2c2f5b7c68ae8798b":["bd9159d2966a77ae7e472d435eb5c9c5cad7f820"],"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0a046c0c310bc77931fc8441bd920053b607dd14":["174ced3f382f37c6b4eab123325bfea03b47af5e"],"e2ffda7a1ecb465d19f368d81bd4737bcf4fd087":["5742a13bc31248b37eec58aaf19da9d165a48d82"],"d281db9007b19360dddcee9ecd7cfcabde1ca54e":["bfb889456f00316d23950a3c6efea95b78a799eb"],"ba1116b3450a9c1642c89445d131b37344055245":["64a84446b679daf1e25d901bf647686ade7fc1f0"],"174ced3f382f37c6b4eab123325bfea03b47af5e":["ba1116b3450a9c1642c89445d131b37344055245"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["0a046c0c310bc77931fc8441bd920053b607dd14"],"fe0932c1d340f83fb0a611e5829b3046a1cc1152":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e2ffda7a1ecb465d19f368d81bd4737bcf4fd087"],"d6c356d9e7be4ba949f083ecd3fb65231bc64008":["0a046c0c310bc77931fc8441bd920053b607dd14","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"a946a1d011debaca507664c0571ac25f38c62eae":["105b8c63d8ae43de76f14005b62a5657a4b8d9ce"],"105b8c63d8ae43de76f14005b62a5657a4b8d9ce":["ce48e56956c287f0fdb295c2c2f5b7c68ae8798b"],"bd9159d2966a77ae7e472d435eb5c9c5cad7f820":["d6c356d9e7be4ba949f083ecd3fb65231bc64008"],"5742a13bc31248b37eec58aaf19da9d165a48d82":["d281db9007b19360dddcee9ecd7cfcabde1ca54e"],"bfb889456f00316d23950a3c6efea95b78a799eb":["a946a1d011debaca507664c0571ac25f38c62eae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}