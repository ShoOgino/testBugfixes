{"path":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#run(String,int,Consumer[InetSocketAddress]).mjava","commits":[{"id":"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760","date":1599669750,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockVerifyServer#run(String,int,Consumer[InetSocketAddress]).mjava","pathOld":"/dev/null","sourceNew":"  // method pkg-private for tests\n  static void run(String hostname, int maxClients, Consumer<InetSocketAddress> startClients) throws Exception {\n    try (final ServerSocket s = new ServerSocket()) {\n      s.setReuseAddress(true);\n      s.setSoTimeout(30000); // initially 30 secs to give clients enough time to startup\n      s.bind(new InetSocketAddress(hostname, 0));\n      final InetSocketAddress localAddr = (InetSocketAddress) s.getLocalSocketAddress();\n      System.out.println(\"Listening on \" + localAddr + \"...\");\n      \n      // callback only for the test to start the clients:\n      startClients.accept(localAddr);\n      \n      final Object localLock = new Object();\n      final int[] lockedID = new int[1];\n      lockedID[0] = -1;\n      final CountDownLatch startingGun = new CountDownLatch(1);\n      final Thread[] threads = new Thread[maxClients];\n      \n      for (int count = 0; count < maxClients; count++) {\n        final Socket cs = s.accept();\n        threads[count] = new Thread() {\n          @Override\n          public void run() {\n            try (InputStream in = cs.getInputStream(); OutputStream os = cs.getOutputStream()) {\n              final int id = in.read();\n              if (id < 0) {\n                throw new IOException(\"Client closed connection before communication started.\");\n              }\n              \n              startingGun.await();\n              os.write(START_GUN_SIGNAL);\n              os.flush();\n              \n              while (true) {\n                final int command = in.read();\n                if (command < 0) {\n                  return; // closed\n                }\n                \n                synchronized (localLock) {\n                  final int currentLock = lockedID[0];\n                  if (currentLock == -2) {\n                    return; // another thread got error, so we exit, too!\n                  }\n                  switch (command) {\n                    case VerifyingLockFactory.MSG_LOCK_ACQUIRED:\n                      // Locked\n                      if (currentLock != -1) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" got lock, but \" + currentLock + \" already holds the lock\");\n                      }\n                      lockedID[0] = id;\n                      break;\n                    case VerifyingLockFactory.MSG_LOCK_RELEASED:\n                      // Unlocked\n                      if (currentLock != id) {\n                        lockedID[0] = -2;\n                        throw new IllegalStateException(\"id \" + id + \" released the lock, but \" + currentLock + \" is the one holding the lock\");\n                      }\n                      lockedID[0] = -1;\n                      break;\n                    default:\n                      throw new RuntimeException(\"Unrecognized command: \" + command);\n                  }\n                  os.write(command);\n                  os.flush();\n                }\n              }\n            } catch (RuntimeException | Error e) {\n              throw e;\n            } catch (Exception ioe) {\n              throw new RuntimeException(ioe);\n            } finally {\n              IOUtils.closeWhileHandlingException(cs);\n            }\n          }\n        };\n        threads[count].start();\n      }\n      \n      // start\n      System.out.println(\"All clients started, fire gun...\");\n      startingGun.countDown();\n      \n      // wait for all threads to finish\n      for (Thread t : threads) {\n        t.join();\n      }\n\n      System.out.println(\"Server terminated.\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7ee2241d9fc5dee5029efe24602d8a4d2b4d760"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7ee2241d9fc5dee5029efe24602d8a4d2b4d760"],"b7ee2241d9fc5dee5029efe24602d8a4d2b4d760":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}