{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","commits":[{"id":"e58bb31b4af6b8eeb1539849575c59df745bc6e6","date":1461874681,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundent -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundent -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundent -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundent -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundent -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63a1978c6710c767fa084741e3d6424840003a62","date":1495850671,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return (new HttpSolrClient.Builder(url)).build();\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return (new HttpSolrClient.Builder(url)).build();\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#getRandomizedHttpSolrClient(String).mjava","sourceNew":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return (new HttpSolrClient.Builder(url)).build();\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","sourceOld":"  /** \n   * Generates an HttpSolrClient, either by using the test framework helper method or by direct \n   * instantiation (determined randomly)\n   * @see #getHttpSolrClient\n   */\n  public static HttpSolrClient getRandomizedHttpSolrClient(String url) {\n    // NOTE: at the moment, SolrTestCaseJ4 already returns \"new HttpSolrClient\" most of the time,\n    // so this method may seem redundant -- but the point here is to sanity check 2 things:\n    // 1) a direct test that \"new HttpSolrClient\" works given the current JVM/sysprop defaults\n    // 2) a sanity check that whatever getHttpSolrClient(String) returns will work regardless of\n    //    current test configuration.\n    // ... so we are hopefully future proofing against possible changes to SolrTestCaseJ4.getHttpSolrClient\n    // that \"optimize\" the test client construction in a way that would prevent us from finding bugs with\n    // regular HttpSolrClient instantiation.\n    if (random().nextBoolean()) {\n      return new HttpSolrClient(url);\n    } // else...\n    return getHttpSolrClient(url);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["d470c8182e92b264680e34081b75e70a9f2b3c89","63a1978c6710c767fa084741e3d6424840003a62"],"63a1978c6710c767fa084741e3d6424840003a62":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"e58bb31b4af6b8eeb1539849575c59df745bc6e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["d470c8182e92b264680e34081b75e70a9f2b3c89","63a1978c6710c767fa084741e3d6424840003a62"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e58bb31b4af6b8eeb1539849575c59df745bc6e6","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["e58bb31b4af6b8eeb1539849575c59df745bc6e6"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e58bb31b4af6b8eeb1539849575c59df745bc6e6"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"63a1978c6710c767fa084741e3d6424840003a62":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"e58bb31b4af6b8eeb1539849575c59df745bc6e6":["d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e58bb31b4af6b8eeb1539849575c59df745bc6e6","55b50463286869f584cf849d1587a0fcd54d1dfa"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e9017cf144952056066919f1ebc7897ff9bd71b1","63a1978c6710c767fa084741e3d6424840003a62","d1f5728f32a4a256b36cfabd7a2636452f599bb9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}