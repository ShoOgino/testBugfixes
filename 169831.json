{"path":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.shard);\n      NamedList facet_counts = (NamedList)srsp.rsp.getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37","718ab708b1705aae7831111fcddfc834665eee61","0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"705cbdd6d66202e299a6f186f5fbb69dbb64f41a","date":1205860565,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.shard);\n      NamedList facet_counts = (NamedList)srsp.rsp.getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.shard);\n      NamedList facet_counts = (NamedList)srsp.rsp.getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4db78c8781346b675fa5f1a6db8adcb96889c2ca","date":1213723536,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.shard);\n      NamedList facet_counts = (NamedList)srsp.rsp.getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.shard);\n      NamedList facet_counts = (NamedList)srsp.rsp.getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e69935771ba8cb2303a86bf8a42be7861eaf1da","date":1216694040,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.shard);\n      NamedList facet_counts = (NamedList)srsp.rsp.getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5a95ce1d7a3779af6db59b6b39d3b89172d7445","date":1228620032,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && (dff.sort.equals(FacetParams.FACET_SORT_LEX) || dff.sort.equals(FacetParams.FACET_SORT_LEX_LEGACY))) continue;\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.topFacets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.topFacets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      ShardFacetCount[] counts = dff.getSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba2bd485bcfb228fadd0d133a947f88f0cc2058d","date":1228666670,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_LEX)) continue;\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && (dff.sort.equals(FacetParams.FACET_SORT_LEX) || dff.sort.equals(FacetParams.FACET_SORT_LEX_LEGACY))) continue;\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb179b2fab2183d2f6041e450ff8022c592ecf0","date":1229553695,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_LEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String facet_q = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          Long prevCount = fi.queryFacets.get(facet_q);\n          if (prevCount != null) count += prevCount;\n          fi.queryFacets.put(facet_q, count);\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    // list of queries to send each shard\n    List<String>[] toRefine = new List[rb.shards.length];\n    fi._toRefine = toRefine;\n    for (int i=0; i<toRefine.length; i++) {\n      toRefine[i] = new ArrayList<String>();\n    }\n\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_LEX)) continue;\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        String query = null;\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              if (query==null) query = dff.makeQuery(sfc);\n              toRefine[shardNum].add(query);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1161f19bd84204b140d97fea16ff621e86ce7ab4","date":1235924971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_INDEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_LEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"718ab708b1705aae7831111fcddfc834665eee61","date":1241122833,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");\n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_INDEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");      \n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_INDEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#countFacets(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");\n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_INDEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {\n    FacetInfo fi = rb._facetInfo;\n\n    for (ShardResponse srsp: sreq.responses) {\n      int shardNum = rb.getShardNum(srsp.getShard());\n      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get(\"facet_counts\");\n\n      // handle facet queries\n      NamedList facet_queries = (NamedList)facet_counts.get(\"facet_queries\");\n      if (facet_queries != null) {\n        for (int i=0; i<facet_queries.size(); i++) {\n          String returnedKey = (String)facet_queries.getName(i);\n          long count = ((Number)facet_queries.getVal(i)).longValue();\n          QueryFacet qf = fi.queryFacets.get(returnedKey);\n          qf.count += count;\n        }\n      }\n\n      // step through each facet.field, adding results from this shard\n      NamedList facet_fields = (NamedList)facet_counts.get(\"facet_fields\");\n      for (DistribFieldFacet dff : fi.facets.values()) {\n        dff.add(shardNum, (NamedList)facet_fields.get(dff.getKey()), dff.initialLimit);\n      }\n    }\n\n\n    //\n    // This code currently assumes that there will be only a single\n    // request ((with responses from all shards) sent out to get facets...\n    // otherwise we would need to wait until all facet responses were received.\n    //\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      if (dff.limit <= 0) continue; // no need to check these facets for refinement\n      if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_INDEX)) continue;\n\n      dff._toRefine = new List[rb.shards.length];\n      ShardFacetCount[] counts = dff.getCountSorted();\n      int ntop = Math.min(counts.length, dff.offset + dff.limit);\n      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;\n\n      for (int i=0; i<counts.length; i++) {\n        ShardFacetCount sfc = counts[i];\n        boolean needRefinement = false;\n\n        if (i<ntop) {\n          // automatically flag the top values for refinement\n          needRefinement = true;\n        } else {\n          // calculate the maximum value that this term may have\n          // and if it is >= smallestCount, then flag for refinement\n          long maxCount = sfc.count;\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum)) {\n              // if missing from this shard, add the max it could be\n              maxCount += dff.maxPossible(sfc,shardNum);\n            }\n          }\n          if (maxCount >= smallestCount) {\n            // TODO: on a tie, we could check the term values\n            needRefinement = true;\n          }\n        }\n\n        if (needRefinement) {\n          // add a query for each shard missing the term that needs refinement\n          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {\n            OpenBitSet obs = dff.counted[shardNum];\n            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {\n              dff.needRefinements = true;\n              List<String> lst = dff._toRefine[shardNum];\n              if (lst == null) {\n                lst = dff._toRefine[shardNum] = new ArrayList<String>();\n              }\n              lst.add(sfc.name);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"718ab708b1705aae7831111fcddfc834665eee61":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["ba2bd485bcfb228fadd0d133a947f88f0cc2058d"],"ba2bd485bcfb228fadd0d133a947f88f0cc2058d":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"705cbdd6d66202e299a6f186f5fbb69dbb64f41a":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"4db78c8781346b675fa5f1a6db8adcb96889c2ca":["705cbdd6d66202e299a6f186f5fbb69dbb64f41a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"0e69935771ba8cb2303a86bf8a42be7861eaf1da":["4db78c8781346b675fa5f1a6db8adcb96889c2ca"],"ad94625fb8d088209f46650c8097196fec67f00c":["718ab708b1705aae7831111fcddfc834665eee61"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"718ab708b1705aae7831111fcddfc834665eee61":["ad94625fb8d088209f46650c8097196fec67f00c"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"ba2bd485bcfb228fadd0d133a947f88f0cc2058d":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["705cbdd6d66202e299a6f186f5fbb69dbb64f41a"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["ba2bd485bcfb228fadd0d133a947f88f0cc2058d"],"705cbdd6d66202e299a6f186f5fbb69dbb64f41a":["4db78c8781346b675fa5f1a6db8adcb96889c2ca"],"4db78c8781346b675fa5f1a6db8adcb96889c2ca":["0e69935771ba8cb2303a86bf8a42be7861eaf1da"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["718ab708b1705aae7831111fcddfc834665eee61"],"0e69935771ba8cb2303a86bf8a42be7861eaf1da":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}