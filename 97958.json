{"path":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","commits":[{"id":"136796946c32863f11b97ebec6b4091cdfe3a20b","date":1468862468,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // these don't work in distrib cloud mode due to SOLR-9286\n      FL_VALIDATORS.addAll(Arrays.asList\n                           (new FunctionValidator(\"aaa_i\"), // fq field\n                            new FunctionValidator(\"aaa_i\", \"func_aaa_alias\"),\n                            new RenameFieldValueValidator(\"id\", \"my_id_alias\"),\n                            new RenameFieldValueValidator(\"bbb_i\", \"my_int_field_alias\"),\n                            new RenameFieldValueValidator(\"ddd_s\", \"my_str_field_alias\")));\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","76b65cf789129cacd84e977b8f1538aec29e0281"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26624d6ff6e4b87874022addc79be7e89af6b7b6","date":1468950645,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // these don't work in distrib cloud mode due to SOLR-9286\n      FL_VALIDATORS.addAll(Arrays.asList\n                           (new FunctionValidator(\"aaa_i\"), // fq field\n                            new FunctionValidator(\"aaa_i\", \"func_aaa_alias\"),\n                            new RenameFieldValueValidator(\"id\", \"my_id_alias\"),\n                            new RenameFieldValueValidator(\"bbb_i\", \"my_int_field_alias\"),\n                            new RenameFieldValueValidator(\"ddd_s\", \"my_str_field_alias\")));\n      // SOLR-9289...\n      FL_VALIDATORS.add(new DocIdValidator());\n      FL_VALIDATORS.add(new DocIdValidator(\"my_docid_alias\"));\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // these don't work in distrib cloud mode due to SOLR-9286\n      FL_VALIDATORS.addAll(Arrays.asList\n                           (new FunctionValidator(\"aaa_i\"), // fq field\n                            new FunctionValidator(\"aaa_i\", \"func_aaa_alias\"),\n                            new RenameFieldValueValidator(\"id\", \"my_id_alias\"),\n                            new RenameFieldValueValidator(\"bbb_i\", \"my_int_field_alias\"),\n                            new RenameFieldValueValidator(\"ddd_s\", \"my_str_field_alias\")));\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":["76b65cf789129cacd84e977b8f1538aec29e0281"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76b65cf789129cacd84e977b8f1538aec29e0281","date":1470165799,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // No-Op\n      // At the moment, there are no known transformers that (we have FlValidators for and) only\n      // work in single core mode.\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // these don't work in distrib cloud mode due to SOLR-9286\n      FL_VALIDATORS.addAll(Arrays.asList\n                           (new FunctionValidator(\"aaa_i\"), // fq field\n                            new FunctionValidator(\"aaa_i\", \"func_aaa_alias\"),\n                            new RenameFieldValueValidator(\"id\", \"my_id_alias\"),\n                            new RenameFieldValueValidator(\"bbb_i\", \"my_int_field_alias\"),\n                            new RenameFieldValueValidator(\"ddd_s\", \"my_str_field_alias\")));\n      // SOLR-9289...\n      FL_VALIDATORS.add(new DocIdValidator());\n      FL_VALIDATORS.add(new DocIdValidator(\"my_docid_alias\"));\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","bugFix":["26624d6ff6e4b87874022addc79be7e89af6b7b6","136796946c32863f11b97ebec6b4091cdfe3a20b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbfb6ddad2ec9fa9128265741535450c3cbc4344","date":1470329280,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // No-Op\n      // At the moment, there are no known transformers that (we have FlValidators for and) only\n      // work in single core mode.\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // Due to known bugs with some transformers in either multi vs single node, we want\n    // to test both possible cases explicitly and modify the List of FL_VALIDATORS we use accordingly:\n    //  - 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    //  - 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n    if (singleCoreMode) {\n      // these don't work in distrib cloud mode due to SOLR-9286\n      FL_VALIDATORS.addAll(Arrays.asList\n                           (new FunctionValidator(\"aaa_i\"), // fq field\n                            new FunctionValidator(\"aaa_i\", \"func_aaa_alias\"),\n                            new RenameFieldValueValidator(\"id\", \"my_id_alias\"),\n                            new RenameFieldValueValidator(\"bbb_i\", \"my_int_field_alias\"),\n                            new RenameFieldValueValidator(\"ddd_s\", \"my_str_field_alias\")));\n      // SOLR-9289...\n      FL_VALIDATORS.add(new DocIdValidator());\n      FL_VALIDATORS.add(new DocIdValidator(\"my_docid_alias\"));\n    } else {\n      // No-Op\n      // No known transformers that only work in distrib cloud but fail in singleCoreMode\n\n    }\n    // TODO: SOLR-9314: programatically compare FL_VALIDATORS with all known transformers.\n    // (ala QueryEqualityTest) can't be done until we eliminate the need for \"singleCodeMode\"\n    // conditional logic (might still want 'singleCoreMode' on the MiniSolrCloudCluster side,\n    // but shouldn't have conditional FlValidators\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .withProperty(\"config\", \"solrconfig-tlog.xml\")\n        .withProperty(\"schema\", \"schema-psuedo-fields.xml\")\n        .process(CLOUD_CLIENT);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  private static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n    \n    Map<String, String> collectionProperties = new HashMap<>();\n    collectionProperties.put(\"config\", \"solrconfig-tlog.xml\");\n    collectionProperties.put(\"schema\", \"schema-psuedo-fields.xml\");\n\n    assertNotNull(cluster.createCollection(COLLECTION_NAME, numShards, repFactor,\n                                           configName, null, null, collectionProperties));\n    \n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .withProperty(\"config\", \"solrconfig-tlog.xml\")\n        .withProperty(\"schema\", \"schema-psuedo-fields.xml\")\n        .process(CLOUD_CLIENT);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomFlRTGCloud#createMiniSolrCloudCluster().mjava","sourceNew":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .withProperty(\"config\", \"solrconfig-tlog.xml\")\n        .withProperty(\"schema\", \"schema-psuedo-fields.xml\")\n        .process(CLOUD_CLIENT);\n\n    cluster.waitForActiveCollection(COLLECTION_NAME, numShards, repFactor * numShards); \n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void createMiniSolrCloudCluster() throws Exception {\n\n    // 50% runs use single node/shard a FL_VALIDATORS with all validators known to work on single node\n    // 50% runs use multi node/shard with FL_VALIDATORS only containing stuff that works in cloud\n    final boolean singleCoreMode = random().nextBoolean();\n\n    // (asuming multi core multi replicas shouldn't matter (assuming multi node) ...\n    final int repFactor = singleCoreMode ? 1 : (usually() ? 1 : 2);\n    // ... but we definitely want to ensure forwarded requests to other shards work ...\n    final int numShards = singleCoreMode ? 1 : 2;\n    // ... including some forwarded requests from nodes not hosting a shard\n    final int numNodes = 1 + (singleCoreMode ? 0 : (numShards * repFactor));\n    \n    final String configName = DEBUG_LABEL + \"_config-set\";\n    final Path configDir = Paths.get(TEST_HOME(), \"collection1\", \"conf\");\n    \n    configureCluster(numNodes).addConfig(configName, configDir).configure();\n\n    CLOUD_CLIENT = cluster.getSolrClient();\n    CLOUD_CLIENT.setDefaultCollection(COLLECTION_NAME);\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, configName, numShards, repFactor)\n        .withProperty(\"config\", \"solrconfig-tlog.xml\")\n        .withProperty(\"schema\", \"schema-psuedo-fields.xml\")\n        .process(CLOUD_CLIENT);\n\n    waitForRecoveriesToFinish(CLOUD_CLIENT);\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      CLIENTS.add(getHttpSolrClient(jetty.getBaseUrl() + \"/\" + COLLECTION_NAME + \"/\"));\n    }\n  }\n\n","bugFix":["136796946c32863f11b97ebec6b4091cdfe3a20b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["fbfb6ddad2ec9fa9128265741535450c3cbc4344"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"fbfb6ddad2ec9fa9128265741535450c3cbc4344":["76b65cf789129cacd84e977b8f1538aec29e0281"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"26624d6ff6e4b87874022addc79be7e89af6b7b6":["136796946c32863f11b97ebec6b4091cdfe3a20b"],"136796946c32863f11b97ebec6b4091cdfe3a20b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["26624d6ff6e4b87874022addc79be7e89af6b7b6","fbfb6ddad2ec9fa9128265741535450c3cbc4344"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"76b65cf789129cacd84e977b8f1538aec29e0281":["26624d6ff6e4b87874022addc79be7e89af6b7b6"]},"commit2Childs":{"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"fbfb6ddad2ec9fa9128265741535450c3cbc4344":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["136796946c32863f11b97ebec6b4091cdfe3a20b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"26624d6ff6e4b87874022addc79be7e89af6b7b6":["3b013574eedcdbac35dc7e35b0ee616ffc38895d","76b65cf789129cacd84e977b8f1538aec29e0281"],"136796946c32863f11b97ebec6b4091cdfe3a20b":["26624d6ff6e4b87874022addc79be7e89af6b7b6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"76b65cf789129cacd84e977b8f1538aec29e0281":["fbfb6ddad2ec9fa9128265741535450c3cbc4344"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}