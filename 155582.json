{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","commits":[{"id":"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","date":1439091488,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"/dev/null","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n      }\n    } finally {\n      iw.decref();\n    }\n    if (ulog != null) ulog.add(cmd, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a1888dae6d3c1d082a5aa627824792e4d694281","date":1439156801,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n      }\n    } finally {\n      iw.decref();\n    }\n    synchronized (solrCoreState.getUpdateLock()) {\n      if (ulog != null) ulog.add(cmd, true);\n    }\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n      }\n    } finally {\n      iw.decref();\n    }\n    if (ulog != null) ulog.add(cmd, true);\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1adea4accc297f58fd9d8de3c820fd576eb0d396","date":1441292844,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n      }\n    } finally {\n      iw.decref();\n    }\n    synchronized (solrCoreState.getUpdateLock()) {\n      if (ulog != null) ulog.add(cmd, true);\n    }\n  }\n\n","bugFix":["1a1888dae6d3c1d082a5aa627824792e4d694281"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        writer.updateDocument(idTerm, luceneDocument);\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407b2e02aedce6b9118323ef204a08acfd83add7","date":1487217081,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = new Term(idField.getName(), cmd.getIndexedId());\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9133745ed58338ebe8daabe49076605b61fc6b86","date":1487468548,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Document luceneDocument = cmd.getLuceneDocument();\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5ce7c704ca874aa623a99f2669737b52ec71cfc","date":1528728510,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n    // this logic is different enough from doNormalUpdate that it's separate\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n    // this logic is different enough from doNormalUpdate that it's separate\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n    // this logic is different enough from doNormalUpdate that it's separate\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    Term idTerm = getIdTerm(cmd);\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer, idTerm);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#addAndDelete(AddUpdateCommand,List[UpdateLog.DBQ]).mjava","sourceNew":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n    // this logic is different enough from doNormalUpdate that it's separate\n    log.info(\"Reordered DBQs detected.  Update={} DBQs={}\", cmd, deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : {}\", dbq, e);\n      }\n    }\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","sourceOld":"  private void addAndDelete(AddUpdateCommand cmd, List<UpdateLog.DBQ> deletesAfter) throws IOException {\n    // this logic is different enough from doNormalUpdate that it's separate\n    log.info(\"Reordered DBQs detected.  Update=\" + cmd + \" DBQs=\"\n        + deletesAfter);\n    List<Query> dbqList = new ArrayList<>(deletesAfter.size());\n    for (UpdateLog.DBQ dbq : deletesAfter) {\n      try {\n        DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);\n        tmpDel.query = dbq.q;\n        tmpDel.version = -dbq.version;\n        dbqList.add(getQuery(tmpDel));\n      } catch (Exception e) {\n        log.error(\"Exception parsing reordered query : \" + dbq, e);\n      }\n    }\n\n    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n    try {\n      IndexWriter writer = iw.get();\n\n      // see comment in deleteByQuery\n      synchronized (solrCoreState.getUpdateLock()) {\n        updateDocOrDocValues(cmd, writer);\n\n        if (cmd.isInPlaceUpdate() && ulog != null) {\n          ulog.openRealtimeSearcher(); // This is needed due to LUCENE-7344.\n        }\n        for (Query q : dbqList) {\n          writer.deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n        }\n        if (ulog != null) ulog.add(cmd, true); // this needs to be protected by update lock\n      }\n    } finally {\n      iw.decref();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["1adea4accc297f58fd9d8de3c820fd576eb0d396","415bbbe7da8065dd3c477bdc3c703c6425622998"],"740d649f013f07efbeb73ca854f106c60166e7c0":["c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"9133745ed58338ebe8daabe49076605b61fc6b86":["407b2e02aedce6b9118323ef204a08acfd83add7"],"407b2e02aedce6b9118323ef204a08acfd83add7":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"1adea4accc297f58fd9d8de3c820fd576eb0d396":["1a1888dae6d3c1d082a5aa627824792e4d694281"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["9133745ed58338ebe8daabe49076605b61fc6b86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"1a1888dae6d3c1d082a5aa627824792e4d694281":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","c5ce7c704ca874aa623a99f2669737b52ec71cfc"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","407b2e02aedce6b9118323ef204a08acfd83add7"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9133745ed58338ebe8daabe49076605b61fc6b86":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"407b2e02aedce6b9118323ef204a08acfd83add7":["9133745ed58338ebe8daabe49076605b61fc6b86"],"1adea4accc297f58fd9d8de3c820fd576eb0d396":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c5ce7c704ca874aa623a99f2669737b52ec71cfc","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["1a1888dae6d3c1d082a5aa627824792e4d694281"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["740d649f013f07efbeb73ca854f106c60166e7c0","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"1a1888dae6d3c1d082a5aa627824792e4d694281":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}