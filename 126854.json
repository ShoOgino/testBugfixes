{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","commits":[{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","sourceNew":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      // nocommit: this must be multiple asserts\n      //assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n      //  (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","sourceOld":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      // nocommit: this must be multiple asserts\n      //assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n      //  (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76f7066a3ec6e68e257b01dd46edbbdd3530690a","date":1358805020,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","sourceNew":null,"sourceOld":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      // nocommit: this must be multiple asserts\n      //assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n      //  (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"76f7066a3ec6e68e257b01dd46edbbdd3530690a":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["76f7066a3ec6e68e257b01dd46edbbdd3530690a"],"76f7066a3ec6e68e257b01dd46edbbdd3530690a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["76f7066a3ec6e68e257b01dd46edbbdd3530690a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}