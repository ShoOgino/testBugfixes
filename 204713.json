{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","commits":[{"id":"fdd61b10b980a6d0b8a8d63baf7e8f5e19e8437a","date":1363558184,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"/dev/null","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    MockTokenizer tokenizer = new MockTokenizer(new StringReader(\"one two three four five\"), MockTokenizer.WHITESPACE, false);\n    tokenizer.setEnableChecks(false); // LimitTokenPositionFilter doesn't consume the entire stream that it wraps\n    \n    SynonymMap.Builder builder = new SynonymMap.Builder(true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n    CharsRef multiWordCharsRef = new CharsRef();\n    SynonymMap.Builder.join(new String[] { \"and\", \"indubitably\", \"single\", \"only\" }, multiWordCharsRef);\n    builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n    SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n    builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n    SynonymMap synonymMap = builder.build();\n    TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n    stream = new LimitTokenPositionFilter(stream, 3); // consumeAllTokens defaults to false\n    \n    // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n    assertTokenStreamContents(stream, \n        new String[] { \"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\" },\n        new int[]    {     1,       0,       0,         0,    0,     1,              0,        0,       1,       0,         0 });\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338","date":1389274049,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n    tokenizer.setEnableChecks(false); // LimitTokenPositionFilter doesn't consume the entire stream that it wraps\n    \n    SynonymMap.Builder builder = new SynonymMap.Builder(true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n    CharsRef multiWordCharsRef = new CharsRef();\n    SynonymMap.Builder.join(new String[] { \"and\", \"indubitably\", \"single\", \"only\" }, multiWordCharsRef);\n    builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n    SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n    builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n    SynonymMap synonymMap = builder.build();\n    TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n    stream = new LimitTokenPositionFilter(stream, 3); // consumeAllTokens defaults to false\n    \n    // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n    assertTokenStreamContents(stream, \n        new String[] { \"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\" },\n        new int[]    {     1,       0,       0,         0,    0,     1,              0,        0,       1,       0,         0 });\n    \n  }\n\n","sourceOld":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    MockTokenizer tokenizer = new MockTokenizer(new StringReader(\"one two three four five\"), MockTokenizer.WHITESPACE, false);\n    tokenizer.setEnableChecks(false); // LimitTokenPositionFilter doesn't consume the entire stream that it wraps\n    \n    SynonymMap.Builder builder = new SynonymMap.Builder(true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n    CharsRef multiWordCharsRef = new CharsRef();\n    SynonymMap.Builder.join(new String[] { \"and\", \"indubitably\", \"single\", \"only\" }, multiWordCharsRef);\n    builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n    SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n    builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n    SynonymMap synonymMap = builder.build();\n    TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n    stream = new LimitTokenPositionFilter(stream, 3); // consumeAllTokens defaults to false\n    \n    // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n    assertTokenStreamContents(stream, \n        new String[] { \"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\" },\n        new int[]    {     1,       0,       0,         0,    0,     1,              0,        0,       1,       0,         0 });\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43acd3a99a12a5bec9c72097de0e294c80cb6daa","date":1396327381,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRef multiWordCharsRef = new CharsRef();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","sourceOld":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n    tokenizer.setEnableChecks(false); // LimitTokenPositionFilter doesn't consume the entire stream that it wraps\n    \n    SynonymMap.Builder builder = new SynonymMap.Builder(true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n    CharsRef multiWordCharsRef = new CharsRef();\n    SynonymMap.Builder.join(new String[] { \"and\", \"indubitably\", \"single\", \"only\" }, multiWordCharsRef);\n    builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n    SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n    builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n    SynonymMap synonymMap = builder.build();\n    TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n    stream = new LimitTokenPositionFilter(stream, 3); // consumeAllTokens defaults to false\n    \n    // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n    assertTokenStreamContents(stream, \n        new String[] { \"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\" },\n        new int[]    {     1,       0,       0,         0,    0,     1,              0,        0,       1,       0,         0 });\n    \n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRef multiWordCharsRef = new CharsRef();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","sourceOld":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n    tokenizer.setEnableChecks(false); // LimitTokenPositionFilter doesn't consume the entire stream that it wraps\n    \n    SynonymMap.Builder builder = new SynonymMap.Builder(true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n    builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n    CharsRef multiWordCharsRef = new CharsRef();\n    SynonymMap.Builder.join(new String[] { \"and\", \"indubitably\", \"single\", \"only\" }, multiWordCharsRef);\n    builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n    SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n    builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n    SynonymMap synonymMap = builder.build();\n    TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n    stream = new LimitTokenPositionFilter(stream, 3); // consumeAllTokens defaults to false\n    \n    // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n    assertTokenStreamContents(stream, \n        new String[] { \"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\" },\n        new int[]    {     1,       0,       0,         0,    0,     1,              0,        0,       1,       0,         0 });\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","sourceOld":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRef multiWordCharsRef = new CharsRef();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef, true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef, true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","bugFix":["43acd3a99a12a5bec9c72097de0e294c80cb6daa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  @SuppressWarnings(\"deprecation\")\n  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new org.apache.lucene.analysis.synonym.SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","sourceOld":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"deprecation\")\n  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new org.apache.lucene.analysis.synonym.SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestLimitTokenPositionFilter#testMaxPosition3WithSynomyms().mjava","sourceNew":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      @SuppressWarnings(\"deprecation\")\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","sourceOld":"  public void testMaxPosition3WithSynomyms() throws IOException {\n    for (final boolean consumeAll : new boolean[]{true, false}) {\n      MockTokenizer tokenizer = whitespaceMockTokenizer(\"one two three four five\");\n      // if we are consuming all tokens, we can use the checks, otherwise we can't\n      tokenizer.setEnableChecks(consumeAll);\n\n      SynonymMap.Builder builder = new SynonymMap.Builder(true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"first\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"alpha\"), true);\n      builder.add(new CharsRef(\"one\"), new CharsRef(\"beguine\"), true);\n      CharsRefBuilder multiWordCharsRef = new CharsRefBuilder();\n      SynonymMap.Builder.join(new String[]{\"and\", \"indubitably\", \"single\", \"only\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"one\"), multiWordCharsRef.get(), true);\n      SynonymMap.Builder.join(new String[]{\"dopple\", \"ganger\"}, multiWordCharsRef);\n      builder.add(new CharsRef(\"two\"), multiWordCharsRef.get(), true);\n      SynonymMap synonymMap = builder.build();\n      TokenStream stream = new SynonymFilter(tokenizer, synonymMap, true);\n      stream = new LimitTokenPositionFilter(stream, 3, consumeAll);\n\n      // \"only\", the 4th word of multi-word synonym \"and indubitably single only\" is not emitted, since its position is greater than 3.\n      assertTokenStreamContents(stream,\n          new String[]{\"one\", \"first\", \"alpha\", \"beguine\", \"and\", \"two\", \"indubitably\", \"dopple\", \"three\", \"single\", \"ganger\"},\n          new int[]{1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0});\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338","43acd3a99a12a5bec9c72097de0e294c80cb6daa"],"fdd61b10b980a6d0b8a8d63baf7e8f5e19e8437a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338":["fdd61b10b980a6d0b8a8d63baf7e8f5e19e8437a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["43acd3a99a12a5bec9c72097de0e294c80cb6daa"],"43acd3a99a12a5bec9c72097de0e294c80cb6daa":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"fdd61b10b980a6d0b8a8d63baf7e8f5e19e8437a":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338":["5eb2511ababf862ea11e10761c70ee560cd84510","43acd3a99a12a5bec9c72097de0e294c80cb6daa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fdd61b10b980a6d0b8a8d63baf7e8f5e19e8437a"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43acd3a99a12a5bec9c72097de0e294c80cb6daa":["5eb2511ababf862ea11e10761c70ee560cd84510","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}