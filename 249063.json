{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          }\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        if (log.isInfoEnabled()) {\n          log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n        }\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          }\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        if (log.isInfoEnabled()) {\n          log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n        }\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          }\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        if (log.isInfoEnabled()) {\n          log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n        }\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          }\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        if (log.isInfoEnabled()) {\n          log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n        }\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n            commitName, meta.toNamedList());\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}