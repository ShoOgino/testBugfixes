{"path":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Object,ModelRange,Integer,Object).mjava","commits":[{"id":"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45","date":1569046571,"type":1,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Object,ModelRange,Integer,Object).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Integer,ModelRange,Integer,Object).mjava","sourceNew":"  /**\n   * Helper method for validating a single 'bucket' from a Range facet.\n   *\n   * @param label to use in assertions\n   * @param expectedVal <code>\"val\"</code> to assert for this bucket, use <code>null</code> for special \"buckets\" like before, after, between.\n   * @param expectedRangeValues a range of the expected values in the numeric field whose cumulative counts should match this buckets <code>\"count\"</code>\n   * @param subFacetLimitUsed if null, then assert this bucket has no  <code>\"bar\"</code> subfacet, otherwise assert expected term counts for each actual term, and sanity check the number terms returnd against the model and/or this limit.\n   * @param actualBucket the actual bucket returned from a query for all assertions to be conducted against.\n   */\n  private static void assertBucket(final String label,\n                                   final Object expectedVal,\n                                   final ModelRange expectedRangeValues,\n                                   final Integer subFacetLimitUsed,\n                                   final Object actualBucket) {\n    try {\n      \n      assertNotNull(\"null bucket\", actualBucket);\n      assertNotNull(\"expectedRangeValues\", expectedRangeValues);\n      assertTrue(\"bucket is not a NamedList\", actualBucket instanceof NamedList);\n      final NamedList<Object> bucket = (NamedList<Object>) actualBucket;\n\n      if (null != expectedVal) {\n        assertEquals(\"val\", expectedVal, bucket.get(\"val\"));\n      }\n      \n      // figure out the model from our range of values...\n      long expectedCount = 0;\n      List<Map<String,Integer>> toMerge = new ArrayList<>(NUM_RANGE_VALUES);\n      for (int i = expectedRangeValues.lower; i <= expectedRangeValues.upper; i++) {\n        expectedCount += RANGE_MODEL[i];\n        toMerge.add(TERM_MODEL[i]);\n      }\n\n      assertEqualsHACK(\"count\", expectedCount, bucket.get(\"count\"));\n      \n      // merge the maps of our range values by summing the (int) values on key collisions\n      final Map<String,Long> expectedTermCounts = toMerge.stream()\n        .flatMap(m -> m.entrySet().stream())\n        .collect(Collectors.toMap(Entry::getKey, (e -> e.getValue().longValue()), Long::sum));\n\n      if (null == subFacetLimitUsed || 0 == expectedCount) {\n        assertNull(\"unexpected subfacets\", bucket.get(\"bar\"));\n      } else {\n        NamedList<Object> bar = ((NamedList<Object>)bucket.get(\"bar\"));\n        assertNotNull(\"can't find subfacet 'bar'\", bar);\n\n        final int numBucketsExpected = subFacetLimitUsed < 0\n          ? expectedTermCounts.size() : Math.min(subFacetLimitUsed, expectedTermCounts.size());\n        final List<NamedList<Object>> subBuckets = (List<NamedList<Object>>) bar.get(\"buckets\");\n        // we should either have filled out the expected limit, or \n        assertEquals(\"num subfacet buckets\", numBucketsExpected, subBuckets.size());\n\n        // assert sub-facet term counts for the subBuckets that do exist\n        for (NamedList<Object> subBucket : subBuckets) {\n          final Object term = subBucket.get(\"val\");\n          assertNotNull(\"subfacet bucket with null term: \" + subBucket, term);\n          final Long expectedTermCount = expectedTermCounts.get(term.toString());\n          assertNotNull(\"unexpected subfacet bucket: \" + subBucket, expectedTermCount);\n          assertEqualsHACK(\"subfacet count for term: \" + term, expectedTermCount, subBucket.get(\"count\"));\n        }\n      }\n        \n    } catch (AssertionError|RuntimeException ae) {\n      throw new AssertionError(label + \": \" + ae.getMessage(), ae);\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method for validating a single 'bucket' from a Range facet.\n   *\n   * @param label to use in assertions\n   * @param expectedVal <code>\"val\"</code> to assert for this bucket, use <code>null</code> for special \"buckets\" like before, after, between.\n   * @param expectedRangeValues a range of the expected values in the numeric field whose cumulative counts should match this buckets <code>\"count\"</code>\n   * @param subFacetLimitUsed if null, then assert this bucket has no  <code>\"bar\"</code> subfacet, otherwise assert expected term counts for each actual term, and sanity check the number terms returnd against the model and/or this limit.\n   * @param actualBucket the actual bucket returned from a query for all assertions to be conducted against.\n   */\n  private static void assertBucket(final String label,\n                                   final Integer expectedVal,\n                                   final ModelRange expectedRangeValues,\n                                   final Integer subFacetLimitUsed,\n                                   final Object actualBucket) {\n    try {\n      \n      assertNotNull(\"null bucket\", actualBucket);\n      assertNotNull(\"expectedRangeValues\", expectedRangeValues);\n      assertTrue(\"bucket is not a NamedList\", actualBucket instanceof NamedList);\n      final NamedList<Object> bucket = (NamedList<Object>) actualBucket;\n\n      if (null != expectedVal) {\n        assertEquals(\"val\", expectedVal, bucket.get(\"val\"));\n      }\n      \n      // figure out the model from our range of values...\n      long expectedCount = 0;\n      List<Map<String,Integer>> toMerge = new ArrayList<>(NUM_RANGE_VALUES);\n      for (int i = expectedRangeValues.lower; i <= expectedRangeValues.upper; i++) {\n        expectedCount += RANGE_MODEL[i];\n        toMerge.add(TERM_MODEL[i]);\n      }\n      \n      assertEqualsHACK(\"count\", expectedCount, bucket.get(\"count\"));\n      \n      // merge the maps of our range values by summing the (int) values on key collisions\n      final Map<String,Long> expectedTermCounts = toMerge.stream()\n        .flatMap(m -> m.entrySet().stream())\n        .collect(Collectors.toMap(Entry::getKey, (e -> e.getValue().longValue()), Long::sum));\n\n      if (null == subFacetLimitUsed || 0 == expectedCount) {\n        assertNull(\"unexpected subfacets\", bucket.get(\"bar\"));\n      } else {\n        NamedList<Object> bar = ((NamedList<Object>)bucket.get(\"bar\"));\n        assertNotNull(\"can't find subfacet 'bar'\", bar);\n\n        final int numBucketsExpected = subFacetLimitUsed < 0\n          ? expectedTermCounts.size() : Math.min(subFacetLimitUsed, expectedTermCounts.size());\n        final List<NamedList<Object>> subBuckets = (List<NamedList<Object>>) bar.get(\"buckets\");\n        // we should either have filled out the expected limit, or \n        assertEquals(\"num subfacet buckets\", numBucketsExpected, subBuckets.size());\n\n        // assert sub-facet term counts for the subBuckets that do exist\n        for (NamedList<Object> subBucket : subBuckets) {\n          final Object term = subBucket.get(\"val\");\n          assertNotNull(\"subfacet bucket with null term: \" + subBucket, term);\n          final Long expectedTermCount = expectedTermCounts.get(term.toString());\n          assertNotNull(\"unexpected subfacet bucket: \" + subBucket, expectedTermCount);\n          assertEqualsHACK(\"subfacet count for term: \" + term, expectedTermCount, subBucket.get(\"count\"));\n        }\n      }\n        \n    } catch (AssertionError|RuntimeException ae) {\n      throw new AssertionError(label + \": \" + ae.getMessage(), ae);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c841e27891873cab110ebeb89f124a8ec470176","date":1586527220,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Object,ModelRange,Integer,Object).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Object,ModelRange,Integer,Object).mjava","sourceNew":"  /**\n   * Helper method for validating a single 'bucket' from a Range facet.\n   *\n   * @param label to use in assertions\n   * @param expectedVal <code>\"val\"</code> to assert for this bucket, use <code>null</code> for special \"buckets\" like before, after, between.\n   * @param expectedRangeValues a range of the expected values in the numeric field whose cumulative counts should match this buckets <code>\"count\"</code>\n   * @param subFacetLimitUsed if null, then assert this bucket has no  <code>\"bar\"</code> subfacet, otherwise assert expected term counts for each actual term, and sanity check the number terms returnd against the model and/or this limit.\n   * @param actualBucket the actual bucket returned from a query for all assertions to be conducted against.\n   */\n  private static void assertBucket(final String label,\n                                   final Object expectedVal,\n                                   final ModelRange expectedRangeValues,\n                                   final Integer subFacetLimitUsed,\n                                   final Object actualBucket) {\n    try {\n      \n      assertNotNull(\"null bucket\", actualBucket);\n      assertNotNull(\"expectedRangeValues\", expectedRangeValues);\n      assertTrue(\"bucket is not a NamedList\", actualBucket instanceof NamedList);\n      final NamedList<Object> bucket = (NamedList<Object>) actualBucket;\n\n      if (null != expectedVal) {\n        assertEquals(\"val\", expectedVal, bucket.get(\"val\"));\n      }\n      \n      // figure out the model from our range of values...\n      long expectedCount = 0;\n      List<Map<String,Integer>> toMerge = new ArrayList<>(NUM_RANGE_VALUES);\n      for (int i = expectedRangeValues.lower; i <= expectedRangeValues.upper; i++) {\n        expectedCount += RANGE_MODEL[i];\n        toMerge.add(TERM_MODEL[i]);\n      }\n\n      assertEquals(\"count\", expectedCount, bucket.get(\"count\"));\n      \n      // merge the maps of our range values by summing the (int) values on key collisions\n      final Map<String,Long> expectedTermCounts = toMerge.stream()\n        .flatMap(m -> m.entrySet().stream())\n        .collect(Collectors.toMap(Entry::getKey, (e -> e.getValue().longValue()), Long::sum));\n\n      if (null == subFacetLimitUsed || 0 == expectedCount) {\n        assertNull(\"unexpected subfacets\", bucket.get(\"bar\"));\n      } else {\n        NamedList<Object> bar = ((NamedList<Object>)bucket.get(\"bar\"));\n        assertNotNull(\"can't find subfacet 'bar'\", bar);\n\n        final int numBucketsExpected = subFacetLimitUsed < 0\n          ? expectedTermCounts.size() : Math.min(subFacetLimitUsed, expectedTermCounts.size());\n        final List<NamedList<Object>> subBuckets = (List<NamedList<Object>>) bar.get(\"buckets\");\n        // we should either have filled out the expected limit, or \n        assertEquals(\"num subfacet buckets\", numBucketsExpected, subBuckets.size());\n\n        // assert sub-facet term counts for the subBuckets that do exist\n        for (NamedList<Object> subBucket : subBuckets) {\n          final Object term = subBucket.get(\"val\");\n          assertNotNull(\"subfacet bucket with null term: \" + subBucket, term);\n          final Long expectedTermCount = expectedTermCounts.get(term.toString());\n          assertNotNull(\"unexpected subfacet bucket: \" + subBucket, expectedTermCount);\n          assertEquals(\"subfacet count for term: \" + term, expectedTermCount, subBucket.get(\"count\"));\n        }\n      }\n        \n    } catch (AssertionError|RuntimeException ae) {\n      throw new AssertionError(label + \": \" + ae.getMessage(), ae);\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method for validating a single 'bucket' from a Range facet.\n   *\n   * @param label to use in assertions\n   * @param expectedVal <code>\"val\"</code> to assert for this bucket, use <code>null</code> for special \"buckets\" like before, after, between.\n   * @param expectedRangeValues a range of the expected values in the numeric field whose cumulative counts should match this buckets <code>\"count\"</code>\n   * @param subFacetLimitUsed if null, then assert this bucket has no  <code>\"bar\"</code> subfacet, otherwise assert expected term counts for each actual term, and sanity check the number terms returnd against the model and/or this limit.\n   * @param actualBucket the actual bucket returned from a query for all assertions to be conducted against.\n   */\n  private static void assertBucket(final String label,\n                                   final Object expectedVal,\n                                   final ModelRange expectedRangeValues,\n                                   final Integer subFacetLimitUsed,\n                                   final Object actualBucket) {\n    try {\n      \n      assertNotNull(\"null bucket\", actualBucket);\n      assertNotNull(\"expectedRangeValues\", expectedRangeValues);\n      assertTrue(\"bucket is not a NamedList\", actualBucket instanceof NamedList);\n      final NamedList<Object> bucket = (NamedList<Object>) actualBucket;\n\n      if (null != expectedVal) {\n        assertEquals(\"val\", expectedVal, bucket.get(\"val\"));\n      }\n      \n      // figure out the model from our range of values...\n      long expectedCount = 0;\n      List<Map<String,Integer>> toMerge = new ArrayList<>(NUM_RANGE_VALUES);\n      for (int i = expectedRangeValues.lower; i <= expectedRangeValues.upper; i++) {\n        expectedCount += RANGE_MODEL[i];\n        toMerge.add(TERM_MODEL[i]);\n      }\n\n      assertEqualsHACK(\"count\", expectedCount, bucket.get(\"count\"));\n      \n      // merge the maps of our range values by summing the (int) values on key collisions\n      final Map<String,Long> expectedTermCounts = toMerge.stream()\n        .flatMap(m -> m.entrySet().stream())\n        .collect(Collectors.toMap(Entry::getKey, (e -> e.getValue().longValue()), Long::sum));\n\n      if (null == subFacetLimitUsed || 0 == expectedCount) {\n        assertNull(\"unexpected subfacets\", bucket.get(\"bar\"));\n      } else {\n        NamedList<Object> bar = ((NamedList<Object>)bucket.get(\"bar\"));\n        assertNotNull(\"can't find subfacet 'bar'\", bar);\n\n        final int numBucketsExpected = subFacetLimitUsed < 0\n          ? expectedTermCounts.size() : Math.min(subFacetLimitUsed, expectedTermCounts.size());\n        final List<NamedList<Object>> subBuckets = (List<NamedList<Object>>) bar.get(\"buckets\");\n        // we should either have filled out the expected limit, or \n        assertEquals(\"num subfacet buckets\", numBucketsExpected, subBuckets.size());\n\n        // assert sub-facet term counts for the subBuckets that do exist\n        for (NamedList<Object> subBucket : subBuckets) {\n          final Object term = subBucket.get(\"val\");\n          assertNotNull(\"subfacet bucket with null term: \" + subBucket, term);\n          final Long expectedTermCount = expectedTermCounts.get(term.toString());\n          assertNotNull(\"unexpected subfacet bucket: \" + subBucket, expectedTermCount);\n          assertEqualsHACK(\"subfacet count for term: \" + term, expectedTermCount, subBucket.get(\"count\"));\n        }\n      }\n        \n    } catch (AssertionError|RuntimeException ae) {\n      throw new AssertionError(label + \": \" + ae.getMessage(), ae);\n    }\n  }\n\n","bugFix":["c05b634713ca09b2267477408773904d4c69dd9d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Object,ModelRange,Integer,Object).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/RangeFacetCloudTest#assertBucket(String,Object,ModelRange,Integer,Object).mjava","sourceNew":"  /**\n   * Helper method for validating a single 'bucket' from a Range facet.\n   *\n   * @param label to use in assertions\n   * @param expectedVal <code>\"val\"</code> to assert for this bucket, use <code>null</code> for special \"buckets\" like before, after, between.\n   * @param expectedRangeValues a range of the expected values in the numeric field whose cumulative counts should match this buckets <code>\"count\"</code>\n   * @param subFacetLimitUsed if null, then assert this bucket has no  <code>\"bar\"</code> subfacet, otherwise assert expected term counts for each actual term, and sanity check the number terms returnd against the model and/or this limit.\n   * @param actualBucket the actual bucket returned from a query for all assertions to be conducted against.\n   */\n  private static void assertBucket(final String label,\n                                   final Object expectedVal,\n                                   final ModelRange expectedRangeValues,\n                                   final Integer subFacetLimitUsed,\n                                   final Object actualBucket) {\n    try {\n      \n      assertNotNull(\"null bucket\", actualBucket);\n      assertNotNull(\"expectedRangeValues\", expectedRangeValues);\n      assertTrue(\"bucket is not a NamedList\", actualBucket instanceof NamedList);\n      @SuppressWarnings({\"unchecked\"})\n      final NamedList<Object> bucket = (NamedList<Object>) actualBucket;\n\n      if (null != expectedVal) {\n        assertEquals(\"val\", expectedVal, bucket.get(\"val\"));\n      }\n      \n      // figure out the model from our range of values...\n      long expectedCount = 0;\n      List<Map<String,Integer>> toMerge = new ArrayList<>(NUM_RANGE_VALUES);\n      for (int i = expectedRangeValues.lower; i <= expectedRangeValues.upper; i++) {\n        expectedCount += RANGE_MODEL[i];\n        toMerge.add(TERM_MODEL[i]);\n      }\n\n      assertEquals(\"count\", expectedCount, bucket.get(\"count\"));\n      \n      // merge the maps of our range values by summing the (int) values on key collisions\n      final Map<String,Long> expectedTermCounts = toMerge.stream()\n        .flatMap(m -> m.entrySet().stream())\n        .collect(Collectors.toMap(Entry::getKey, (e -> e.getValue().longValue()), Long::sum));\n\n      if (null == subFacetLimitUsed || 0 == expectedCount) {\n        assertNull(\"unexpected subfacets\", bucket.get(\"bar\"));\n      } else {\n        @SuppressWarnings({\"unchecked\"})\n        NamedList<Object> bar = ((NamedList<Object>)bucket.get(\"bar\"));\n        assertNotNull(\"can't find subfacet 'bar'\", bar);\n\n        final int numBucketsExpected = subFacetLimitUsed < 0\n          ? expectedTermCounts.size() : Math.min(subFacetLimitUsed, expectedTermCounts.size());\n        @SuppressWarnings({\"unchecked\"})\n        final List<NamedList<Object>> subBuckets = (List<NamedList<Object>>) bar.get(\"buckets\");\n        // we should either have filled out the expected limit, or \n        assertEquals(\"num subfacet buckets\", numBucketsExpected, subBuckets.size());\n\n        // assert sub-facet term counts for the subBuckets that do exist\n        for (NamedList<Object> subBucket : subBuckets) {\n          final Object term = subBucket.get(\"val\");\n          assertNotNull(\"subfacet bucket with null term: \" + subBucket, term);\n          final Long expectedTermCount = expectedTermCounts.get(term.toString());\n          assertNotNull(\"unexpected subfacet bucket: \" + subBucket, expectedTermCount);\n          assertEquals(\"subfacet count for term: \" + term, expectedTermCount, subBucket.get(\"count\"));\n        }\n      }\n        \n    } catch (AssertionError|RuntimeException ae) {\n      throw new AssertionError(label + \": \" + ae.getMessage(), ae);\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method for validating a single 'bucket' from a Range facet.\n   *\n   * @param label to use in assertions\n   * @param expectedVal <code>\"val\"</code> to assert for this bucket, use <code>null</code> for special \"buckets\" like before, after, between.\n   * @param expectedRangeValues a range of the expected values in the numeric field whose cumulative counts should match this buckets <code>\"count\"</code>\n   * @param subFacetLimitUsed if null, then assert this bucket has no  <code>\"bar\"</code> subfacet, otherwise assert expected term counts for each actual term, and sanity check the number terms returnd against the model and/or this limit.\n   * @param actualBucket the actual bucket returned from a query for all assertions to be conducted against.\n   */\n  private static void assertBucket(final String label,\n                                   final Object expectedVal,\n                                   final ModelRange expectedRangeValues,\n                                   final Integer subFacetLimitUsed,\n                                   final Object actualBucket) {\n    try {\n      \n      assertNotNull(\"null bucket\", actualBucket);\n      assertNotNull(\"expectedRangeValues\", expectedRangeValues);\n      assertTrue(\"bucket is not a NamedList\", actualBucket instanceof NamedList);\n      final NamedList<Object> bucket = (NamedList<Object>) actualBucket;\n\n      if (null != expectedVal) {\n        assertEquals(\"val\", expectedVal, bucket.get(\"val\"));\n      }\n      \n      // figure out the model from our range of values...\n      long expectedCount = 0;\n      List<Map<String,Integer>> toMerge = new ArrayList<>(NUM_RANGE_VALUES);\n      for (int i = expectedRangeValues.lower; i <= expectedRangeValues.upper; i++) {\n        expectedCount += RANGE_MODEL[i];\n        toMerge.add(TERM_MODEL[i]);\n      }\n\n      assertEquals(\"count\", expectedCount, bucket.get(\"count\"));\n      \n      // merge the maps of our range values by summing the (int) values on key collisions\n      final Map<String,Long> expectedTermCounts = toMerge.stream()\n        .flatMap(m -> m.entrySet().stream())\n        .collect(Collectors.toMap(Entry::getKey, (e -> e.getValue().longValue()), Long::sum));\n\n      if (null == subFacetLimitUsed || 0 == expectedCount) {\n        assertNull(\"unexpected subfacets\", bucket.get(\"bar\"));\n      } else {\n        NamedList<Object> bar = ((NamedList<Object>)bucket.get(\"bar\"));\n        assertNotNull(\"can't find subfacet 'bar'\", bar);\n\n        final int numBucketsExpected = subFacetLimitUsed < 0\n          ? expectedTermCounts.size() : Math.min(subFacetLimitUsed, expectedTermCounts.size());\n        final List<NamedList<Object>> subBuckets = (List<NamedList<Object>>) bar.get(\"buckets\");\n        // we should either have filled out the expected limit, or \n        assertEquals(\"num subfacet buckets\", numBucketsExpected, subBuckets.size());\n\n        // assert sub-facet term counts for the subBuckets that do exist\n        for (NamedList<Object> subBucket : subBuckets) {\n          final Object term = subBucket.get(\"val\");\n          assertNotNull(\"subfacet bucket with null term: \" + subBucket, term);\n          final Long expectedTermCount = expectedTermCounts.get(term.toString());\n          assertNotNull(\"unexpected subfacet bucket: \" + subBucket, expectedTermCount);\n          assertEquals(\"subfacet count for term: \" + term, expectedTermCount, subBucket.get(\"count\"));\n        }\n      }\n        \n    } catch (AssertionError|RuntimeException ae) {\n      throw new AssertionError(label + \": \" + ae.getMessage(), ae);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1c841e27891873cab110ebeb89f124a8ec470176":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["1c841e27891873cab110ebeb89f124a8ec470176"]},"commit2Childs":{"1c841e27891873cab110ebeb89f124a8ec470176":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["1c841e27891873cab110ebeb89f124a8ec470176"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}